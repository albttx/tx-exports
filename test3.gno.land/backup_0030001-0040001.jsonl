{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14vhcdsyf83ngsrrqc92kmw8q9xakqjm0v8448t","send":"","pkg_path":"gno.land/r/demo/minter","func":"Mint","args":["g1un6eduj3js40765mmakejyuez8x6t4sp44q99p","ugnot","310000000"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgiTyNXOXskkkxKv2DXaDxFtabuTPHlltbYwCOBpHL3w"},"signature":"aKgQTM3ZN+LlZQyFWPZAOWfHNIjXkMj1UuVm/fxaRi1I60138oQQozV1CU+bCQ34X/FhyMLwRBhLKUCYhjleUQ=="}],"memo":""},"blockNum":"35777"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/demo/tong","func":"Transfer","args":["g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","2"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"V7YjKAY0cVmdMAt+YDaXiykRoU4goSBjrAf20EslU/JnmBVLmXzWIdRA3U3UxldJzXvB6qUe5XABoiCjM76hJQ=="}],"memo":""},"blockNum":"37028"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"Name":"flippando","Path":"gno.land/p/demo/flippando","Files":[{"Name":"flippando.gno","Body":"package flippando\n\nimport (\n\t\"math\"\n\t\"std\"\n\n\t\"gno.land/p/demo/rand\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype game struct {\n\towner     string\n\tgameId    string\n\tboard     []int\n\ttileType  string\n\tgameTiles []int\n\tboardSize int\n\tstatus    string\n}\n\n// owner - 'address', gameId - 'string', board - [int], tileType - 'coloredSquare', 'dice', 'hexagram', gameTiles - [int], boardSize - {4, 8}, status - 'created | ongoing | solved'\n\ntype positions struct {\n\tposition1 int\n\tposition2 int\n}\n\n// position1 - int, postion2 - int\n\ntype inTransit struct {\n\ttokenId   int\n\tinTransit bool\n}\n\n// tokenId - int, inTransit, bool\n\nfunc flipTiles(board []int, solvedBoard []int, gameTiles []int, positions positions) ([]int, []int) {\n\t//   - returns the tiles at the positions[] in the board array\n\t//   - updates the game[gameId].board with the indices at positions\n\n\t// pos := positions\n\t// optimize for one call, and use the tuple?\n\trandomNumberSlice := generateRandomNumbers(2, 1, len(board))\n\t// randomNumber1 := generateRandomNumbers(1, 1, len(board))\n\t// randomNumber2 := generateRandomNumbers(1, 1, len(board))\n\n\tif board[positions.position1] == 0 {\n\t\tboard[positions.position1] = gameTiles[randomNumberSlice[0]]\n\t}\n\n\tif board[positions.position2] == 0 {\n\t\tboard[positions.position2] = gameTiles[randomNumberSlice[1]]\n\t}\n\n\tif board[positions.position1] == board[positions.position2] {\n\t\tsolvedBoard[positions.position1] = board[positions.position1]\n\t\tsolvedBoard[positions.position2] = board[positions.position2]\n\t}\n\n\t// enforce solvability\n\tquantumThreshold := int(sqrt(float64(len(board))))\n\tunsolvedTiles := 0\n\n\tfor j := 0; j \u003c len(board); j++ {\n\t\tif solvedBoard[j] == 0 {\n\t\t\tunsolvedTiles++\n\t\t}\n\t}\n\n\tif unsolvedTiles \u003c= quantumThreshold {\n\t\t// replace the board with solvedBoard and redeploy\n\t\tif board[positions.position1] != board[positions.position2] {\n\t\t\tboard[positions.position1] = board[positions.position2]\n\t\t\tsolvedBoard[positions.position1] = board[positions.position1]\n\t\t\tsolvedBoard[positions.position2] = board[positions.position2]\n\t\t}\n\t}\n\n\treturn board, solvedBoard\n\n\t// check for game solved\n\t// todo: promote this check to the realm? that's where we send user events\n\t/*\n\t   unsolvedTiles = 0\n\n\t   for j := 0; j \u003c len(board); j++ {\n\t       if(solvedBoard[j] == 0){\n\t           unsolvedTiles = unsolvedTiles + 1\n\t       }\n\t   }\n\t   if(unsolvedTiles == 0){\n\t       // call flippandoGameMaster finishGame\n\t       flippandoGameMaster.finishGame(id, games[id].player);\n\t       emit GameSolved(id, games[id])\n\t   }*/\n}\n\nfunc createNFT(gameId string) {\n\t// - generates a GRC721 token with the solved board SVG as a tokenURI\n}\n\nfunc makeArt(owner string, buildingBlocks []int) {\n\t// - checks if any of the tokenIds in the buildingBlocks[] are belonging to the user (not allowed)\n\t// - checks if any of the tokenIds in the buildingBlocks[] are in transit\n\t// - unlocks and sends the locked Flips in each used NFT\n\t// - transfers the NFTs to the new owner (the art creator)\n\t// - calls FlippandoBundler.bundleAssets() to generate a new GRC721 NFT with a standard tokenURI, and the tokenIds of the used NFT primitives\n}\n\n/*\nvar randIntn = func(n int) int {\n\treturn rand.Intn(n)\n}*/\n\nfunc generateRandomNumbers(num, start, end int) []int {\n\tif start \u003e end {\n\t\tstart, end = end, start // Ensure the range is in ascending order\n\t}\n\n\tif num \u003c 0 {\n\t\tufmt.Sprintf(\"The number of random values (num) must be non-negative\")\n\t\treturn nil\n\t}\n\n\tif num \u003e end-start+1 {\n\t\tufmt.Sprintf(\"The number of random values (num) cannot exceed the range size\")\n\t\treturn nil\n\t}\n\n\t// Seed the random number generator with the current time\n\tr := rand.New()\n\n\t// Generate num unique random values within the range\n\tresult := make([]int, 0, num)\n\tfor len(result) \u003c num {\n\t\trandomValue := r.Intn(end-start+1) + start\n\n\t\t// Check if the value already exists in the result slice\n\t\t// If not, append it to the result slice\n\t\tunique := true\n\t\tfor _, val := range result {\n\t\t\tif val == randomValue {\n\t\t\t\tunique = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif unique {\n\t\t\tresult = append(result, randomValue)\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc sqrt(x float64) float64 {\n\tif x == 0 || x == 1 {\n\t\treturn x\n\t}\n\n\t// Start with an initial guess\n\tguess := x / 2.0\n\tprevGuess := 0.0\n\n\t// Use a small threshold to determine when to stop the approximation\n\tconst threshold = 0.00001\n\n\t// Use math.Abs to calculate the absolute value\n\tabs := func(f float64) float64 {\n\t\tif f \u003c 0 {\n\t\t\treturn -f\n\t\t}\n\t\treturn f\n\t}\n\n\tfor abs(guess-prevGuess) \u003e threshold {\n\t\tprevGuess = guess\n\t\tguess = 0.5 * (guess + x/guess)\n\t}\n\n\treturn guess\n}\n"},{"Name":"flippando_test.gno","Body":"package flippando\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/rand\"\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestGenerateRandomNumbers(t *testing.T) {\n\t// Create an instance of your custom deterministic random number generator.\n\trandInstance := rand.New() // Use your custom Instance type here\n\n\t// Test case 1: Positive test case\n\trandomValues := generateRandomNumbers(4, 1, 4)\n\texpectedValues := []int{2, 3, 1, 4}\n\tif !sliceEqual(randomValues, expectedValues) {\n\t\tt.Fatalf(\"Expected %v, but got %v\", expectedValues, randomValues)\n\t}\n\n\t// Test case 2: Edge case with num exceeding the range size\n\trandomValues = generateRandomNumbers(10, 1, 4)\n\tif randomValues != nil {\n\t\tt.Fatalf(\"Expected nil for num exceeding range size, but got %v\", randomValues)\n\t}\n}\n\n// Helper function to compare two slices for equality\nfunc sliceEqual(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"fpPg1LzkM1zsofN7qM8SalCmc/cUvpJgNmmazNCrzQxBwJ1yc0JMqduK7ucHQ4F68R4zPSZJJRA5Ory5D0vj4g=="}],"memo":""},"blockNum":"39566"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"Name":"flippando","Path":"gno.land/p/demo/flippando","Files":[{"Name":"flippando.gno","Body":"package flippando\n\nimport (\n\t\"math\"\n\t\"std\"\n\n\t\"gno.land/p/demo/rand\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype game struct {\n\towner     string\n\tgameId    string\n\tboard     []int\n\ttileType  string\n\tgameTiles []int\n\tboardSize int\n\tstatus    string\n}\n\n// owner - 'address', gameId - 'string', board - [int], tileType - 'coloredSquare', 'dice', 'hexagram', gameTiles - [int], boardSize - {4, 8}, status - 'created | ongoing | solved'\n\ntype positions struct {\n\tposition1 int\n\tposition2 int\n}\n\n// position1 - int, postion2 - int\n\ntype inTransit struct {\n\ttokenId   int\n\tinTransit bool\n}\n\n// tokenId - int, inTransit, bool\n\nfunc flipTiles(board []int, solvedBoard []int, gameTiles []int, positions positions) ([]int, []int) {\n\t//   - returns the tiles at the positions[] in the board array\n\t//   - updates the game[gameId].board with the indices at positions\n\n\t// pos := positions\n\t// optimize for one call, and use the tuple?\n\trandomNumberSlice := generateRandomNumbers(2, 1, len(board))\n\t// randomNumber1 := generateRandomNumbers(1, 1, len(board))\n\t// randomNumber2 := generateRandomNumbers(1, 1, len(board))\n\n\tif board[positions.position1] == 0 {\n\t\tboard[positions.position1] = gameTiles[randomNumberSlice[0]]\n\t}\n\n\tif board[positions.position2] == 0 {\n\t\tboard[positions.position2] = gameTiles[randomNumberSlice[1]]\n\t}\n\n\tif board[positions.position1] == board[positions.position2] {\n\t\tsolvedBoard[positions.position1] = board[positions.position1]\n\t\tsolvedBoard[positions.position2] = board[positions.position2]\n\t}\n\n\t// enforce solvability\n\tquantumThreshold := int(sqrt(float64(len(board))))\n\tunsolvedTiles := 0\n\n\tfor j := 0; j \u003c len(board); j++ {\n\t\tif solvedBoard[j] == 0 {\n\t\t\tunsolvedTiles++\n\t\t}\n\t}\n\n\tif unsolvedTiles \u003c= quantumThreshold {\n\t\t// replace the board with solvedBoard and redeploy\n\t\tif board[positions.position1] != board[positions.position2] {\n\t\t\tboard[positions.position1] = board[positions.position2]\n\t\t\tsolvedBoard[positions.position1] = board[positions.position1]\n\t\t\tsolvedBoard[positions.position2] = board[positions.position2]\n\t\t}\n\t}\n\n\treturn board, solvedBoard\n\n\t// check for game solved\n\t// todo: promote this check to the realm? that's where we send user events\n\t/*\n\t   unsolvedTiles = 0\n\n\t   for j := 0; j \u003c len(board); j++ {\n\t       if(solvedBoard[j] == 0){\n\t           unsolvedTiles = unsolvedTiles + 1\n\t       }\n\t   }\n\t   if(unsolvedTiles == 0){\n\t       // call flippandoGameMaster finishGame\n\t       flippandoGameMaster.finishGame(id, games[id].player);\n\t       emit GameSolved(id, games[id])\n\t   }*/\n}\n\nfunc createNFT(gameId string) {\n\t// - generates a GRC721 token with the solved board SVG as a tokenURI\n}\n\nfunc makeArt(owner string, buildingBlocks []int) {\n\t// - checks if any of the tokenIds in the buildingBlocks[] are belonging to the user (not allowed)\n\t// - checks if any of the tokenIds in the buildingBlocks[] are in transit\n\t// - unlocks and sends the locked Flips in each used NFT\n\t// - transfers the NFTs to the new owner (the art creator)\n\t// - calls FlippandoBundler.bundleAssets() to generate a new GRC721 NFT with a standard tokenURI, and the tokenIds of the used NFT primitives\n}\n\n/*\nvar randIntn = func(n int) int {\n\treturn rand.Intn(n)\n}*/\n\nfunc generateRandomNumbers(num, start, end int) []int {\n\tif start \u003e end {\n\t\tstart, end = end, start // Ensure the range is in ascending order\n\t}\n\n\tif num \u003c 0 {\n\t\tufmt.Sprintf(\"The number of random values (num) must be non-negative\")\n\t\treturn nil\n\t}\n\n\tif num \u003e end-start+1 {\n\t\tufmt.Sprintf(\"The number of random values (num) cannot exceed the range size\")\n\t\treturn nil\n\t}\n\n\t// Seed the random number generator with the current time\n\tr := rand.New()\n\n\t// Generate num unique random values within the range\n\tresult := make([]int, 0, num)\n\tfor len(result) \u003c num {\n\t\trandomValue := r.Intn(end-start+1) + start\n\n\t\t// Check if the value already exists in the result slice\n\t\t// If not, append it to the result slice\n\t\tunique := true\n\t\tfor _, val := range result {\n\t\t\tif val == randomValue {\n\t\t\t\tunique = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif unique {\n\t\t\tresult = append(result, randomValue)\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc sqrt(x float64) float64 {\n\tif x == 0 || x == 1 {\n\t\treturn x\n\t}\n\n\t// Start with an initial guess\n\tguess := x / 2.0\n\tprevGuess := 0.0\n\n\t// Use a small threshold to determine when to stop the approximation\n\tconst threshold = 0.00001\n\n\t// Use math.Abs to calculate the absolute value\n\tabs := func(f float64) float64 {\n\t\tif f \u003c 0 {\n\t\t\treturn -f\n\t\t}\n\t\treturn f\n\t}\n\n\tfor abs(guess-prevGuess) \u003e threshold {\n\t\tprevGuess = guess\n\t\tguess = 0.5 * (guess + x/guess)\n\t}\n\n\treturn guess\n}\n"},{"Name":"flippando_test.gno","Body":"package flippando\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/rand\"\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestGenerateRandomNumbers(t *testing.T) {\n\t// Create an instance of your custom deterministic random number generator.\n\trandInstance := rand.New() // Use your custom Instance type here\n\n\t// Test case 1: Positive test case\n\trandomValues := generateRandomNumbers(4, 1, 4)\n\texpectedValues := []int{2, 3, 1, 4}\n\tif !sliceEqual(randomValues, expectedValues) {\n\t\tt.Fatalf(\"Expected %v, but got %v\", expectedValues, randomValues)\n\t}\n\n\t// Test case 2: Edge case with num exceeding the range size\n\trandomValues = generateRandomNumbers(10, 1, 4)\n\tif randomValues != nil {\n\t\tt.Fatalf(\"Expected nil for num exceeding range size, but got %v\", randomValues)\n\t}\n}\n\n// Helper function to compare two slices for equality\nfunc sliceEqual(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"YYs7WMBui7TDMK0Kg/K7vUMlZ6iuBNuoJm2aN175z2chbYuSL/UfA315u4bDPVZhvAlBuhxKy7hKsdiXrlmkSA=="}],"memo":""},"blockNum":"39569"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"Name":"flippando","Path":"gno.land/p/demo/flippando","Files":[{"Name":"flippando.gno","Body":"package flippando\n\nimport (\n\t\"math\"\n\t\"std\"\n\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype game struct {\n\towner     string\n\tgameId    string\n\tboard     []int\n\ttileType  string\n\tgameTiles []int\n\tboardSize int\n\tstatus    string\n}\n\n// owner - 'address', gameId - 'string', board - [int], tileType - 'coloredSquare', 'dice', 'hexagram', gameTiles - [int], boardSize - {4, 8}, status - 'created | ongoing | solved'\n\ntype positions struct {\n\tposition1 int\n\tposition2 int\n}\n\n// position1 - int, postion2 - int\n\ntype inTransit struct {\n\ttokenId   int\n\tinTransit bool\n}\n\n// tokenId - int, inTransit, bool\n\nfunc flipTiles(board []int, solvedBoard []int, gameTiles []int, positions positions) ([]int, []int) {\n\t//   - returns the tiles at the positions[] in the board array\n\t//   - updates the game[gameId].board with the indices at positions\n\n\t// pos := positions\n\t// optimize for one call, and use the tuple?\n\trandomNumberSlice := generateRandomNumbers(2, 1, len(board))\n\t// randomNumber1 := generateRandomNumbers(1, 1, len(board))\n\t// randomNumber2 := generateRandomNumbers(1, 1, len(board))\n\n\tif board[positions.position1] == 0 {\n\t\tboard[positions.position1] = gameTiles[randomNumberSlice[0]]\n\t}\n\n\tif board[positions.position2] == 0 {\n\t\tboard[positions.position2] = gameTiles[randomNumberSlice[1]]\n\t}\n\n\tif board[positions.position1] == board[positions.position2] {\n\t\tsolvedBoard[positions.position1] = board[positions.position1]\n\t\tsolvedBoard[positions.position2] = board[positions.position2]\n\t}\n\n\t// enforce solvability\n\tquantumThreshold := int(sqrt(float64(len(board))))\n\tunsolvedTiles := 0\n\n\tfor j := 0; j \u003c len(board); j++ {\n\t\tif solvedBoard[j] == 0 {\n\t\t\tunsolvedTiles++\n\t\t}\n\t}\n\n\tif unsolvedTiles \u003c= quantumThreshold {\n\t\t// replace the board with solvedBoard and redeploy\n\t\tif board[positions.position1] != board[positions.position2] {\n\t\t\tboard[positions.position1] = board[positions.position2]\n\t\t\tsolvedBoard[positions.position1] = board[positions.position1]\n\t\t\tsolvedBoard[positions.position2] = board[positions.position2]\n\t\t}\n\t}\n\n\treturn board, solvedBoard\n\n\t// check for game solved\n\t// todo: promote this check to the realm? that's where we send user events\n\t/*\n\t   unsolvedTiles = 0\n\n\t   for j := 0; j \u003c len(board); j++ {\n\t       if(solvedBoard[j] == 0){\n\t           unsolvedTiles = unsolvedTiles + 1\n\t       }\n\t   }\n\t   if(unsolvedTiles == 0){\n\t       // call flippandoGameMaster finishGame\n\t       flippandoGameMaster.finishGame(id, games[id].player);\n\t       emit GameSolved(id, games[id])\n\t   }*/\n}\n\nfunc createNFT(gameId string) {\n\t// - generates a GRC721 token with the solved board SVG as a tokenURI\n}\n\nfunc makeArt(owner string, buildingBlocks []int) {\n\t// - checks if any of the tokenIds in the buildingBlocks[] are belonging to the user (not allowed)\n\t// - checks if any of the tokenIds in the buildingBlocks[] are in transit\n\t// - unlocks and sends the locked Flips in each used NFT\n\t// - transfers the NFTs to the new owner (the art creator)\n\t// - calls FlippandoBundler.bundleAssets() to generate a new GRC721 NFT with a standard tokenURI, and the tokenIds of the used NFT primitives\n}\n\n/*\nvar randIntn = func(n int) int {\n\treturn rand.Intn(n)\n}*/\n\nfunc generateRandomNumbers(num, start, end int) []int {\n\tif start \u003e end {\n\t\tstart, end = end, start // Ensure the range is in ascending order\n\t}\n\n\tif num \u003c 0 {\n\t\tufmt.Sprintf(\"The number of random values (num) must be non-negative\")\n\t\treturn nil\n\t}\n\n\tif num \u003e end-start+1 {\n\t\tufmt.Sprintf(\"The number of random values (num) cannot exceed the range size\")\n\t\treturn nil\n\t}\n\n\t// Seed the random number generator with the current time\n\tr := rand.New()\n\n\t// Generate num unique random values within the range\n\tresult := make([]int, 0, num)\n\tfor len(result) \u003c num {\n\t\trandomValue := r.Intn(end-start+1) + start\n\n\t\t// Check if the value already exists in the result slice\n\t\t// If not, append it to the result slice\n\t\tunique := true\n\t\tfor _, val := range result {\n\t\t\tif val == randomValue {\n\t\t\t\tunique = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif unique {\n\t\t\tresult = append(result, randomValue)\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc sqrt(x float64) float64 {\n\tif x == 0 || x == 1 {\n\t\treturn x\n\t}\n\n\t// Start with an initial guess\n\tguess := x / 2.0\n\tprevGuess := 0.0\n\n\t// Use a small threshold to determine when to stop the approximation\n\tconst threshold = 0.00001\n\n\t// Use math.Abs to calculate the absolute value\n\tabs := func(f float64) float64 {\n\t\tif f \u003c 0 {\n\t\t\treturn -f\n\t\t}\n\t\treturn f\n\t}\n\n\tfor abs(guess-prevGuess) \u003e threshold {\n\t\tprevGuess = guess\n\t\tguess = 0.5 * (guess + x/guess)\n\t}\n\n\treturn guess\n}\n"},{"Name":"flippando_test.gno","Body":"package flippando\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/rand\"\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestGenerateRandomNumbers(t *testing.T) {\n\t// Create an instance of your custom deterministic random number generator.\n\trandInstance := rand.New() // Use your custom Instance type here\n\n\t// Test case 1: Positive test case\n\trandomValues := generateRandomNumbers(4, 1, 4)\n\texpectedValues := []int{2, 3, 1, 4}\n\tif !sliceEqual(randomValues, expectedValues) {\n\t\tt.Fatalf(\"Expected %v, but got %v\", expectedValues, randomValues)\n\t}\n\n\t// Test case 2: Edge case with num exceeding the range size\n\trandomValues = generateRandomNumbers(10, 1, 4)\n\tif randomValues != nil {\n\t\tt.Fatalf(\"Expected nil for num exceeding range size, but got %v\", randomValues)\n\t}\n}\n\n// Helper function to compare two slices for equality\nfunc sliceEqual(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"g0WH04zhqhnQM7MY+vbBRJD1eW6hPWrf0JpGustleSQZBHg6l/S4PItb5kypEQ54THZ7T1CkbRECJ2xtTP7PJg=="}],"memo":""},"blockNum":"39571"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"Name":"flippando","Path":"gno.land/p/demo/flippando","Files":[{"Name":"flippando.gno","Body":"package flippando\n\nimport (\n\t\"math\"\n\t\"std\"\n\n\t\"gno.land/p/demo/rand\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype game struct {\n\towner     string\n\tgameId    string\n\tboard     []int\n\ttileType  string\n\tgameTiles []int\n\tboardSize int\n\tstatus    string\n}\n\n// owner - 'address', gameId - 'string', board - [int], tileType - 'coloredSquare', 'dice', 'hexagram', gameTiles - [int], boardSize - {4, 8}, status - 'created | ongoing | solved'\n\ntype positions struct {\n\tposition1 int\n\tposition2 int\n}\n\n// position1 - int, postion2 - int\n\ntype inTransit struct {\n\ttokenId   int\n\tinTransit bool\n}\n\n// tokenId - int, inTransit, bool\n\nfunc flipTiles(board []int, solvedBoard []int, gameTiles []int, positions positions) ([]int, []int) {\n\t//   - returns the tiles at the positions[] in the board array\n\t//   - updates the game[gameId].board with the indices at positions\n\n\t// pos := positions\n\t// optimize for one call, and use the tuple?\n\trandomNumberSlice := generateRandomNumbers(2, 1, len(board))\n\t// randomNumber1 := generateRandomNumbers(1, 1, len(board))\n\t// randomNumber2 := generateRandomNumbers(1, 1, len(board))\n\n\tif board[positions.position1] == 0 {\n\t\tboard[positions.position1] = gameTiles[randomNumberSlice[0]]\n\t}\n\n\tif board[positions.position2] == 0 {\n\t\tboard[positions.position2] = gameTiles[randomNumberSlice[1]]\n\t}\n\n\tif board[positions.position1] == board[positions.position2] {\n\t\tsolvedBoard[positions.position1] = board[positions.position1]\n\t\tsolvedBoard[positions.position2] = board[positions.position2]\n\t}\n\n\t// enforce solvability\n\tquantumThreshold := int(sqrt(float64(len(board))))\n\tunsolvedTiles := 0\n\n\tfor j := 0; j \u003c len(board); j++ {\n\t\tif solvedBoard[j] == 0 {\n\t\t\tunsolvedTiles++\n\t\t}\n\t}\n\n\tif unsolvedTiles \u003c= quantumThreshold {\n\t\t// replace the board with solvedBoard and redeploy\n\t\tif board[positions.position1] != board[positions.position2] {\n\t\t\tboard[positions.position1] = board[positions.position2]\n\t\t\tsolvedBoard[positions.position1] = board[positions.position1]\n\t\t\tsolvedBoard[positions.position2] = board[positions.position2]\n\t\t}\n\t}\n\n\treturn board, solvedBoard\n\n\t// check for game solved\n\t// todo: promote this check to the realm? that's where we send user events\n\t/*\n\t   unsolvedTiles = 0\n\n\t   for j := 0; j \u003c len(board); j++ {\n\t       if(solvedBoard[j] == 0){\n\t           unsolvedTiles = unsolvedTiles + 1\n\t       }\n\t   }\n\t   if(unsolvedTiles == 0){\n\t       // call flippandoGameMaster finishGame\n\t       flippandoGameMaster.finishGame(id, games[id].player);\n\t       emit GameSolved(id, games[id])\n\t   }*/\n}\n\nfunc createNFT(gameId string) {\n\t// - generates a GRC721 token with the solved board SVG as a tokenURI\n}\n\nfunc makeArt(owner string, buildingBlocks []int) {\n\t// - checks if any of the tokenIds in the buildingBlocks[] are belonging to the user (not allowed)\n\t// - checks if any of the tokenIds in the buildingBlocks[] are in transit\n\t// - unlocks and sends the locked Flips in each used NFT\n\t// - transfers the NFTs to the new owner (the art creator)\n\t// - calls FlippandoBundler.bundleAssets() to generate a new GRC721 NFT with a standard tokenURI, and the tokenIds of the used NFT primitives\n}\n\n/*\nvar randIntn = func(n int) int {\n\treturn rand.Intn(n)\n}*/\n\nfunc generateRandomNumbers(num, start, end int) []int {\n\tif start \u003e end {\n\t\tstart, end = end, start // Ensure the range is in ascending order\n\t}\n\n\tif num \u003c 0 {\n\t\tufmt.Sprintf(\"The number of random values (num) must be non-negative\")\n\t\treturn nil\n\t}\n\n\tif num \u003e end-start+1 {\n\t\tufmt.Sprintf(\"The number of random values (num) cannot exceed the range size\")\n\t\treturn nil\n\t}\n\n\t// Seed the random number generator with the current time\n\tr := rand.New()\n\n\t// Generate num unique random values within the range\n\tresult := make([]int, 0, num)\n\tfor len(result) \u003c num {\n\t\trandomValue := r.Intn(end-start+1) + start\n\n\t\t// Check if the value already exists in the result slice\n\t\t// If not, append it to the result slice\n\t\tunique := true\n\t\tfor _, val := range result {\n\t\t\tif val == randomValue {\n\t\t\t\tunique = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tif unique {\n\t\t\tresult = append(result, randomValue)\n\t\t}\n\t}\n\n\treturn result\n}\n\nfunc sqrt(x float64) float64 {\n\tif x == 0 || x == 1 {\n\t\treturn x\n\t}\n\n\t// Start with an initial guess\n\tguess := x / 2.0\n\tprevGuess := 0.0\n\n\t// Use a small threshold to determine when to stop the approximation\n\tconst threshold = 0.00001\n\n\t// Use math.Abs to calculate the absolute value\n\tabs := func(f float64) float64 {\n\t\tif f \u003c 0 {\n\t\t\treturn -f\n\t\t}\n\t\treturn f\n\t}\n\n\tfor abs(guess-prevGuess) \u003e threshold {\n\t\tprevGuess = guess\n\t\tguess = 0.5 * (guess + x/guess)\n\t}\n\n\treturn guess\n}\n"},{"Name":"flippando_test.gno","Body":"package flippando\n\nimport (\n\t\"std\"\n\t\"testing\"\n\n\t\"gno.land/p/demo/rand\"\n\t\"gno.land/p/demo/testutils\"\n)\n\nfunc TestGenerateRandomNumbers(t *testing.T) {\n\t// Create an instance of your custom deterministic random number generator.\n\trandInstance := rand.New() // Use your custom Instance type here\n\n\t// Test case 1: Positive test case\n\trandomValues := generateRandomNumbers(4, 1, 4)\n\texpectedValues := []int{2, 3, 1, 4}\n\tif !sliceEqual(randomValues, expectedValues) {\n\t\tt.Fatalf(\"Expected %v, but got %v\", expectedValues, randomValues)\n\t}\n\n\t// Test case 2: Edge case with num exceeding the range size\n\trandomValues = generateRandomNumbers(10, 1, 4)\n\tif randomValues != nil {\n\t\tt.Fatalf(\"Expected nil for num exceeding range size, but got %v\", randomValues)\n\t}\n}\n\n// Helper function to compare two slices for equality\nfunc sliceEqual(a, b []int) bool {\n\tif len(a) != len(b) {\n\t\treturn false\n\t}\n\tfor i := range a {\n\t\tif a[i] != b[i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"KHP+bbIXISPRGmbIPkdimKrnCyq9ZOdKI+NRUQjp1OI6qjYD2Ifc2l3Y2PIljECCspVDBAktUGOHcNzXDGjt/Q=="}],"memo":""},"blockNum":"39575"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jk49uwqxa9nk98e5p0y8hszjvjuw5ek9dca6sv","to_address":"g1dupwc95pnkpyz0vnmaq6c49ym3753wym5gmedu","amount":"100000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Au72itL2h4pEETcRtnLk/nQzRgcok47xuueKP0ZbEA09"},"signature":"ORzFKMKh+03geKBkMPI+HFuw3lMJJCfgg/SQQscIHpASSxg27O5HNCxbtmWMDCSmyWqh8V2RCeYj8uJPbpWXAQ=="}],"memo":""},"blockNum":"39611"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"Name":"hehe","Path":"gno.land/r/hehe","Files":[{"Name":"contract.gno","Body":"package main\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"contract_test.gno","Body":"package main\n\nimport (\n  \"testing\"\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"VVdH1iB2zjA1wfYutY2fJ5DXqAzvl8pTQusDV9Nxb993jnELXyK8vYnNVt28I1bPLGPieDf8bLGK8B/6TEZsLg=="}],"memo":""},"blockNum":"39885"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"Name":"qwe","Path":"gno.land/r/qwe","Files":[{"Name":"contract.gno","Body":"package main\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"contract_test.gno","Body":"package main\n\nimport (\n  \"testing\"\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"Hw+T4de6C/ygK1sccjYkdOa8OsOhu5TkNk5d3mxacptay0uq6Y8TChNB26/8EPaIMgeQwC8YYBMIBtANGt252g=="}],"memo":""},"blockNum":"39887"}
