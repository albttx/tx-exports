{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"Name":"123","Path":"gno.land/r/123/123","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n\treturn \"Hello World!\"\n}\n"},{"Name":"whatisit.gno","Body":"package\r\n    hi\r\n    hello"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"YneTSJuYEcTZBkEq1IEWN+VpJ6+K9wzWlr/dj+GdKHJtslY6Qxl9xr6R0IObLWNARcR+g15pJYlRwRZ+MoIdAQ=="}],"memo":""},"blockNum":"160073"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g13enw4ph4jwh2mqv07pxcsesyam5605cydps77n","package":{"Name":"test1","Path":"gno.land/p/test/test1","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n\treturn \"Hello World!\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3JoC0+RVv9CQsgf4X359CS2cPelnoPDiVtGW/ppfqfN"},"signature":"GUVobgpwplvMCDlN5m2hp9WVi6CXuDpEcd8OMF77xjgG0w5h+WtFr0Yuf2j2gaAFZGyGH9EKmUYymCdwOKuiMw=="}],"memo":""},"blockNum":"160076"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g13enw4ph4jwh2mqv07pxcsesyam5605cydps77n","package":{"Name":"test","Path":"gno.land/r/deploy/test","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n\treturn \"Hello World!\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3JoC0+RVv9CQsgf4X359CS2cPelnoPDiVtGW/ppfqfN"},"signature":"FQckOwaTSklyzOywB+341OHLe3SutBWa8KYa8N5ffDZCCGXUrrQCiJCQBmcxt6pXyJxmUHuOHELJLe+d7UPlYw=="}],"memo":""},"blockNum":"160078"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g13enw4ph4jwh2mqv07pxcsesyam5605cydps77n","package":{"Name":"test11","Path":"gno.land/p/test/test11","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n\treturn \"Hello World!\"\n}\n"},{"Name":"test.gno","Body":"package test"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3JoC0+RVv9CQsgf4X359CS2cPelnoPDiVtGW/ppfqfN"},"signature":"9U+kUy5GdcZedCNmMY3bn+23f8AXBjBfsNvD6W9duGYTpHKBPwySNOHQQvPouASu+R2YdiYIMX1II1N7gpqPHg=="}],"memo":""},"blockNum":"160082"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g13enw4ph4jwh2mqv07pxcsesyam5605cydps77n","package":{"Name":"test11","Path":"gno.land/p/test/test11","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n\treturn \"Hello World!\"\n}\n"},{"Name":"test.gno","Body":"package test"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3JoC0+RVv9CQsgf4X359CS2cPelnoPDiVtGW/ppfqfN"},"signature":"BjY83q5gN+U7+PNfnKlA3DNXwAis5NBdnpFoyJ3HKPhr8h6d4mp6Qd+Ku6Wi3KAWGcK+Dibchp1m2X7ztC4oNg=="}],"memo":""},"blockNum":"160084"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1hqzeju0p0eup9rgxa0pxvyc0y7wnzjrdvppsy5","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"En3zM3MeZhNvNLnL8HEORWWl2pDY1+ZSX+j7lmycr2ZS+zqTnakFR6BlmlWcbfdqcP/hJXHEFIqHVEi3KB6TNQ=="}],"memo":""},"blockNum":"160088"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1hqzeju0p0eup9rgxa0pxvyc0y7wnzjrdvppsy5","package":{"Name":"starbucks","Path":"gno.land/p/demo/starbucks","Files":[{"Name":"GRC20.gno","Body":"package starbucks\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tstarbucks  *grc20.AdminToken\r\n\tadmin std.Address = \"g1hqzeju0p0eup9rgxa0pxvyc0y7wnzjrdvppsy5\"\r\n)\r\n\r\nfunc init() {\r\n\tstarbucks = grc20.NewAdminToken(\"Starbucks\", \"STAR\", 6)\r\n\tstarbucks.Mint(admin, 1000000000) // @administrator\r\n}\r\n\r\n// method proxies as public functions.\r\n//\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn starbucks.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := starbucks.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := starbucks.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tstarbucks.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tstarbucks.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tstarbucks.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tstarbucks.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tstarbucks.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render.\r\n//\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn starbucks.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := starbucks.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A8ZPjq3N75o801HNNSJB3v0GmXHDkhslgNungVdLjFdz"},"signature":"MQV6bmYUVjqsE3DxEEEE3EN8TR3Zyt79Eq1osJd5QeFwg4keB3e74TK5dul6SiHoGuS4vOc3QAs0LXx+VpOtgg=="}],"memo":""},"blockNum":"160090"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1hqzeju0p0eup9rgxa0pxvyc0y7wnzjrdvppsy5","package":{"Name":"starbucks","Path":"gno.land/r/demo/starbucks","Files":[{"Name":"GRC20.gno","Body":"package starbucks\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tstarbucks  *grc20.AdminToken\r\n\tadmin std.Address = \"g1hqzeju0p0eup9rgxa0pxvyc0y7wnzjrdvppsy5\"\r\n)\r\n\r\nfunc init() {\r\n\tstarbucks = grc20.NewAdminToken(\"Starbucks\", \"STAR\", 6)\r\n\tstarbucks.Mint(admin, 1000000000) // @administrator\r\n}\r\n\r\n// method proxies as public functions.\r\n//\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn starbucks.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := starbucks.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := starbucks.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tstarbucks.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tstarbucks.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tstarbucks.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tstarbucks.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tstarbucks.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render.\r\n//\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn starbucks.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := starbucks.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A8ZPjq3N75o801HNNSJB3v0GmXHDkhslgNungVdLjFdz"},"signature":"469aWfidadGQx/zShBSUf41T+OZWltpe8StkzB4fzwJNtnQCP6v9K/qPWtikKg1Vy64LT0j+XAanFDq03mr63w=="}],"memo":""},"blockNum":"160093"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1hqzeju0p0eup9rgxa0pxvyc0y7wnzjrdvppsy5","to_address":"g1c4pdj3lx0t8n9k5yay2gnw2ewkxxdxhnknnvqz","amount":"10000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A8ZPjq3N75o801HNNSJB3v0GmXHDkhslgNungVdLjFdz"},"signature":"Ac/SbL2Bccjetp019YCJvmyJhI6Q+l7dgkdWyayAxWh5ohDgl66C20PdQow2HT8S7QG+AHISI1fKdfNpflYG/Q=="}],"memo":""},"blockNum":"160130"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1c4pdj3lx0t8n9k5yay2gnw2ewkxxdxhnknnvqz","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"PMrQGYfZvbzXFPGh2/0vIjii1XobJDm+x0Y9osqWnsgDCHubOKBeS71EVrtsxDj2mRh8dK9PnMEIQJEMkEaSqA=="}],"memo":""},"blockNum":"160134"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1c4pdj3lx0t8n9k5yay2gnw2ewkxxdxhnknnvqz","package":{"Name":"gopher","Path":"gno.land/r/demo/gopher","Files":[{"Name":"GRC20.gno","Body":"package gopher\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tgopher  *grc20.AdminToken\r\n\tadmin std.Address = \"g1c4pdj3lx0t8n9k5yay2gnw2ewkxxdxhnknnvqz\"\r\n)\r\n\r\nfunc init() {\r\n\tgopher = grc20.NewAdminToken(\"Gopher\", \"gopher\", 6)\r\n\tgopher.Mint(admin, 1000000000) // @administrator\r\n}\r\n\r\n// method proxies as public functions.\r\n//\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn gopher.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := gopher.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := gopher.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tgopher.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tgopher.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tgopher.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tgopher.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tgopher.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render.\r\n//\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn gopher.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := gopher.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7qLRNI7yEuRCeRhuXCql/jnp9PDy0nQchJqGO3uuDM5"},"signature":"5ykCQAGShQFQG7o/6EPuATqeoUvySOJBe8XOrrQPJp8tiBEndSR1oRth93YFB3SA3pRqagZXYjcw4qdOOS61yQ=="}],"memo":""},"blockNum":"160146"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1fnakf9vrd6uqn8qdmp88yam4p0ngy572answ9f","package":{"Name":"seoul","Path":"gno.land/r/demo/seoul","Files":[{"Name":"GRC20.gno","Body":"package seoul\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tseoul  *grc20.AdminToken\r\n\tadmin std.Address = \"g1fnakf9vrd6uqn8qdmp88yam4p0ngy572answ9f\"\r\n)\r\n\r\nfunc init() {\r\n\tseoul = grc20.NewAdminToken(\"Seoul\", \"SEOUL\", 6)\r\n\tseoul.Mint(admin, 1000000000) // @administrator\r\n}\r\n\r\n// method proxies as public functions.\r\n//\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn seoul.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := seoul.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := seoul.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tseoul.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tseoul.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tseoul.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tseoul.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tseoul.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render.\r\n//\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn seoul.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := seoul.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3cWVULHSHC1mwK8o1vfJHKfNMvLEvKU/sHPQoFWRoey"},"signature":"JW97M6xYBCvYJesNY/1vOfpAssdeHnDynMkAL8O2cpM9IutKSj03nNK+3hEewDqSUMBRACSVpKDhSGV/8ul4yw=="}],"memo":""},"blockNum":"160164"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1c4pdj3lx0t8n9k5yay2gnw2ewkxxdxhnknnvqz","package":{"Name":"apple","Path":"gno.land/r/demo/apple","Files":[{"Name":"GRC20.gno","Body":"package apple\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\tapple  *grc20.AdminToken\r\n\tadmin std.Address = \"g1c4pdj3lx0t8n9k5yay2gnw2ewkxxdxhnknnvqz\"\r\n)\r\n\r\nfunc init() {\r\n\tapple = grc20.NewAdminToken(\"Apple\", \"APPLE\", 6)\r\n\tapple.Mint(admin, 1000000000) // @administrator\r\n}\r\n\r\n// method proxies as public functions.\r\n//\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn apple.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := apple.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := apple.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tapple.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tapple.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tapple.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tapple.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\tapple.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render.\r\n//\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn apple.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := apple.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A7qLRNI7yEuRCeRhuXCql/jnp9PDy0nQchJqGO3uuDM5"},"signature":"uu3yHUDcKPEVD0Fh23DOhPyxS1tUzjQ97yZw0PBgd55SZpuQGXEfWMvw9u7VRTsBFaAnNEqKleFY1C6FcIXT4g=="}],"memo":""},"blockNum":"160179"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g15wmukt79xymnnu6c4de32trnufudqum60yrxu8","package":{"Name":"tg","Path":"gno.land/p/rtgr/tg","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A6QxDeE9T4utsKFysdC0JZTyVwnc4UgqQ7vhHJf5pp+p"},"signature":"HxetKyf+dQJzF5W7eemsmOEvqFqOIY1wveHq2N8Alng89Y9PVaaCfPnDszwmK/ubh+LfahUiTRQYHIN7/bmeyA=="}],"memo":""},"blockNum":"160768"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14vhcdsyf83ngsrrqc92kmw8q9xakqjm0v8448t","send":"","pkg_path":"gno.land/r/demo/minter","func":"Mint","args":["g1mm90sxz5lnrknst7apatxkpc0mrtz3cstr7d3q","ugnot","310000000"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgiTyNXOXskkkxKv2DXaDxFtabuTPHlltbYwCOBpHL3w"},"signature":"3oYQN7GA343GMH7V22Lu4WTS5er770upc7wMV77ORMQmhEnhdvMQUyoHF74q/BP4On/FYEG52k/Wx2zCh7A84w=="}],"memo":""},"blockNum":"160952"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"cxgD4JmLtiY1Jn4oCM4p4dtptVcLbhS+biUvlo148xlG8mFrZzTGzOWElpf8JfE34INDJW9fjMSQ0xv5HOEJSQ=="}],"memo":""},"blockNum":"161083"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","package":{"Name":"mytoken","Path":"gno.land/p/asdas/asd/mytoken","Files":[{"Name":"mytoken.gno","Body":"package mytoken\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/p/demo/users\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\nvar (\n\tmytoken *grc20.AdminToken\n\tadmin   std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // set admin account\n)\n\n// init is a constructor function that runs only once (at time of deployment)\nfunc init() {\n\t// provision the token's name, symbol and number of decimals\n\tmytoken = grc20.NewAdminToken(\"Mytoken\", \"MTKN\", 4)\n\n\t// set the total supply\n\tmytoken.Mint(admin, 1000000*10000) // @administrator (supply = 1 million)\n}\n\nfunc TotalSupply() uint64 {\n\treturn mytoken.TotalSupply()\n}\n\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := mytoken.BalanceOf(owner.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := mytoken.Allowance(owner.Resolve(), spender.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn allowance\n}\n\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := mytoken.Transfer(caller, to.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := mytoken.Approve(caller, spender.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := mytoken.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mytoken.Mint(address.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mytoken.Burn(address.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn mytoken.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := mytoken.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AzKti/XiFTeigS2l358qt7i7UIfEeHD8HjiNZPR5DUlD"},"signature":"NVaA8lOYTvsHUHH6/3QwkyUqXTvzrdqh9HgzUfFhqeN4l9GTqxATEko1/fynchsOAM7Bp9xUucwEmeTX1kWecw=="}],"memo":""},"blockNum":"161085"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","package":{"Name":"token","Path":"gno.land/p/mynonfungibletoken/token","Files":[{"Name":"package.gno","Body":"package mynonfungibletoken\n\nimport (\n\t\"std\"\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/users\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\nvar (\n\tadmin std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // set admin account\n\tmynonfungibletoken = grc721.NewBasicNFT(\"mynonfungibletoken\", \"MNFT\")\n)\n\nfunc init() {\n\tmintNNFT(admin, 10) // @administrator (initial supply = 10 NFTs)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n\tcount := mynonfungibletoken.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\tmynonfungibletoken.Mint(owner, tid)\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n\tbalance, err := mynonfungibletoken.BalanceOf(user.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := mynonfungibletoken.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n\treturn mynonfungibletoken.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := mynonfungibletoken.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.Approve(user.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n\terr := mynonfungibletoken.SetApprovalForAll(user.Resolve(), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.TransferFrom(from.Resolve(), to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Admin\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Mint(to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn mynonfungibletoken.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"gy30+h+BHG7Zn3awa4wWx74GXxryOIyubHvcwepRjx8h7eyU0P+QHmbyttWyvwaDP6ZwGgO4OckxLDUzzR4PUQ=="}],"memo":""},"blockNum":"161089"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","package":{"Name":"test","Path":"gno.land/p/mynonfungibletoken/test","Files":[{"Name":"package.gno","Body":"package mynonfungibletoken\n\nimport (\n\t\"std\"\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/users\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\nvar (\n\tadmin std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // set admin account\n\tmynonfungibletoken = grc721.NewBasicNFT(\"mynonfungibletoken\", \"MNFT\")\n)\n\nfunc init() {\n\tmintNNFT(admin, 10) // @administrator (initial supply = 10 NFTs)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n\tcount := mynonfungibletoken.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\tmynonfungibletoken.Mint(owner, tid)\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n\tbalance, err := mynonfungibletoken.BalanceOf(user.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := mynonfungibletoken.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n\treturn mynonfungibletoken.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := mynonfungibletoken.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.Approve(user.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n\terr := mynonfungibletoken.SetApprovalForAll(user.Resolve(), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.TransferFrom(from.Resolve(), to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Admin\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Mint(to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn mynonfungibletoken.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"5+9fZGc4DICCqzPuLYwwCA6CQHdyYRJKwG/f7EuXQH4QSPqtEe8W5JwzQEaf+J9MgJyi+OXeteJG6HGHq7XvfQ=="}],"memo":""},"blockNum":"161091"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","package":{"Name":"test","Path":"gno.land/p/test/test","Files":[{"Name":"package.gno","Body":"package mynonfungibletoken\n\nimport (\n\t\"std\"\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/users\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\nvar (\n\tadmin std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // set admin account\n\tmynonfungibletoken = grc721.NewBasicNFT(\"mynonfungibletoken\", \"MNFT\")\n)\n\nfunc init() {\n\tmintNNFT(admin, 10) // @administrator (initial supply = 10 NFTs)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n\tcount := mynonfungibletoken.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\tmynonfungibletoken.Mint(owner, tid)\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n\tbalance, err := mynonfungibletoken.BalanceOf(user.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := mynonfungibletoken.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n\treturn mynonfungibletoken.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := mynonfungibletoken.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.Approve(user.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n\terr := mynonfungibletoken.SetApprovalForAll(user.Resolve(), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.TransferFrom(from.Resolve(), to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Admin\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Mint(to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn mynonfungibletoken.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"WlhpB9eULudMsjNScWRZ0o50m6pdszQ91ux52P26TylzCWHHVZzZNhCZGPeVFlLZpln6hZeh2KDW6eYN4VnCpA=="}],"memo":""},"blockNum":"161093"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","package":{"Name":"testtoken","Path":"gno.land/p/testtoken/testtoken","Files":[{"Name":"package.gno","Body":"package testoken\n\nimport (\n\t\"std\"\n\t\"gno.land/p/demo/grc/grc721\"\n\t\"gno.land/p/demo/users\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\nvar (\n\tadmin std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // set admin account\n\tmynonfungibletoken = grc721.NewBasicNFT(\"mynonfungibletoken\", \"MNFT\")\n)\n\nfunc init() {\n\tmintNNFT(admin, 10) // @administrator (initial supply = 10 NFTs)\n}\n\nfunc mintNNFT(owner std.Address, n uint64) {\n\tcount := mynonfungibletoken.TokenCount()\n\tfor i := count; i \u003c count+n; i++ {\n\t\ttid := grc721.TokenID(ufmt.Sprintf(\"%d\", i))\n\t\tmynonfungibletoken.Mint(owner, tid)\n\t}\n}\n\n// Getters\n\nfunc BalanceOf(user users.AddressOrName) uint64 {\n\tbalance, err := mynonfungibletoken.BalanceOf(user.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc OwnerOf(tid grc721.TokenID) std.Address {\n\towner, err := mynonfungibletoken.OwnerOf(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn owner\n}\n\nfunc IsApprovedForAll(owner, user users.AddressOrName) bool {\n\treturn mynonfungibletoken.IsApprovedForAll(owner.Resolve(), user.Resolve())\n}\n\nfunc GetApproved(tid grc721.TokenID) std.Address {\n\taddr, err := mynonfungibletoken.GetApproved(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn addr\n}\n\n// Setters\n\nfunc Approve(user users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.Approve(user.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc SetApprovalForAll(user users.AddressOrName, approved bool) {\n\terr := mynonfungibletoken.SetApprovalForAll(user.Resolve(), approved)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, tid grc721.TokenID) {\n\terr := mynonfungibletoken.TransferFrom(from.Resolve(), to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Admin\n\nfunc Mint(to users.AddressOrName, tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Mint(to.Resolve(), tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(tid grc721.TokenID) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mynonfungibletoken.Burn(tid)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\n// Render\n\nfunc Render(path string) string {\n\tswitch {\n\tcase path == \"\":\n\t\treturn mynonfungibletoken.RenderHome()\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\n// Util\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"2jd9EvjwNw8DzQ0tMTzQMrV9sPxpcKlcf+0YxnIDmv4YxZvVPr0zMOP+oRmqOsyRiC7Hk8w0/maZjlpafQd+qg=="}],"memo":""},"blockNum":"161095"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","package":{"Name":"blog","Path":"gno.land/p/microblog/blog","Files":[{"Name":"package.gno","Body":"package microblog\n\nimport (\n\t\"errors\"\n\t\"sort\"\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tErrNotFound    = errors.New(\"not found\")\n\tStatusNotFound = \"404\"\n)\n\ntype Microblog struct {\n\tTitle  string\n\tPrefix string   // i.e. r/gnoland/blog:\n\tPages  avl.Tree // author (string) -\u003e Page\n}\n\nfunc NewMicroblog(title string, prefix string) (m *Microblog) {\n\treturn \u0026Microblog{\n\t\tTitle:  title,\n\t\tPrefix: prefix,\n\t\tPages:  avl.Tree{},\n\t}\n}\n\nfunc (m *Microblog) GetPages() []*Page {\n\tvar (\n\t\tpages = make([]*Page, m.Pages.Size())\n\t\tindex = 0\n\t)\n\n\tm.Pages.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tpages[index] = value.(*Page)\n\t\tindex++\n\t\treturn false\n\t})\n\n\tsort.Sort(byLastPosted(pages))\n\n\treturn pages\n}\n\nfunc (m *Microblog) RenderHome() string {\n\toutput := ufmt.Sprintf(\"# %s\\n\\n\", m.Title)\n\toutput += \"# pages\\n\\n\"\n\n\tfor _, page := range m.GetPages() {\n\t\tif u := users.GetUserByAddress(page.Author); u != nil {\n\t\t\toutput += ufmt.Sprintf(\"- [%s (%s)](%s%s)\\n\", u.Name(), page.Author.String(), m.Prefix, page.Author.String())\n\t\t} else {\n\t\t\toutput += ufmt.Sprintf(\"- [%s](%s%s)\\n\", page.Author.String(), m.Prefix, page.Author.String())\n\t\t}\n\t}\n\n\treturn output\n}\n\nfunc (m *Microblog) RenderUser(user string) string {\n\tsilo, found := m.Pages.Get(user)\n\tif !found {\n\t\treturn StatusNotFound\n\t}\n\n\treturn (silo.(*Page)).String()\n}\n\nfunc (m *Microblog) Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\n\tisHome := path == \"\"\n\tisUser := len(parts) == 1\n\n\tswitch {\n\tcase isHome:\n\t\treturn m.RenderHome()\n\n\tcase isUser:\n\t\treturn m.RenderUser(parts[0])\n\t}\n\n\treturn StatusNotFound\n}\n\nfunc (m *Microblog) NewPost(text string) error {\n\tauthor := std.GetOrigCaller()\n\t_, found := m.Pages.Get(author.String())\n\tif !found {\n\t\t// make a new page for the new author\n\t\tm.Pages.Set(author.String(), \u0026Page{\n\t\t\tAuthor:    author,\n\t\t\tCreatedAt: time.Now(),\n\t\t})\n\t}\n\n\tpage, err := m.GetPage(author.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn page.NewPost(text)\n}\n\nfunc (m *Microblog) GetPage(author string) (*Page, error) {\n\tsilo, found := m.Pages.Get(author)\n\tif !found {\n\t\treturn nil, ErrNotFound\n\t}\n\treturn silo.(*Page), nil\n}\n\ntype Page struct {\n\tID         int\n\tAuthor     std.Address\n\tCreatedAt  time.Time\n\tLastPosted time.Time\n\tPosts      avl.Tree // time -\u003e Post\n}\n\n// byLastPosted implements sort.Interface for []Page based on\n// the LastPosted field.\ntype byLastPosted []*Page\n\nfunc (a byLastPosted) Len() int           { return len(a) }\nfunc (a byLastPosted) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\nfunc (a byLastPosted) Less(i, j int) bool { return a[i].LastPosted.After(a[j].LastPosted) }\n\nfunc (p *Page) String() string {\n\to := \"\"\n\tif u := users.GetUserByAddress(p.Author); u != nil {\n\t\to += ufmt.Sprintf(\"# [%s](/r/demo/users:%s)\\n\\n\", u.Name(), u.Name())\n\t\to += ufmt.Sprintf(\"%s\\n\\n\", u.Profile())\n\t}\n\to += ufmt.Sprintf(\"## [%s](/r/demo/microblog:%s)\\n\\n\", p.Author, p.Author)\n\n\to += ufmt.Sprintf(\"joined %s, last updated %s\\n\\n\", p.CreatedAt.Format(\"2006-02-01\"), p.LastPosted.Format(\"2006-02-01\"))\n\to += \"## feed\\n\\n\"\n\tfor _, u := range p.GetPosts() {\n\t\to += u.String() + \"\\n\\n\"\n\t}\n\treturn o\n}\n\nfunc (p *Page) NewPost(text string) error {\n\tnow := time.Now()\n\tp.LastPosted = now\n\tp.Posts.Set(ufmt.Sprintf(\"%s%d\", now.Format(time.RFC3339), p.Posts.Size()), \u0026Post{\n\t\tID:        p.Posts.Size(),\n\t\tText:      text,\n\t\tCreatedAt: now,\n\t})\n\treturn nil\n}\n\nfunc (p *Page) GetPosts() []*Post {\n\tposts := make([]*Post, p.Posts.Size())\n\ti := 0\n\tp.Posts.ReverseIterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tpostParsed := value.(*Post)\n\t\tposts[i] = postParsed\n\t\ti++\n\t\treturn false\n\t})\n\treturn posts\n}\n\n// Post lists the specific update\ntype Post struct {\n\tID        int\n\tCreatedAt time.Time\n\tText      string\n}\n\nfunc (p *Post) String() string {\n\treturn \"\u003e \" + strings.ReplaceAll(p.Text, \"\\n\", \"\\n\u003e\\n\u003e\") + \"\\n\u003e\\n\u003e *\" + p.CreatedAt.Format(time.RFC1123) + \"*\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"xg66EwuhGyYoa/C9TNeOLHiQeLKgxpKpczSDAy8gBzMU8NKNZ4b1QaU5LegEQKJG8H2spColk9O8lmLHecaGjQ=="}],"memo":""},"blockNum":"161097"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","package":{"Name":"blog","Path":"gno.land/p/blog/blog","Files":[{"Name":"package.gno","Body":"package microblog\n\nimport (\n\t\"errors\"\n\t\"sort\"\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tErrNotFound    = errors.New(\"not found\")\n\tStatusNotFound = \"404\"\n)\n\ntype Microblog struct {\n\tTitle  string\n\tPrefix string   // i.e. r/gnoland/blog:\n\tPages  avl.Tree // author (string) -\u003e Page\n}\n\nfunc NewMicroblog(title string, prefix string) (m *Microblog) {\n\treturn \u0026Microblog{\n\t\tTitle:  title,\n\t\tPrefix: prefix,\n\t\tPages:  avl.Tree{},\n\t}\n}\n\nfunc (m *Microblog) GetPages() []*Page {\n\tvar (\n\t\tpages = make([]*Page, m.Pages.Size())\n\t\tindex = 0\n\t)\n\n\tm.Pages.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tpages[index] = value.(*Page)\n\t\tindex++\n\t\treturn false\n\t})\n\n\tsort.Sort(byLastPosted(pages))\n\n\treturn pages\n}\n\nfunc (m *Microblog) RenderHome() string {\n\toutput := ufmt.Sprintf(\"# %s\\n\\n\", m.Title)\n\toutput += \"# pages\\n\\n\"\n\n\tfor _, page := range m.GetPages() {\n\t\tif u := users.GetUserByAddress(page.Author); u != nil {\n\t\t\toutput += ufmt.Sprintf(\"- [%s (%s)](%s%s)\\n\", u.Name(), page.Author.String(), m.Prefix, page.Author.String())\n\t\t} else {\n\t\t\toutput += ufmt.Sprintf(\"- [%s](%s%s)\\n\", page.Author.String(), m.Prefix, page.Author.String())\n\t\t}\n\t}\n\n\treturn output\n}\n\nfunc (m *Microblog) RenderUser(user string) string {\n\tsilo, found := m.Pages.Get(user)\n\tif !found {\n\t\treturn StatusNotFound\n\t}\n\n\treturn (silo.(*Page)).String()\n}\n\nfunc (m *Microblog) Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\n\tisHome := path == \"\"\n\tisUser := len(parts) == 1\n\n\tswitch {\n\tcase isHome:\n\t\treturn m.RenderHome()\n\n\tcase isUser:\n\t\treturn m.RenderUser(parts[0])\n\t}\n\n\treturn StatusNotFound\n}\n\nfunc (m *Microblog) NewPost(text string) error {\n\tauthor := std.GetOrigCaller()\n\t_, found := m.Pages.Get(author.String())\n\tif !found {\n\t\t// make a new page for the new author\n\t\tm.Pages.Set(author.String(), \u0026Page{\n\t\t\tAuthor:    author,\n\t\t\tCreatedAt: time.Now(),\n\t\t})\n\t}\n\n\tpage, err := m.GetPage(author.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn page.NewPost(text)\n}\n\nfunc (m *Microblog) GetPage(author string) (*Page, error) {\n\tsilo, found := m.Pages.Get(author)\n\tif !found {\n\t\treturn nil, ErrNotFound\n\t}\n\treturn silo.(*Page), nil\n}\n\ntype Page struct {\n\tID         int\n\tAuthor     std.Address\n\tCreatedAt  time.Time\n\tLastPosted time.Time\n\tPosts      avl.Tree // time -\u003e Post\n}\n\n// byLastPosted implements sort.Interface for []Page based on\n// the LastPosted field.\ntype byLastPosted []*Page\n\nfunc (a byLastPosted) Len() int           { return len(a) }\nfunc (a byLastPosted) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\nfunc (a byLastPosted) Less(i, j int) bool { return a[i].LastPosted.After(a[j].LastPosted) }\n\nfunc (p *Page) String() string {\n\to := \"\"\n\tif u := users.GetUserByAddress(p.Author); u != nil {\n\t\to += ufmt.Sprintf(\"# [%s](/r/demo/users:%s)\\n\\n\", u.Name(), u.Name())\n\t\to += ufmt.Sprintf(\"%s\\n\\n\", u.Profile())\n\t}\n\to += ufmt.Sprintf(\"## [%s](/r/demo/microblog:%s)\\n\\n\", p.Author, p.Author)\n\n\to += ufmt.Sprintf(\"joined %s, last updated %s\\n\\n\", p.CreatedAt.Format(\"2006-02-01\"), p.LastPosted.Format(\"2006-02-01\"))\n\to += \"## feed\\n\\n\"\n\tfor _, u := range p.GetPosts() {\n\t\to += u.String() + \"\\n\\n\"\n\t}\n\treturn o\n}\n\nfunc (p *Page) NewPost(text string) error {\n\tnow := time.Now()\n\tp.LastPosted = now\n\tp.Posts.Set(ufmt.Sprintf(\"%s%d\", now.Format(time.RFC3339), p.Posts.Size()), \u0026Post{\n\t\tID:        p.Posts.Size(),\n\t\tText:      text,\n\t\tCreatedAt: now,\n\t})\n\treturn nil\n}\n\nfunc (p *Page) GetPosts() []*Post {\n\tposts := make([]*Post, p.Posts.Size())\n\ti := 0\n\tp.Posts.ReverseIterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tpostParsed := value.(*Post)\n\t\tposts[i] = postParsed\n\t\ti++\n\t\treturn false\n\t})\n\treturn posts\n}\n\n// Post lists the specific update\ntype Post struct {\n\tID        int\n\tCreatedAt time.Time\n\tText      string\n}\n\nfunc (p *Post) String() string {\n\treturn \"\u003e \" + strings.ReplaceAll(p.Text, \"\\n\", \"\\n\u003e\\n\u003e\") + \"\\n\u003e\\n\u003e *\" + p.CreatedAt.Format(time.RFC1123) + \"*\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"M76C4mkYuOkIb8P1Qth7KNAJY4gEigVv4UieAMTQ3jhE2Fmbw88WJl8RZKL3vFgHZF0STRBozIJcGRTvgYddSg=="}],"memo":""},"blockNum":"161099"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","package":{"Name":"nft","Path":"gno.land/p/asdad/asdasd/nft","Files":[{"Name":"nft.gno","Body":"package nft\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/grc/grc721\"\n)\n\ntype token struct {\n\tgrc721.IGRC721 // implements the GRC721 interface\n\n\ttokenCounter int\n\ttokens       avl.Tree // grc721.TokenID -\u003e *NFToken{}\n\toperators    avl.Tree // owner std.Address -\u003e operator std.Address\n}\n\ntype NFToken struct {\n\towner    std.Address\n\tapproved std.Address\n\ttokenID  grc721.TokenID\n\tdata     string\n}\n\nvar gToken = \u0026token{}\n\nfunc GetToken() *token { return gToken }\n\nfunc (grc *token) nextTokenID() grc721.TokenID {\n\tgrc.tokenCounter++\n\ts := strconv.Itoa(grc.tokenCounter)\n\treturn grc721.TokenID(s)\n}\n\nfunc (grc *token) getToken(tid grc721.TokenID) (*NFToken, bool) {\n\ttoken, ok := grc.tokens.Get(string(tid))\n\tif !ok {\n\t\treturn nil, false\n\t}\n\treturn token.(*NFToken), true\n}\n\nfunc (grc *token) Mint(to std.Address, data string) grc721.TokenID {\n\ttid := grc.nextTokenID()\n\tgrc.tokens.Set(string(tid), \u0026NFToken{\n\t\towner:   to,\n\t\ttokenID: tid,\n\t\tdata:    data,\n\t})\n\treturn tid\n}\n\nfunc (grc *token) BalanceOf(owner std.Address) (count int64) {\n\tpanic(\"not yet implemented\")\n}\n\nfunc (grc *token) OwnerOf(tid grc721.TokenID) std.Address {\n\ttoken, ok := grc.getToken(tid)\n\tif !ok {\n\t\tpanic(\"token does not exist\")\n\t}\n\treturn token.owner\n}\n\n// XXX not fully implemented yet.\nfunc (grc *token) SafeTransferFrom(from, to std.Address, tid grc721.TokenID) {\n\tgrc.TransferFrom(from, to, tid)\n\t// When transfer is complete, this function checks if `_to` is a smart\n\t// contract (code size \u003e 0). If so, it calls `onERC721Received` on\n\t// `_to` and throws if the return value is not\n\t// `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t// XXX ensure \"to\" is a realm with onERC721Received() signature.\n}\n\nfunc (grc *token) TransferFrom(from, to std.Address, tid grc721.TokenID) {\n\tcaller := std.GetCallerAt(2)\n\ttoken, ok := grc.getToken(tid)\n\t// Throws if `_tokenId` is not a valid NFT.\n\tif !ok {\n\t\tpanic(\"token does not exist\")\n\t}\n\t// Throws unless `msg.sender` is the current owner, an authorized\n\t// operator, or the approved address for this NFT.\n\tif caller != token.owner \u0026\u0026 caller != token.approved {\n\t\toperator, ok := grc.operators.Get(token.owner.String())\n\t\tif !ok || caller != operator.(std.Address) {\n\t\t\tpanic(\"unauthorized\")\n\t\t}\n\t}\n\t// Throws if `_from` is not the current owner.\n\tif from != token.owner {\n\t\tpanic(\"from is not the current owner\")\n\t}\n\t// Throws if `_to` is the zero address.\n\tif to == \"\" {\n\t\tpanic(\"to cannot be empty\")\n\t}\n\t// Good.\n\ttoken.owner = to\n}\n\nfunc (grc *token) Approve(approved std.Address, tid grc721.TokenID) {\n\tcaller := std.GetCallerAt(2)\n\ttoken, ok := grc.getToken(tid)\n\t// Throws if `_tokenId` is not a valid NFT.\n\tif !ok {\n\t\tpanic(\"token does not exist\")\n\t}\n\t// Throws unless `msg.sender` is the current owner,\n\t// or an authorized operator.\n\tif caller != token.owner {\n\t\toperator, ok := grc.operators.Get(token.owner.String())\n\t\tif !ok || caller != operator.(std.Address) {\n\t\t\tpanic(\"unauthorized\")\n\t\t}\n\t}\n\t// Good.\n\ttoken.approved = approved\n}\n\n// XXX make it work for set of operators.\nfunc (grc *token) SetApprovalForAll(operator std.Address, approved bool) {\n\tcaller := std.GetCallerAt(2)\n\tgrc.operators.Set(caller.String(), operator)\n}\n\nfunc (grc *token) GetApproved(tid grc721.TokenID) std.Address {\n\ttoken, ok := grc.getToken(tid)\n\t// Throws if `_tokenId` is not a valid NFT.\n\tif !ok {\n\t\tpanic(\"token does not exist\")\n\t}\n\treturn token.approved\n}\n\n// XXX make it work for set of operators\nfunc (grc *token) IsApprovedForAll(owner, operator std.Address) bool {\n\toperator2, ok := grc.operators.Get(owner.String())\n\tif !ok {\n\t\treturn false\n\t}\n\treturn operator == operator2.(std.Address)\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AzKti/XiFTeigS2l358qt7i7UIfEeHD8HjiNZPR5DUlD"},"signature":"OCIYoFq7akJY7st61MaGVGWpJsL0d4w7rPVMi4GKch5H7oiYRCnnS/u0N4eabYNhC7UeYQuH08xAOiIKkh0KDg=="}],"memo":""},"blockNum":"161100"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","package":{"Name":"blog","Path":"gno.land/p/blog/blog","Files":[{"Name":"package.gno","Body":"package blog\n\nimport (\n\t\"errors\"\n\t\"sort\"\n\t\"std\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n\t\"gno.land/r/demo/users\"\n)\n\nvar (\n\tErrNotFound    = errors.New(\"not found\")\n\tStatusNotFound = \"404\"\n)\n\ntype Microblog struct {\n\tTitle  string\n\tPrefix string   // i.e. r/gnoland/blog:\n\tPages  avl.Tree // author (string) -\u003e Page\n}\n\nfunc NewMicroblog(title string, prefix string) (m *Microblog) {\n\treturn \u0026Microblog{\n\t\tTitle:  title,\n\t\tPrefix: prefix,\n\t\tPages:  avl.Tree{},\n\t}\n}\n\nfunc (m *Microblog) GetPages() []*Page {\n\tvar (\n\t\tpages = make([]*Page, m.Pages.Size())\n\t\tindex = 0\n\t)\n\n\tm.Pages.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tpages[index] = value.(*Page)\n\t\tindex++\n\t\treturn false\n\t})\n\n\tsort.Sort(byLastPosted(pages))\n\n\treturn pages\n}\n\nfunc (m *Microblog) RenderHome() string {\n\toutput := ufmt.Sprintf(\"# %s\\n\\n\", m.Title)\n\toutput += \"# pages\\n\\n\"\n\n\tfor _, page := range m.GetPages() {\n\t\tif u := users.GetUserByAddress(page.Author); u != nil {\n\t\t\toutput += ufmt.Sprintf(\"- [%s (%s)](%s%s)\\n\", u.Name(), page.Author.String(), m.Prefix, page.Author.String())\n\t\t} else {\n\t\t\toutput += ufmt.Sprintf(\"- [%s](%s%s)\\n\", page.Author.String(), m.Prefix, page.Author.String())\n\t\t}\n\t}\n\n\treturn output\n}\n\nfunc (m *Microblog) RenderUser(user string) string {\n\tsilo, found := m.Pages.Get(user)\n\tif !found {\n\t\treturn StatusNotFound\n\t}\n\n\treturn (silo.(*Page)).String()\n}\n\nfunc (m *Microblog) Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\n\tisHome := path == \"\"\n\tisUser := len(parts) == 1\n\n\tswitch {\n\tcase isHome:\n\t\treturn m.RenderHome()\n\n\tcase isUser:\n\t\treturn m.RenderUser(parts[0])\n\t}\n\n\treturn StatusNotFound\n}\n\nfunc (m *Microblog) NewPost(text string) error {\n\tauthor := std.GetOrigCaller()\n\t_, found := m.Pages.Get(author.String())\n\tif !found {\n\t\t// make a new page for the new author\n\t\tm.Pages.Set(author.String(), \u0026Page{\n\t\t\tAuthor:    author,\n\t\t\tCreatedAt: time.Now(),\n\t\t})\n\t}\n\n\tpage, err := m.GetPage(author.String())\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn page.NewPost(text)\n}\n\nfunc (m *Microblog) GetPage(author string) (*Page, error) {\n\tsilo, found := m.Pages.Get(author)\n\tif !found {\n\t\treturn nil, ErrNotFound\n\t}\n\treturn silo.(*Page), nil\n}\n\ntype Page struct {\n\tID         int\n\tAuthor     std.Address\n\tCreatedAt  time.Time\n\tLastPosted time.Time\n\tPosts      avl.Tree // time -\u003e Post\n}\n\n// byLastPosted implements sort.Interface for []Page based on\n// the LastPosted field.\ntype byLastPosted []*Page\n\nfunc (a byLastPosted) Len() int           { return len(a) }\nfunc (a byLastPosted) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\nfunc (a byLastPosted) Less(i, j int) bool { return a[i].LastPosted.After(a[j].LastPosted) }\n\nfunc (p *Page) String() string {\n\to := \"\"\n\tif u := users.GetUserByAddress(p.Author); u != nil {\n\t\to += ufmt.Sprintf(\"# [%s](/r/demo/users:%s)\\n\\n\", u.Name(), u.Name())\n\t\to += ufmt.Sprintf(\"%s\\n\\n\", u.Profile())\n\t}\n\to += ufmt.Sprintf(\"## [%s](/r/demo/microblog:%s)\\n\\n\", p.Author, p.Author)\n\n\to += ufmt.Sprintf(\"joined %s, last updated %s\\n\\n\", p.CreatedAt.Format(\"2006-02-01\"), p.LastPosted.Format(\"2006-02-01\"))\n\to += \"## feed\\n\\n\"\n\tfor _, u := range p.GetPosts() {\n\t\to += u.String() + \"\\n\\n\"\n\t}\n\treturn o\n}\n\nfunc (p *Page) NewPost(text string) error {\n\tnow := time.Now()\n\tp.LastPosted = now\n\tp.Posts.Set(ufmt.Sprintf(\"%s%d\", now.Format(time.RFC3339), p.Posts.Size()), \u0026Post{\n\t\tID:        p.Posts.Size(),\n\t\tText:      text,\n\t\tCreatedAt: now,\n\t})\n\treturn nil\n}\n\nfunc (p *Page) GetPosts() []*Post {\n\tposts := make([]*Post, p.Posts.Size())\n\ti := 0\n\tp.Posts.ReverseIterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tpostParsed := value.(*Post)\n\t\tposts[i] = postParsed\n\t\ti++\n\t\treturn false\n\t})\n\treturn posts\n}\n\n// Post lists the specific update\ntype Post struct {\n\tID        int\n\tCreatedAt time.Time\n\tText      string\n}\n\nfunc (p *Post) String() string {\n\treturn \"\u003e \" + strings.ReplaceAll(p.Text, \"\\n\", \"\\n\u003e\\n\u003e\") + \"\\n\u003e\\n\u003e *\" + p.CreatedAt.Format(time.RFC1123) + \"*\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"0fI7Ck5PXQkXqd1LVjfCi7tP83TPzUZ/79ZLYHX5I2gnx5dxTX2SKVCDUywqFi3rWPGq4e0c9XR+fYPq3TsgTg=="}],"memo":""},"blockNum":"161102"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","package":{"Name":"count","Path":"gno.land/p/count/count","Files":[{"Name":"package.gno","Body":"package count\n\nimport \"fmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn fmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n"},{"Name":"count_test.gno","Body":"package count\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"173qTbMNDaJ9z+icRGUybsPJEoMczk9IZSNqm+l1gPVP17fFt7eahvwtnPT6Qi0Rf8YbbN6YTYo1DEXF3MsLuw=="}],"memo":""},"blockNum":"161104"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","package":{"Name":"noob","Path":"gno.land/p/noob/noob","Files":[{"Name":"package.gno","Body":"package noob\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\nvar (\n\tnoob = avl.NewTree()\n)\n\ntype Storage struct {\n\tDate int64 // block height\n\tData []string\n}\n\nfunc init() {\n\tnoob.Set(\n\t\t\"foo\",\n\t\tStorage{\n\t\t\tDate: std.GetHeight(),\n\t\t\tData: []string{\"bar\"},\n\t\t},\n\t)\n}\n\nfunc Noob(data string) {\n\tvar storage Storage\n\tvar dataSlice []string\n\n\t// get existing\n\texisting, ok := noob.Get(\"foo\")\n\tif ok {\n\t\tstorage = existing.(Storage)\t\n\n\t\tfor _, existingData := range storage.Data {\n\t\t\tdataSlice = append(\n\t\t\t\tdataSlice,\n\t\t\t\texistingData,\n\t\t\t)\n\t\t}\n\t}\n\n\t// append new data\n\tdataSlice = append(\n\t\tdataSlice,\n\t\tdata,\n\t)\n\n\t// update with new + old values\n\tnoob.Set(\n\t\t\"foo\",\n\t\tStorage{\n\t\t\tDate: std.GetHeight(),\n\t\t\tData: dataSlice,\n\t\t},\n\t)\t\n}\n\nfunc GetNoob() string {\n\tvar storage Storage\n\tvar resultStr string\n\n\texisting, ok := noob.Get(\"foo\")\n\tif ok {\n\t\tstorage = existing.(Storage)\n\n\t\tfor index, data := range storage.Data {\n\t\t\t// if last item in slice\n\t\t\tif index == len(storage.Data)-1 {\n\t\t\t\tresultStr += ufmt.Sprintf(\"%s\", data)\n\n\t\t\t\treturn ufmt.Sprintf(\"Date: %d Data: %s\", storage.Date, resultStr)\n\t\t\t}\n\t\t\tresultStr += ufmt.Sprintf(\"%s, \", data)\n\t\t}\n\t}\n\treturn ufmt.Sprintf(\"Date: %d Data: %s\", storage.Date, resultStr)\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"OPqFSslvUFH34Nmn5sfJcK8JXt7d1K0NFDfcaqP1nVwcKpxSzIgp/vQgoQVPfmBPpTOcbqMSfStTn0X7ed8uxg=="}],"memo":""},"blockNum":"161107"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","package":{"Name":"counter","Path":"gno.land/p/asdasd/asasd/counter","Files":[{"Name":"counter.gno","Body":"package count\n\nimport \"fmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn fmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n"},{"Name":"counter_test.gno","Body":"package count\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AzKti/XiFTeigS2l358qt7i7UIfEeHD8HjiNZPR5DUlD"},"signature":"A/i1B/0lzm1sc4ezf6mTIjR2yu8kvO84fGtzPRJ9t+ItSfeQUbvHnG2mK2j5O8GurQfbGUJzGleF4fKniQVpxg=="}],"memo":""},"blockNum":"161109"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","package":{"Name":"stack","Path":"gno.land/p/stack/stack","Files":[{"Name":"package.gno","Body":"package stack\n\ntype Stack struct {\n\ttop    *node\n\tlength int\n}\n\ntype node struct {\n\tvalue interface{}\n\tprev  *node\n}\n\nfunc New() *Stack {\n\treturn \u0026Stack{nil, 0}\n}\n\nfunc (s *Stack) Len() int {\n\treturn s.length\n}\n\nfunc (s *Stack) Top() interface{} {\n\tif s.length == 0 {\n\t\treturn nil\n\t}\n\treturn s.top.value\n}\n\nfunc (s *Stack) Pop() interface{} {\n\tif s.length == 0 {\n\t\treturn nil\n\t}\n\n\tnode := s.top\n\ts.top = node.prev\n\ts.length -= 1\n\treturn node.value\n}\n\nfunc (s *Stack) Push(value interface{}) {\n\tnode := \u0026node{value, s.top}\n\ts.top = node\n\ts.length += 1\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"LeiqaezJ7Ihh7oFI1fj0NuX9oxti9kNUYALYngog44M6qLn9UUxsoGahpaB2+Yv+R7mymbDIowIWoBKwWUINYg=="}],"memo":""},"blockNum":"161111"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","package":{"Name":"stackkk","Path":"gno.land/p/stackkk/stackkk","Files":[{"Name":"package.gno","Body":"package stackkk\n\ntype Stack struct {\n\ttop    *node\n\tlength int\n}\n\ntype node struct {\n\tvalue interface{}\n\tprev  *node\n}\n\nfunc New() *Stack {\n\treturn \u0026Stack{nil, 0}\n}\n\nfunc (s *Stack) Len() int {\n\treturn s.length\n}\n\nfunc (s *Stack) Top() interface{} {\n\tif s.length == 0 {\n\t\treturn nil\n\t}\n\treturn s.top.value\n}\n\nfunc (s *Stack) Pop() interface{} {\n\tif s.length == 0 {\n\t\treturn nil\n\t}\n\n\tnode := s.top\n\ts.top = node.prev\n\ts.length -= 1\n\treturn node.value\n}\n\nfunc (s *Stack) Push(value interface{}) {\n\tnode := \u0026node{value, s.top}\n\ts.top = node\n\ts.length += 1\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"lNVLGOerNR6hUWoski7FNYl9/nr2i6k2psz5zLb5nEsdLIvbx6z93jZCkJBZGMJXsjMtLWqKTHf5XVxdrwS72w=="}],"memo":""},"blockNum":"161113"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","package":{"Name":"counter","Path":"gno.land/p/asdad/asdasd/counter","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"fmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn fmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AzKti/XiFTeigS2l358qt7i7UIfEeHD8HjiNZPR5DUlD"},"signature":"FdcTVziiLATAZrS4wk5tFvMK94QZiGp7TOCgeyadcXpOFEksmsebXcjYAnR6v9dVxN0wzpSPr9vJ4uHEske2zQ=="}],"memo":""},"blockNum":"161114"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","package":{"Name":"counter","Path":"gno.land/p/asdad/asdasd/counter","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AzKti/XiFTeigS2l358qt7i7UIfEeHD8HjiNZPR5DUlD"},"signature":"DkeYl8g/EYgpAYkm3xXXzoQ4XBL0LmwxvYD/G0aySeRbNBPWKNB7P7qQplHpuOLlwRmVxaSdMAQIssUuIRCs/g=="}],"memo":""},"blockNum":"161116"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","package":{"Name":"polllll","Path":"gno.land/p/polllll/polllll","Files":[{"Name":"package.gno","Body":"package polllll\n\nimport (\n\t\"bytes\"\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\n// Main struct\ntype Poll struct {\n\ttitle       string\n\tdescription string\n\tdeadline    int64     // block height\n\tvoters      *avl.Tree // addr -\u003e yes/no (bool)\n}\n\n// Getters\nfunc (p Poll) Title() string {\n\treturn p.title\n}\n\nfunc (p Poll) Description() string {\n\treturn p.description\n}\n\nfunc (p Poll) Deadline() int64 {\n\treturn p.deadline\n}\n\nfunc (p Poll) Voters() *avl.Tree {\n\treturn p.voters\n}\n\n// Poll instance constructor\nfunc NewPoll(title, description string, deadline int64) *Poll {\n\treturn \u0026Poll{\n\t\ttitle:       title,\n\t\tdescription: description,\n\t\tdeadline:    deadline,\n\t\tvoters:      avl.NewTree(),\n\t}\n}\n\n// Vote records a vote for a user\nfunc (p *Poll) Vote(voter std.Address, vote bool) {\n\tp.voters.Set(string(voter), vote)\n}\n\n// HasVoted checks if a user has voted and returns the vote: yes - true, no - false\nfunc (p *Poll) HasVoted(address std.Address) (bool, bool) {\n\tvote, exists := p.voters.Get(string(address))\n\tif exists {\n\t\treturn true, vote.(bool)\n\t}\n\treturn false, false\n}\n\n// VoteCount returns the number of yay \u0026 nay votes\nfunc (p Poll) VoteCount() (int, int) {\n\tvar yay int\n\n\tp.voters.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tvote := value.(bool)\n\t\tif vote {\n\t\t\tyay++\n\t\t}\n\t\treturn false\n\t})\n\treturn yay, p.voters.Size() - yay\n}\n\n// State variables\nvar (\n\tpolls         *avl.Tree // id -\u003e Poll\n\tpollIDCounter int\n)\n\nfunc init() {\n\tpolls = avl.NewTree()\n\tpollIDCounter = 0\n}\n\n// NewPoll creates a new Poll instance\nfunc NewPoll(title, description string, deadline int64) string {\n\t// get block height\n\tif deadline \u003c= std.GetHeight() {\n\t\treturn \"Error: Deadline has to be in the future.\"\n\t}\n\n\t// convert int ID to string used in AVL tree\n\tid := ufmt.Sprintf(\"%d\", pollIDCounter)\n\tp := NewPoll(title, description, deadline)\n\n\t// add new poll in avl tree\n\tpolls.Set(id, p)\n\n\t// increment ID counter\n\tpollIDCounter++\n\n\treturn ufmt.Sprintf(\"Successfully created poll #%s!\", id)\n}\n\n// Vote allows voting for a specific Poll (yes - true, no - false)\nfunc Vote(pollID int, vote bool) string {\n\t// get txSender\n\ttxSender := std.GetOrigCaller()\n\n\tid := ufmt.Sprintf(\"%d\", pollID)\n\t// get specific Poll from AVL tree\n\tpollRaw, exists := polls.Get(id)\n\n\tif !exists {\n\t\treturn \"Error: Poll with specified ID doesn't exist.\"\n\t}\n\n\t// cast Poll into proper format\n\tpoll, _ := pollRaw.(*Poll)\n\n\tvoted, _ := poll.HasVoted(txSender)\n\tif voted {\n\t\treturn \"Error: You've already voted!\"\n\t}\n\n\tif poll.Deadline() \u003c= std.GetHeight() {\n\t\treturn \"Error: Voting for this poll is closed.\"\n\t}\n\n\t// record vote\n\tpoll.Vote(txSender, vote)\n\n\t// update Poll in tree\n\tpolls.Set(id, poll)\n\n\tif vote {\n\t\treturn ufmt.Sprintf(\"Successfully voted YAY for poll #%s!\", id)\n\t}\n\treturn ufmt.Sprintf(\"Successfully voted NAY for poll #%s!\", id)\n}\n\n// Render renders the current state of polls\nfunc Render(path string) string {\n\tvar b bytes.Buffer\n\n\tb.WriteString(\"# Polls!\\n\\n\")\n\n\tif polls.Size() == 0 {\n\t\tb.WriteString(\"### No active polls currently!\")\n\t\treturn b.String()\n\t}\n\tpolls.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\n\t\t// cast raw data from tree into Poll struct\n\t\tp := value.(*Poll)\n\t\tyay, nay := p.VoteCount()\n\t\tyayPercent := 0\n\t\tnayPercent := 0\n\n\t\tif totalVotes := yay + nay; totalVotes != 0 {\n\t\t\tyayPercent = yay * 100 / totalVotes\n\t\t\tnayPercent = nay * 100 / totalVotes\n\t\t}\n\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\n\t\t\t\t\"## Poll #%s: %s\\n\",\n\t\t\t\tkey, // poll ID\n\t\t\t\tp.Title(),\n\t\t\t),\n\t\t)\n\n\t\tdropdown := \"\u003cdetails\u003e\\n\u003csummary\u003ePoll details\u003c/summary\u003e\u003cbr\u003e\"\n\t\tb.WriteString(dropdown + \"Description: \" + p.Description())\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\"\u003cbr\u003eVoting until block: %d\u003cbr\u003eCurrent vote count: %d\",\n\t\t\t\tp.Deadline(),\n\t\t\t\tp.Voters().Size()),\n\t\t)\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\"\u003cbr\u003eYAY votes: %d (%d%%)\", yay, yayPercent),\n\t\t)\n\t\tb.WriteString(\n\t\t\tufmt.Sprintf(\"\u003cbr\u003eNAY votes: %d (%d%%)\u003c/details\u003e\", nay, nayPercent),\n\t\t)\n\n\t\tdropdown = \"\u003cbr\u003e\u003cdetails\u003e\\n\u003csummary\u003eVote details\u003c/summary\u003e\"\n\t\tb.WriteString(dropdown)\n\n\t\tp.Voters().Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\t\tvoter := key\n\t\t\tvote := value.(bool)\n\n\t\t\tif vote {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"\u003cbr\u003e%s voted YAY!\", voter),\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tb.WriteString(\n\t\t\t\t\tufmt.Sprintf(\"\u003cbr\u003e%s voted NAY!\", voter),\n\t\t\t\t)\n\t\t\t}\n\t\t\treturn false\n\t\t})\n\n\t\tb.WriteString(\"\u003c/details\u003e\\n\\n\")\n\t\treturn false\n\t})\n\treturn b.String()\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"sbvXTGLtxoscJOnfltAA143rqTRwjt6V+9KU7Hw3TOVxUEuCBB4mMwf3+wywsrQh5UVKcH9rNRZfjZDRcjNQEA=="}],"memo":""},"blockNum":"161118"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","package":{"Name":"counter","Path":"gno.land/p/asdasd/asdasd/counter","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AzKti/XiFTeigS2l358qt7i7UIfEeHD8HjiNZPR5DUlD"},"signature":"YC3tN/LEMagRtf8h1H8bUa4noudjuUnuSLgYBBejtVRxqEjTai0rpyJHnoXubdZFKl/JpQaUebr0VrmFrOcCyA=="}],"memo":""},"blockNum":"161123"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","package":{"Name":"bankkkk","Path":"gno.land/p/bankkkk/bankkkk","Files":[{"Name":"package.gno","Body":"package bankkkk\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// order is an unexposed struct for security.\ntype order struct {\n\tfrom      Address\n\tto        Address\n\tamount    Coins\n\tprocessed bool\n}\n\n// String method for order provides a string representation.\nfunc (o *order) String() string {\n\treturn fmt.Sprintf(\"From: %s, To: %s, Amount: %v, Processed: %t\", o.from, o.to, o.amount, o.processed)\n}\n\n// Order wraps the internal *order for external use.\ntype Order struct {\n\t*order\n}\n\n// NewOrder creates a new Order.\nfunc NewOrder(from Address, to Address, amount Coins) Order {\n\treturn Order{\n\t\torder: \u0026order{\n\t\t\tfrom:   from,\n\t\t\tto:     to,\n\t\t\tamount: amount,\n\t\t},\n\t}\n}\n\n// Execute processes the order, returns error if already processed or nil.\nfunc (o *Order) Execute() error {\n\tif o.order == nil {\n\t\treturn errors.New(\"order is nil\")\n\t}\n\tif o.order.processed {\n\t\treturn errors.New(\"order already processed\")\n\t}\n\to.order.processed = true\n\t// TODO: Implement the actual execution logic.\n\treturn nil\n}\n\nfunc (o Order) IsZero() bool {\n\treturn o.order == nil\n}\n\nfunc (o Order) From() Address {\n\treturn o.order.from\n}\n\nfunc (o Order) To() Address {\n\treturn o.order.to\n}\n\nfunc (o Order) Amount() Coins {\n\treturn o.order.amount\n}\n\nfunc (o Order) Processed() bool {\n\treturn o.order.processed\n}\n\n//----------------------------------------\n// Escrow\n\ntype EscrowTerms struct {\n\tPartyA  Address\n\tPartyB  Address\n\tAmountA Coins\n\tAmountB Coins\n}\n\ntype EscrowContract struct {\n\tEscrowTerms\n\tOrderA Order\n\tOrderB Order\n}\n\nfunc CreateEscrow(terms EscrowTerms) *EscrowContract {\n\treturn \u0026EscrowContract{\n\t\tEscrowTerms: terms,\n\t}\n}\n\nfunc (esc *EscrowContract) SetOrderA(order Order) {\n\tif !esc.OrderA.IsZero() {\n\t\tpanic(\"order-a already set\")\n\t}\n\tif esc.EscrowTerms.PartyA != order.From() {\n\t\tpanic(\"invalid order-a:from mismatch\")\n\t}\n\tif esc.EscrowTerms.PartyB != order.To() {\n\t\tpanic(\"invalid order-a:to mismatch\")\n\t}\n\tif !esc.EscrowTerms.AmountA.Equal(order.Amount()) {\n\t\tpanic(\"invalid order-a amount\")\n\t}\n\tesc.OrderA = order\n}\n\nfunc (esc *EscrowContract) SetOrderB(order Order) {\n\tif !esc.OrderB.IsZero() {\n\t\tpanic(\"order-b already set\")\n\t}\n\tif esc.EscrowTerms.PartyB != order.From() {\n\t\tpanic(\"invalid order-b:from mismatch\")\n\t}\n\tif esc.EscrowTerms.PartyA != order.To() {\n\t\tpanic(\"invalid order-b:to mismatch\")\n\t}\n\tif !esc.EscrowTerms.AmountB.Equal(order.Amount()) {\n\t\tpanic(\"invalid order-b amount\")\n\t}\n\tesc.OrderB = order\n}\n\nfunc (esc *EscrowContract) Execute() error {\n\tif esc.OrderA.IsZero() || esc.OrderB.IsZero() {\n\t\treturn errors.New(\"one or both orders not set\")\n\t}\n\tif err := esc.OrderA.Execute(); err != nil {\n\t\treturn err\n\t}\n\tif err := esc.OrderB.Execute(); err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\n//----------------------------------------\n// Supporting types and methods.\n\ntype (\n\tAddress string\n\tCoins   []Coin\n\tCoin    struct {\n\t\tDenom  string\n\t\tAmount int64\n\t}\n)\n\nfunc (c Coins) Equal(b Coins) bool {\n\tif len(c) != len(b) {\n\t\treturn false\n\t}\n\tfor i, coinA := range c {\n\t\tcoinB := b[i]\n\t\tif coinA.Denom != coinB.Denom || coinA.Amount != coinB.Amount {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"sYU5Ej20tsTgAQByKWodF1ZFk5XI8hZClvwWyaHtP/IfqTX3onOCkda5vdMQCgB/3hBzBkdgFvqvcvO8cOfLWg=="}],"memo":""},"blockNum":"161125"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","package":{"Name":"mytoken","Path":"gno.land/r/asdsad/asdasd/mytoken","Files":[{"Name":"package.gno","Body":"package mytoken\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/p/demo/users\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\nvar (\n\tmytoken *grc20.AdminToken\n\tadmin   std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // set admin account\n)\n\n// init is a constructor function that runs only once (at time of deployment)\nfunc init() {\n\t// provision the token's name, symbol and number of decimals\n\tmytoken = grc20.NewAdminToken(\"Mytoken\", \"MTKN\", 4)\n\n\t// set the total supply\n\tmytoken.Mint(admin, 1000000*10000) // @administrator (supply = 1 million)\n}\n\nfunc TotalSupply() uint64 {\n\treturn mytoken.TotalSupply()\n}\n\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := mytoken.BalanceOf(owner.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := mytoken.Allowance(owner.Resolve(), spender.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn allowance\n}\n\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := mytoken.Transfer(caller, to.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := mytoken.Approve(caller, spender.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := mytoken.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mytoken.Mint(address.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mytoken.Burn(address.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn mytoken.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := mytoken.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AzKti/XiFTeigS2l358qt7i7UIfEeHD8HjiNZPR5DUlD"},"signature":"3S7a/nRXBSFvERzi9YNeZM2E+NQVmEgCXVdVbVCCEasfoDhI6uhSsy+GjjfN0Sa844/xo9s2nQUjl4o5ktnLuA=="}],"memo":""},"blockNum":"161129"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1dnllrdzwfhxv3evyk09y48mgn5phfjvtyrlzm7","package":{"Name":"mytoken","Path":"gno.land/r/mytoken/mytoken","Files":[{"Name":"package.gno","Body":"package mytoken\n\nimport (\n\t\"std\"\n\t\"strings\"\n\t\"gno.land/p/demo/grc/grc20\"\n\t\"gno.land/p/demo/users\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\nvar (\n\tmytoken *grc20.AdminToken\n\tadmin   std.Address = \"g1us8428u2a5satrlxzagqqa5m6vmuze025anjlj\" // set admin account\n)\n\n// init is a constructor function that runs only once (at time of deployment)\nfunc init() {\n\t// provision the token's name, symbol and number of decimals\n\tmytoken = grc20.NewAdminToken(\"Mytoken\", \"MTKN\", 4)\n\n\t// set the total supply\n\tmytoken.Mint(admin, 1000000*10000) // @administrator (supply = 1 million)\n}\n\nfunc TotalSupply() uint64 {\n\treturn mytoken.TotalSupply()\n}\n\nfunc BalanceOf(owner users.AddressOrName) uint64 {\n\tbalance, err := mytoken.BalanceOf(owner.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn balance\n}\n\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\n\tallowance, err := mytoken.Allowance(owner.Resolve(), spender.Resolve())\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn allowance\n}\n\nfunc Transfer(to users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := mytoken.Transfer(caller, to.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Approve(spender users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := mytoken.Approve(caller, spender.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\terr := mytoken.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Mint(address users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mytoken.Mint(address.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Burn(address users.AddressOrName, amount uint64) {\n\tcaller := std.PrevRealm().Addr()\n\tassertIsAdmin(caller)\n\terr := mytoken.Burn(address.Resolve(), amount)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc Render(path string) string {\n\tparts := strings.Split(path, \"/\")\n\tc := len(parts)\n\n\tswitch {\n\tcase path == \"\":\n\t\treturn mytoken.RenderHome()\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\n\t\towner := users.AddressOrName(parts[1])\n\t\tbalance, _ := mytoken.BalanceOf(owner.Resolve())\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\n\tdefault:\n\t\treturn \"404\\n\"\n\t}\n}\n\nfunc assertIsAdmin(address std.Address) {\n\tif address != admin {\n\t\tpanic(\"restricted access\")\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsGEi/6/N0zRtRCWxHb7KZ1Z/BTfZIc77fvtkSRJlmwQ"},"signature":"xChXG2DvK7g8TYTBA09uR89xVj+TjGP5VnYzQ0z9BVs3dZnq6VtWRat9rJ1SlZKDXL7vpjpXxBzPYztc8V5J9g=="}],"memo":""},"blockNum":"161131"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p6wtprf8wl2s5z08s0tmn7snxlq0tdjvv46tm9","package":{"Name":"blog","Path":"gno.land/r/asasdasd/asasd/blog","Files":[{"Name":"package.gno","Body":"package blog\n\nimport (\n\t\"errors\"\n\t\"std\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\t\"gno.land/p/demo/avl\"\n\t\"gno.land/p/demo/mux\"\n\t\"gno.land/p/demo/ufmt\"\n)\n\ntype Blog struct {\n\tTitle        string\n\tPrefix       string   // i.e. r/gnoland/blog:\n\tPosts        avl.Tree // slug -\u003e Post\n\tNoBreadcrumb bool\n}\n\nfunc (b Blog) RenderLastPostsWidget(limit int) string {\n\toutput := \"\"\n\ti := 0\n\tb.Posts.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tp := value.(*Post)\n\t\toutput += ufmt.Sprintf(\"- [%s](%s)\\n\", p.Title, p.URL())\n\t\ti++\n\t\treturn i \u003e= limit\n\t})\n\treturn output\n}\n\nfunc (b Blog) RenderHome(res *mux.ResponseWriter, req *mux.Request) {\n\tif !b.NoBreadcrumb {\n\t\tres.Write(breadcrumb([]string{b.Title}))\n\t}\n\n\tif b.Posts.Size() == 0 {\n\t\tres.Write(\"No posts.\")\n\t\treturn\n\t}\n\n\tres.Write(\"\u003cdiv class='columns-3'\u003e\")\n\tb.Posts.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tpost := value.(*Post)\n\t\tres.Write(post.RenderListItem())\n\t\treturn false\n\t})\n\tres.Write(\"\u003c/div\u003e\")\n\n\t// FIXME: tag list/cloud.\n}\n\nfunc (b Blog) RenderPost(res *mux.ResponseWriter, req *mux.Request) {\n\tslug := req.GetVar(\"slug\")\n\n\tpost, found := b.Posts.Get(slug)\n\tif !found {\n\t\tres.Write(\"404\")\n\t\treturn\n\t}\n\tp := post.(*Post)\n\n\tif !b.NoBreadcrumb {\n\t\tbreadStr := breadcrumb([]string{\n\t\t\tufmt.Sprintf(\"[%s](%s)\", b.Title, b.Prefix),\n\t\t\t\"p\",\n\t\t\tp.Title,\n\t\t})\n\t\tres.Write(breadStr)\n\t}\n\n\t// output += ufmt.Sprintf(\"## [%s](%s)\\n\", p.Title, p.URL())\n\tres.Write(p.Body + \"\\n\\n\")\n\tres.Write(p.RenderTagList() + \"\\n\\n\")\n\tres.Write(formatAuthorAndDate(p.Author, p.CreatedAt) + \"\\n\\n\")\n\n\t// comments\n\tp.Comments.ReverseIterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tcomment := value.(*Comment)\n\t\tres.Write(comment.RenderListItem())\n\t\treturn false\n\t})\n}\n\nfunc (b Blog) RenderTag(res *mux.ResponseWriter, req *mux.Request) {\n\tslug := req.GetVar(\"slug\")\n\n\tif slug == \"\" {\n\t\tres.Write(\"404\")\n\t\treturn\n\t}\n\n\tif !b.NoBreadcrumb {\n\t\tbreadStr := breadcrumb([]string{\n\t\t\tufmt.Sprintf(\"[%s](%s)\", b.Title, b.Prefix),\n\t\t\t\"t\",\n\t\t\tslug,\n\t\t})\n\t\tres.Write(breadStr)\n\t}\n\n\tnb := 0\n\tb.Posts.Iterate(\"\", \"\", func(key string, value interface{}) bool {\n\t\tpost := value.(*Post)\n\t\tif !post.HasTag(slug) {\n\t\t\treturn false\n\t\t}\n\t\tres.Write(post.RenderListItem())\n\t\tnb++\n\t\treturn false\n\t})\n\tif nb == 0 {\n\t\tres.Write(\"No posts.\")\n\t}\n}\n\nfunc (b Blog) Render(path string) string {\n\trouter := mux.NewRouter()\n\trouter.HandleFunc(\"\", b.RenderHome)\n\trouter.HandleFunc(\"p/{slug}\", b.RenderPost)\n\trouter.HandleFunc(\"t/{slug}\", b.RenderTag)\n\treturn router.Render(path)\n}\n\nfunc (b *Blog) NewPost(author std.Address, slug, title, body string, tags []string) error {\n\t_, found := b.Posts.Get(slug)\n\tif found {\n\t\treturn errors.New(\"slug already exists.\")\n\t}\n\n\tpost := Post{\n\t\tAuthor:    author,\n\t\tSlug:      slug,\n\t\tTitle:     title,\n\t\tBody:      body,\n\t\tTags:      tags,\n\t\tCreatedAt: time.Now(),\n\t}\n\treturn b.prepareAndSetPost(\u0026post)\n}\n\nfunc (b *Blog) prepareAndSetPost(post *Post) error {\n\tpost.Title = strings.TrimSpace(post.Title)\n\tpost.Body = strings.TrimSpace(post.Body)\n\n\tif post.Title == \"\" {\n\t\treturn errors.New(\"title is missing.\")\n\t}\n\tif post.Body == \"\" {\n\t\treturn errors.New(\"body is missing.\")\n\t}\n\tif post.Slug == \"\" {\n\t\treturn errors.New(\"slug is missing.\")\n\t}\n\t// more input sanitization?\n\n\tpost.Blog = b\n\tpost.UpdatedAt = time.Now()\n\n\tb.Posts.Set(post.Slug, post)\n\treturn nil\n}\n\nfunc (b *Blog) GetPost(slug string) *Post {\n\tpost, found := b.Posts.Get(slug)\n\tif !found {\n\t\treturn nil\n\t}\n\treturn post.(*Post)\n}\n\ntype Post struct {\n\tBlog         *Blog\n\tSlug         string // FIXME: save space?\n\tTitle        string\n\tBody         string\n\tCreatedAt    time.Time\n\tUpdatedAt    time.Time\n\tComments     avl.Tree\n\tAuthor       std.Address\n\tTags         []string\n\tCommentIndex int\n}\n\nfunc (p *Post) Update(title, body string, tags []string) error {\n\tp.Title = title\n\tp.Body = body\n\tp.Tags = tags\n\treturn p.Blog.prepareAndSetPost(p)\n}\n\nfunc (p *Post) AddComment(author std.Address, comment string) error {\n\tif p == nil {\n\t\treturn ErrNoSuchPost\n\t}\n\tp.CommentIndex++\n\tcommentKey := strconv.Itoa(p.CommentIndex)\n\tcomment = strings.TrimSpace(comment)\n\tp.Comments.Set(commentKey, \u0026Comment{\n\t\tPost:      p,\n\t\tCreatedAt: time.Now(),\n\t\tAuthor:    author,\n\t\tComment:   comment,\n\t})\n\n\treturn nil\n}\n\nfunc (p *Post) DeleteComment(index int) error {\n\tif p == nil {\n\t\treturn ErrNoSuchPost\n\t}\n\tcommentKey := strconv.Itoa(index)\n\tp.Comments.Remove(commentKey)\n\treturn nil\n}\n\nfunc (p *Post) HasTag(tag string) bool {\n\tif p == nil {\n\t\treturn false\n\t}\n\tfor _, t := range p.Tags {\n\t\tif t == tag {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (p *Post) RenderListItem() string {\n\tif p == nil {\n\t\treturn \"error: no such post\\n\"\n\t}\n\toutput := \"\u003cdiv\u003e\\n\\n\"\n\toutput += ufmt.Sprintf(\"## [%s](%s)\\n\", p.Title, p.URL())\n\toutput += ufmt.Sprintf(\"**[Learn More](%s)**\\n\", p.URL())\n\t// output += p.Summary() + \"\\n\\n\"\n\t// output += p.RenderTagList() + \"\\n\\n\"\n\t// output += formatAuthorAndDate(p.Author, p.CreatedAt) + \"\\n\"\n\toutput += \"\\n\"\n\toutput += \"\u003c/div\u003e\"\n\treturn output\n}\n\nfunc (p *Post) RenderTagList() string {\n\tif p == nil {\n\t\treturn \"error: no such post\\n\"\n\t}\n\toutput := \"\"\n\tfor idx, tag := range p.Tags {\n\t\tif idx \u003e 0 {\n\t\t\toutput += \" \"\n\t\t}\n\t\ttagURL := p.Blog.Prefix + \"t/\" + tag\n\t\toutput += ufmt.Sprintf(\"[#%s](%s)\", tag, tagURL)\n\t}\n\treturn output\n}\n\nfunc (p *Post) URL() string {\n\tif p == nil {\n\t\treturn p.Blog.Prefix + \"404\"\n\t}\n\treturn p.Blog.Prefix + \"p/\" + p.Slug\n}\n\nfunc (p *Post) Summary() string {\n\tif p == nil {\n\t\treturn \"error: no such post\\n\"\n\t}\n\n\t// FIXME: better summary.\n\tlines := strings.Split(p.Body, \"\\n\")\n\tif len(lines) \u003c= 3 {\n\t\treturn p.Body\n\t}\n\treturn strings.Join(lines[0:3], \"\\n\") + \"...\"\n}\n\ntype Comment struct {\n\tPost      *Post\n\tCreatedAt time.Time\n\tAuthor    std.Address\n\tComment   string\n}\n\nfunc (c Comment) RenderListItem() string {\n\toutput := \"\"\n\toutput += ufmt.Sprintf(\"#### %s\\n\", formatAuthorAndDate(c.Author, c.CreatedAt))\n\toutput += c.Comment + \"\\n\"\n\toutput += \"\\n\"\n\treturn output\n}\n\nfunc formatAuthorAndDate(author std.Address, createdAt time.Time) string {\n\tauthorString := author.String() // FIXME: username.\n\tcreatedAtString := createdAt.Format(\"2006-01-02 3:04pm MST\")\n\treturn ufmt.Sprintf(\"by %s on %s\", authorString, createdAtString)\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AzKti/XiFTeigS2l358qt7i7UIfEeHD8HjiNZPR5DUlD"},"signature":"mZ6KeGKCrf+jxvfWW1x8V2FK8kXJaUElJxeEO7HgpHgFjCnDW+RWLqeE13bBYNMyYPBnjZ9h+h2b4f56G8OOew=="}],"memo":""},"blockNum":"161133"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g17ec6vfn5w5lzs9s5cxqjuy3xd9kqpkhg6zd4an","package":{"Name":"2","Path":"gno.land/p/1/2","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsUL/t706SoKrZcCOQLfo+LH20e1Y+mUcsrORgc118XG"},"signature":"CwfhNZR+IvygdR+sCLaS2qKTnkQxx2l2SKY9Hby7hQl7x4X/XbVBN9c3XdasTQQwLJDVUS+Z/EuD0SjvjUvAWQ=="}],"memo":""},"blockNum":"161159"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g17ec6vfn5w5lzs9s5cxqjuy3xd9kqpkhg6zd4an","package":{"Name":"2","Path":"gno.land/p/1/2","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"1.gno","Body":"package hello\r\n\r\nimport \"testing\"\r\n\r\nfunc TestHello(t *testing.T) {\r\n\tgot := Render(\"\")\r\n\texpected := \"Hello World!\"\r\n\tif got != expected {\r\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\r\n\t}\r\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsUL/t706SoKrZcCOQLfo+LH20e1Y+mUcsrORgc118XG"},"signature":"szlB28Lh30nG87irM78rzE8M+A0MsUg2uIBmUzpDPk8DVLxPRt43T6u5Ju1s4yKpqFQsUsFk+K3iETIctzwovQ=="}],"memo":""},"blockNum":"161170"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g17ec6vfn5w5lzs9s5cxqjuy3xd9kqpkhg6zd4an","package":{"Name":"0","Path":"gno.land/p/1/0","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"1.gno","Body":"package hello\r\n\r\nimport \"testing\"\r\n\r\nfunc TestHello(t *testing.T) {\r\n\tgot := Render(\"\")\r\n\texpected := \"Hello World!\"\r\n\tif got != expected {\r\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\r\n\t}\r\n}"},{"Name":"count.gno","Body":"package count\r\n\r\nimport \"testing\"\r\n\r\nfunc TestCount(t *testing.T) {\r\n\tAdd()\r\n\tAdd()\r\n\tAdd()\r\n\tRemove()\r\n\tgot := Render(\"\")\r\n\texpected := \"Count: 2\"\r\n\tif got != expected {\r\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\r\n\t}\r\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsUL/t706SoKrZcCOQLfo+LH20e1Y+mUcsrORgc118XG"},"signature":"3LGZ0vo2wIF0SLB9WwuRDwQaRvIzaJbMnpDYi9bi8b5OUBlPnkgnx9TXUYvVjSnjbYm+Ju7OOHW/4+tZiV0/4A=="}],"memo":""},"blockNum":"161173"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g17ec6vfn5w5lzs9s5cxqjuy3xd9kqpkhg6zd4an","package":{"Name":"test","Path":"gno.land/p/test/test","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"tong.gno","Body":"package tong\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\ttong  *grc20.AdminToken\r\n\tadmin std.Address = \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\r\n)\r\n\r\nfunc init() {\r\n\ttong = grc20.NewAdminToken(\"Tong\", \"TONG\", 4)\r\n\ttong.Mint(admin, 123456789) // @administrator (1M)\r\n}\r\n\r\n// method proxies as public functions.\r\n//\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn tong.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := tong.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := tong.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\ttong.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\ttong.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render.\r\n//\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn tong.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := tong.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsUL/t706SoKrZcCOQLfo+LH20e1Y+mUcsrORgc118XG"},"signature":"fymD9MnYzinVb2TS3bPsg0W4qpIlV/+GU5J1LweUpsVQymDz2e0woLfDXpGEaB0NN4cJJaBj4Sno08VNR9zibA=="}],"memo":""},"blockNum":"161177"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g17ec6vfn5w5lzs9s5cxqjuy3xd9kqpkhg6zd4an","package":{"Name":"test","Path":"gno.land/p/test/test","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"tong.gno","Body":"package tong\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\ttong  *grc20.AdminToken\r\n\tadmin std.Address = \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\r\n)\r\n\r\nfunc init() {\r\n\ttong = grc20.NewAdminToken(\"Tong\", \"TONG\", 4)\r\n\ttong.Mint(admin, 123456789) // @administrator (1M)\r\n}\r\n\r\n// method proxies as public functions.\r\n//\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn tong.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := tong.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := tong.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\ttong.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\ttong.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render.\r\n//\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn tong.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := tong.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsUL/t706SoKrZcCOQLfo+LH20e1Y+mUcsrORgc118XG"},"signature":"Ihlu2Zt13eHQy49GI2zxHsEJ2yXivzHNs/9aGMwONF0fwHyYFHwTO8/lVo0QI12qioRrXecVMSoIPB0Jt01RCw=="}],"memo":""},"blockNum":"161179"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g17ec6vfn5w5lzs9s5cxqjuy3xd9kqpkhg6zd4an","package":{"Name":"grc20","Path":"gno.land/p/grc/grc20","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"tong.gno","Body":"package tong\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\ttong  *grc20.AdminToken\r\n\tadmin std.Address = \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\r\n)\r\n\r\nfunc init() {\r\n\ttong = grc20.NewAdminToken(\"Tong\", \"TONG\", 4)\r\n\ttong.Mint(admin, 123456789) // @administrator (1M)\r\n}\r\n\r\n// method proxies as public functions.\r\n//\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn tong.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := tong.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := tong.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\ttong.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\ttong.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render.\r\n//\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn tong.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := tong.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsUL/t706SoKrZcCOQLfo+LH20e1Y+mUcsrORgc118XG"},"signature":"du0AkKbscVbGLQS2PAMwfd6TM+ZXD6isFHfafZAwAPtaRQ+XJmuDWOYMj8p6k9xwuFuu+xveu90eYVmgdRuJGg=="}],"memo":""},"blockNum":"161181"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g17ec6vfn5w5lzs9s5cxqjuy3xd9kqpkhg6zd4an","package":{"Name":"1","Path":"gno.land/p/grc20/1","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"tong.gno","Body":"package tong\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\ttong  *grc20.AdminToken\r\n\tadmin std.Address = \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\r\n)\r\n\r\nfunc init() {\r\n\ttong = grc20.NewAdminToken(\"Tong\", \"TONG\", 4)\r\n\ttong.Mint(admin, 123456789) // @administrator (1M)\r\n}\r\n\r\n// method proxies as public functions.\r\n//\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn tong.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := tong.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := tong.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\ttong.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\ttong.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render.\r\n//\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn tong.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := tong.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsUL/t706SoKrZcCOQLfo+LH20e1Y+mUcsrORgc118XG"},"signature":"oUmdjiFEchutXZYFL9ij8Z4BvgX0yGn18JhTT31tmgJVLN0fjbnvYw8Je2KZagzMEgYnfNF1UI8vJXuy9Yk9lQ=="}],"memo":""},"blockNum":"161183"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g17ec6vfn5w5lzs9s5cxqjuy3xd9kqpkhg6zd4an","package":{"Name":"ufmt","Path":"gno.land/p/demo/ufmt","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"1.gno","Body":"package tong\r\n\r\nimport (\r\n\t\"std\"\r\n\t\"strings\"\r\n\r\n\t\"gno.land/p/demo/grc/grc20\"\r\n\t\"gno.land/p/demo/ufmt\"\r\n\t\"gno.land/r/demo/users\"\r\n)\r\n\r\nvar (\r\n\ttong  *grc20.AdminToken\r\n\tadmin std.Address = \"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5\"\r\n)\r\n\r\nfunc init() {\r\n\ttong = grc20.NewAdminToken(\"Tong\", \"TONG\", 4)\r\n\ttong.Mint(admin, 123456789) // @administrator (1M)\r\n}\r\n\r\n// method proxies as public functions.\r\n//\r\n\r\n// getters.\r\n\r\nfunc TotalSupply() uint64 {\r\n\treturn tong.TotalSupply()\r\n}\r\n\r\nfunc BalanceOf(owner users.AddressOrName) uint64 {\r\n\tbalance, err := tong.BalanceOf(owner.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn balance\r\n}\r\n\r\nfunc Allowance(owner, spender users.AddressOrName) uint64 {\r\n\tallowance, err := tong.Allowance(owner.Resolve(), spender.Resolve())\r\n\tif err != nil {\r\n\t\tpanic(err)\r\n\t}\r\n\treturn allowance\r\n}\r\n\r\n// setters.\r\n\r\nfunc Transfer(to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.Transfer(caller, to.Resolve(), amount)\r\n}\r\n\r\nfunc Approve(spender users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.Approve(caller, spender.Resolve(), amount)\r\n}\r\n\r\nfunc TransferFrom(from, to users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.TransferFrom(caller, from.Resolve(), to.Resolve(), amount)\r\n}\r\n\r\n// faucet.\r\n\r\nfunc Faucet() {\r\n\t// FIXME: add limits?\r\n\t// FIXME: add payment in gnot?\r\n\tcaller := std.GetOrigCaller()\r\n\ttong.Mint(caller, 1000*10000) // 1k\r\n}\r\n\r\n// administration.\r\n\r\nfunc Mint(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\ttong.Mint(address.Resolve(), amount)\r\n}\r\n\r\nfunc Burn(address users.AddressOrName, amount uint64) {\r\n\tcaller := std.GetOrigCaller()\r\n\tassertIsAdmin(caller)\r\n\ttong.Burn(address.Resolve(), amount)\r\n}\r\n\r\n// render.\r\n//\r\n\r\nfunc Render(path string) string {\r\n\tparts := strings.Split(path, \"/\")\r\n\tc := len(parts)\r\n\r\n\tswitch {\r\n\tcase path == \"\":\r\n\t\treturn tong.RenderHome()\r\n\tcase c == 2 \u0026\u0026 parts[0] == \"balance\":\r\n\t\towner := users.AddressOrName(parts[1])\r\n\t\tbalance, _ := tong.BalanceOf(owner.Resolve())\r\n\t\treturn ufmt.Sprintf(\"%d\\n\", balance)\r\n\tdefault:\r\n\t\treturn \"404\\n\"\r\n\t}\r\n}\r\n\r\nfunc assertIsAdmin(address std.Address) {\r\n\tif address != admin {\r\n\t\tpanic(\"restricted access\")\r\n\t}\r\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsUL/t706SoKrZcCOQLfo+LH20e1Y+mUcsrORgc118XG"},"signature":"wgBMgigyGzkvpycl7NAakxceTeYvn4CZQKCpSnOyOVMQCYabOy4/eqyVvt115+rH3QRCsSEQqHEdg6LZQR/uEA=="}],"memo":""},"blockNum":"161186"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14vhcdsyf83ngsrrqc92kmw8q9xakqjm0v8448t","send":"","pkg_path":"gno.land/r/demo/minter","func":"Mint","args":["g1qf62mdy2w4hxjdm9kn7plk2eu5n8majvetrr5n","ugnot","310000000"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgiTyNXOXskkkxKv2DXaDxFtabuTPHlltbYwCOBpHL3w"},"signature":"c1TAgiXhkHzJJS72BYDbDkFbWYgyvnEZYO4pono1I2MQlgEzwl6sTS4ED7o1K7wjVz6q0T5UmOCWlVeFaulGtA=="}],"memo":""},"blockNum":"161225"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1qf62mdy2w4hxjdm9kn7plk2eu5n8majvetrr5n","package":{"Name":"name","Path":"gno.land/p/namespace/name","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Au2Kh1Eb07hQwNBiioJ/FjjWtl+uqNfvCIlNBBxPtAlY"},"signature":"HHn1loIm0zhQanaGxc6v33kpyx3ytcgMaFFRvCNbsqtlSORHHnXI8op82+2lPI7OI7FIHcDs5ERvTFj8evpaCQ=="}],"memo":""},"blockNum":"161228"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1qf62mdy2w4hxjdm9kn7plk2eu5n8majvetrr5n","package":{"Name":"miauw","Path":"gno.land/p/jemoeder/miauw","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Au2Kh1Eb07hQwNBiioJ/FjjWtl+uqNfvCIlNBBxPtAlY"},"signature":"pUXHHYpicwq/+hJG5m0MIW69TmuQEH3Pzr2FR4LKKrEjv1RbPj5veaXx0HZj4QqZ6mCkfIQl38GdDGTDx+5TPg=="}],"memo":""},"blockNum":"161230"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1qf62mdy2w4hxjdm9kn7plk2eu5n8majvetrr5n","package":{"Name":"test","Path":"gno.land/p/jemoeder/test","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"},{"Name":"miauw.gno","Body":"println(\"Hello world\r\n\")"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Au2Kh1Eb07hQwNBiioJ/FjjWtl+uqNfvCIlNBBxPtAlY"},"signature":"mjbSGe/kpZQfl2aCWYVA8M8LTf4bKJZH//7R1/9qpKZS3X8isB25usz6dS3NyprtiAmR7vC2hCFl3lrJniSTJw=="}],"memo":""},"blockNum":"161234"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1qf62mdy2w4hxjdm9kn7plk2eu5n8majvetrr5n","package":{"Name":"test","Path":"gno.land/r/jemoeder/test","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"},{"Name":"miauw.gno","Body":"println(\"Hello world\r\n\")"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Au2Kh1Eb07hQwNBiioJ/FjjWtl+uqNfvCIlNBBxPtAlY"},"signature":"3lyaIrFnK+UjJQcOuoUfInNOxMxv7e+IV6AIj/kzytpq9fmsj8vhp1gRzHGRUx1yqzzuoD6H7DO5cAth8M5NYA=="}],"memo":""},"blockNum":"161236"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1qf62mdy2w4hxjdm9kn7plk2eu5n8majvetrr5n","package":{"Name":"test","Path":"gno.land/r/jemoeder/test","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"},{"Name":"miauw.gno","Body":"println(\"Hello world\")"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Au2Kh1Eb07hQwNBiioJ/FjjWtl+uqNfvCIlNBBxPtAlY"},"signature":"NkTogq05Qv6IkcWe3Hvku6fb8Kj9p5YEOrl1p/WeyUdJU0kalyPgmRruXTFinvZjEP7NUfptcFw3GFbFRb9SNw=="}],"memo":""},"blockNum":"161238"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1qf62mdy2w4hxjdm9kn7plk2eu5n8majvetrr5n","package":{"Name":"name","Path":"gno.land/p/jemoeder/name","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"},{"Name":"miauw.gno","Body":"println(\"Hello world\")"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Au2Kh1Eb07hQwNBiioJ/FjjWtl+uqNfvCIlNBBxPtAlY"},"signature":"VXanHLr0C+DOWuaZfnc9Yd9z4QzWoU0nvdmPF1R7lAxQ++FB4fjYdauJBK0fO/l8zgU/zAqgxrpodfmJFlbe1Q=="}],"memo":""},"blockNum":"161240"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1qf62mdy2w4hxjdm9kn7plk2eu5n8majvetrr5n","package":{"Name":"nkag","Path":"gno.land/p/dijagiofsa/nkag","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"},{"Name":"hi.gno","Body":"./build/gnokey maketx call KEYNAME --pkgpath \"gno.land/r/demo/boards\" --func \"CreateBoard\" --args \"BOARDNAME\" --gas-fee \"1000000ugnot\" --gas-wanted \"2000000\" --broadcast true --chainid test3 --remote test3.gno.land:36657\r\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Au2Kh1Eb07hQwNBiioJ/FjjWtl+uqNfvCIlNBBxPtAlY"},"signature":"7dmMkyuz2e0pG1n6T7Dmp1UJfN4c7DJ6gzDYSVdISvclyDKxh/QMhvMnLMB6r3Ez43lVOwG+jTOKgSWGK6bwQA=="}],"memo":""},"blockNum":"161244"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1qf62mdy2w4hxjdm9kn7plk2eu5n8majvetrr5n","package":{"Name":"test","Path":"gno.land/p/test/test","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"},{"Name":"hi.gno","Body":"./build/gnokey maketx call test1 --pkgpath \"gno.land/r/demo/boards\" --func CreateBoard --args \"testboard\" --gas-fee 1ugnot --gas-wanted 2000000 \u003e createboard.unsigned.txt\r\n./build/gnokey sign test1 --txpath createboard.unsigned.txt --chainid \"test3\" --number 0 --sequence 2 \u003e createboard.signed.txt\r\n./build/gnokey broadcast createboard.signed.txt --remote test3.gno.land:36657"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Au2Kh1Eb07hQwNBiioJ/FjjWtl+uqNfvCIlNBBxPtAlY"},"signature":"KMJL9/KlutFyo125TN9heIyy3gZxXs4qs6Lb0EBvvsBD74xoG+mEP3zfDEa9a2RxYpwjw3XbEWGbHcInfE3QfQ=="}],"memo":""},"blockNum":"161247"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1qf62mdy2w4hxjdm9kn7plk2eu5n8majvetrr5n","package":{"Name":"longtest","Path":"gno.land/p/long/longtest","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"},{"Name":"long.gno","Body":"{\r\n  \"fee\": {\r\n    \"gas_fee\": \"1ugnot\",\r\n    \"gas_wanted\": \"1000000\"\r\n  },\r\n  \"hash\": \"HcxNCowexHlj7uJEpF2rkeAjN8l8/IxMuJZ1sSWlD7s=\",\r\n  \"memo\": \"\",\r\n  \"msg\": [\r\n    {\r\n      \"@type\": \"/vm.m_call\",\r\n      \"args\": [\r\n        \"g1qf62mdy2w4hxjdm9kn7plk2eu5n8majvetrr5n\",\r\n        \"ugnot\",\r\n        \"310000000\"\r\n      ],\r\n      \"caller\": \"g14vhcdsyf83ngsrrqc92kmw8q9xakqjm0v8448t\",\r\n      \"func\": \"Mint\",\r\n      \"pkg_path\": \"gno.land/r/demo/minter\",\r\n      \"send\": \"\"\r\n    }\r\n  ],\r\n  \"signatures\": [\r\n    {\r\n      \"pub_key\": {\r\n        \"@type\": \"/tm.PubKeySecp256k1\",\r\n        \"value\": \"AgiTyNXOXskkkxKv2DXaDxFtabuTPHlltbYwCOBpHL3w\"\r\n      },\r\n      \"signature\": \"c1TAgiXhkHzJJS72BYDbDkFbWYgyvnEZYO4pono1I2MQlgEzwl6sTS4ED7o1K7wjVz6q0T5UmOCWlVeFaulGtA==\"\r\n    }\r\n  ]\r\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"Au2Kh1Eb07hQwNBiioJ/FjjWtl+uqNfvCIlNBBxPtAlY"},"signature":"77RIGQOs44CzUeiQnm2Ii3Tb+M4bsb5A6wlRlWf/nUwvXS1uUTg6kW1nVG+j54XTbB/n1Ij99v+tONTuU7olbg=="}],"memo":""},"blockNum":"161251"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa","package":{"Name":"or","Path":"gno.land/p/gnogno/or","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n\treturn \"Hello World!\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5VVQOKuIJduYT53isYRljsPqVIOmvoodigS0VTlJJpd"},"signature":"G4B6JiML8HZ8Kt8SK3EmgLxJkPlQX8LT70AGI13jwkkVPmRADhZNKd+IFqK4dIFylWzbdLq+GdlwyI5Q/WCDIA=="}],"memo":""},"blockNum":"161267"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa","package":{"Name":"OR","Path":"gno.land/p/gnogno/OR","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n\treturn \"Hello World!\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5VVQOKuIJduYT53isYRljsPqVIOmvoodigS0VTlJJpd"},"signature":"LXFGDiIMYllVSsk5cFJ47MV0c8Zf61beEx5GPoeoC94Usn/O0io1/qJDgzYj+MYYORkoKmHg7g/ab9NQCItMQQ=="}],"memo":""},"blockNum":"161269"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa","package":{"Name":"or","Path":"gno.land/p/gnogno/or","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5VVQOKuIJduYT53isYRljsPqVIOmvoodigS0VTlJJpd"},"signature":"tKku/iuBG6c1CkYFWZjiEgMlaPGr/xxKOtWAE4okatMhjUVdH/MHQZG5TiRXrN0BzseNzXQfh7WuCmRyR0wQ5w=="}],"memo":""},"blockNum":"161274"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1anajhdr28jlh4dd6dz5pzdjk0dsyqvc4ayk0aa","package":{"Name":"gno","Path":"gno.land/p/gno/gno","Files":[{"Name":"counter.gno","Body":"package counter\n\nimport \"gno.land/p/demo/ufmt\"\n\nvar count int\n\nfunc Render(path string) string {\n\treturn ufmt.Sprintf(\"Count: %d\", count)\n}\n\nfunc Add() {\n\tcount++\n}\n\nfunc Remove() {\n\tcount--\n}\n\n"},{"Name":"counter_test.gno","Body":"package counter\n\nimport \"testing\"\n\nfunc TestCount(t *testing.T) {\n\tAdd()\n\tAdd()\n\tAdd()\n\tRemove()\n\tgot := Render(\"\")\n\texpected := \"Count: 2\"\n\tif got != expected {\n\t\tt.Fatalf(\"expected %q, got %q.\", expected, got)\n\t}\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5VVQOKuIJduYT53isYRljsPqVIOmvoodigS0VTlJJpd"},"signature":"nTg+hddrCMvDXdZr5hOCC23MHHL1LYWbsbzGCM98V+BIgJ7up+3OfLGRaXJPZbIZdXCFKGKbCdV72HYIEvx7Tw=="}],"memo":""},"blockNum":"161289"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1erctqqrujmtaen2pw9xcmw4hgftjtfarkt4aap","package":{"Name":"gnowhite","Path":"gno.land/p/gnowhite/gnowhite","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A1hcfOtUs/RKSuafXst21vdD5M5JQIqau/insUouaml5"},"signature":"e44aMckg5muDIFsqzNdEfD2B8PFOpF1QwYnm8yZiUWFPZpSmP/EiKjoaDyEEBziVwkVo1+bskQwuywPjD4xuHQ=="}],"memo":""},"blockNum":"161393"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1erctqqrujmtaen2pw9xcmw4hgftjtfarkt4aap","package":{"Name":"whiteshade","Path":"gno.land/p/gnowhite/whiteshade","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A1hcfOtUs/RKSuafXst21vdD5M5JQIqau/insUouaml5"},"signature":"Z2d/qXFkIHAxYAQVnVsxRDe6F0OrOsLgX55u9xB8ezxR8CYTLixXIJvHNzmx8IyyTkr3bZg6Y/k7W4zqe/YPiQ=="}],"memo":""},"blockNum":"161395"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g1erctqqrujmtaen2pw9xcmw4hgftjtfarkt4aap","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"qIUXy8TdbWgbVxOQplo+hoOebCot10ZnhERWGfR03GhBvtajGtbNoCqDA3M8fmAfu4Z/VojXdR3fbjzOZVp8nA=="}],"memo":""},"blockNum":"161398"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14vhcdsyf83ngsrrqc92kmw8q9xakqjm0v8448t","send":"","pkg_path":"gno.land/r/demo/minter","func":"Mint","args":["g1w5nhjjdcaacj5v5twke02e98l5w0s0lnhk0rry","ugnot","310000000"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgiTyNXOXskkkxKv2DXaDxFtabuTPHlltbYwCOBpHL3w"},"signature":"P9SNBzSMQz13rJ4UFH3ieLMi2RAFcSaK3TUe5JFPwx4EJfEJjTR+2e2gp4T2TjSt1icD1WIxpWOke71kMYwClg=="}],"memo":""},"blockNum":"161447"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13d7jc32adhc39erm5me38w5v7ej7lpvlnqjk73","to_address":"g18cwpdpsqd8mywj8skpsqsg9tn9hudkkpa6ycpe","amount":"20000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A/+cjV0/gZkWzMqCul8aP5hC7M3yliIs17uinn/+66uR"},"signature":"L60DPgmlxdkraAC7rN6uB/Vz+p+Ud94TTXOnKobkJT47ZpIhBW19YA6Onz0rOFrQ4CtC6uDb5aMceEdn4RrSdw=="}],"memo":""},"blockNum":"161505"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g18cwpdpsqd8mywj8skpsqsg9tn9hudkkpa6ycpe","package":{"Name":"a","Path":"gno.land/r/t/a","Files":[{"Name":"tictactoe.gno","Body":"package tictactoe\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n\tID         string\n\tboard      [3][3]int8\n\tturnPlayer int8\n\tplayer1    string\n\tplayer2    string\n\twinner     int8\n\tstatus     int8 // 0=open 1=closed\n}\n\nvar (\n\tallGames       avl.Tree\n\tnextGameId     int64\n\tavailableGames []string\n\tuserGames      avl.Tree\n)\n\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\n\nfunc StartGame(_ string) string {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn startGame(caller)\n}\n\nfunc startGame(player std.Address) string {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatInt(nextGameId, 10))\n\tg := \u0026gameState{\n\t\tID:         id,\n\t\tboard:      [3][3]int8{},\n\t\tturnPlayer: 1,\n\t\tplayer1:    string(player),\n\t\tplayer2:    \"\",\n\t\tstatus:     0,\n\t}\n\tallGames.Set(string(g.ID), g)\n\tavailableGames = append(availableGames, g.ID)\n\taddGameToUser(g.ID, player)\n\treturn g.ID\n}\n\nfunc marshalGameState(g gameState) string {\n\tout := \"{\"\n\tout = out + `\"ID\": \"` + g.ID + `\",`\n\tout = out + `\"turnPlayer\": ` + strconv.Itoa(int(g.turnPlayer)) + `,`\n\tout = out + `\"player1\": \"` + g.player1 + `\",`\n\tout = out + `\"player2\": \"` + g.player2 + `\",`\n\tout = out + `\"status\": ` + strconv.Itoa(int(g.status)) + `,`\n\tout = out + `\"winner\": ` + strconv.Itoa(int(g.winner)) + `,`\n\tout = out + `\"board\": [`\n\tfor i, v := range g.board {\n\t\tout = out + marshalIntSlice(v[:])\n\t\tif i != (len(v) - 1) {\n\t\t\tout = out + \",\"\n\t\t}\n\t}\n\tout = out + \"]}\"\n\treturn out\n}\n\nfunc marshalIntSlice(s []int8) string {\n\tout := \"[\"\n\tfor i, v := range s {\n\t\tout = out + strconv.Itoa(int(v))\n\t\tif i != (len(s) - 1) {\n\t\t\tout = out + \",\"\n\t\t}\n\t}\n\tout = out + \"]\"\n\treturn out\n}\n\nfunc addGameToUser(gameId string, player std.Address) {\n\tvar games []string\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]string)\n\t}\n\tgames = append([]string{gameId}, games...)\n\tuserGames.Set(string(player), games)\n}\n\nfunc GetGames(address string) string {\n\treturn marshalStringSlice(getGames(address))\n}\n\nfunc getGames(player string) []string {\n\tvar games []string\n\tv, ok := userGames.Get(player)\n\tif ok {\n\t\tgames = v.([]string)\n\t}\n\treturn games\n}\n\nfunc GetAvailableGames(_ string) string {\n\treturn marshalStringSlice(availableGames)\n}\n\nfunc marshalStringSlice(slice []string) string {\n\tout := \"[\"\n\tfor i, v := range slice {\n\t\tout = out + \"\\\"\" + v + \"\\\"\"\n\t\tif i != (len(slice) - 1) {\n\t\t\tout = out + \",\"\n\t\t}\n\t}\n\tout = out + \"]\"\n\treturn out\n}\n\nfunc JoinGame(gameId string) bool {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn joinGame(gameId, caller)\n}\n\nfunc joinGame(gameId string, player std.Address) bool {\n\tgraw, ok := allGames.Get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.player2 != \"\" {\n\t\t\tpanic(\"Game not available\")\n\t\t}\n\t\tg.player2 = string(player)\n\t\tallGames.Set(g.ID, g)\n\t\tremoveFromAvailableGames(g.ID)\n\t\treturn ok\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc indexOf(element string, data []string) int {\n\tfor k, v := range data {\n\t\tif element == v {\n\t\t\treturn k\n\t\t}\n\t}\n\treturn -1 // not found.\n}\n\nfunc removeFromAvailableGames(gameId string) {\n\tindex := indexOf(gameId, availableGames)\n\tif index == -1 {\n\t\tpanic(\"Game was not available\")\n\t}\n\tif index == 0 \u0026\u0026 len(availableGames) == 1 {\n\t\tavailableGames = []string{}\n\t} else {\n\t\tnewAvailableGames := availableGames[:len(availableGames)-1]\n\t\tnewAvailableGames[index] = availableGames[len(availableGames)-1]\n\t\tavailableGames = append([]string{}, newAvailableGames...)\n\t}\n}\n\nfunc MakeMove(gameId string, row, col int8) int8 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn makeMove(gameId, row, col, caller)\n}\n\nfunc makeMove(gameId string, row, col int8, player std.Address) int8 {\n\tgraw, ok := allGames.Get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.status == 1 {\n\t\t\tpanic(\"Game has ended\")\n\t\t}\n\t\tif g.player1 != string(player) \u0026\u0026 g.player2 != string(player) {\n\t\t\tpanic(\"You are not part of this game\")\n\t\t}\n\t\tif (g.turnPlayer == 1 \u0026\u0026 g.player1 != string(player)) || (g.turnPlayer == 2 \u0026\u0026 g.player2 != string(player)) {\n\t\t\tpanic(\"Not your turn\")\n\t\t}\n\t\tif row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n\t\t\tpanic(\"Move position out of bounds\")\n\t\t}\n\t\tif g.board[row][col] != 0 {\n\t\t\tpanic(\"Square not empty\")\n\t\t}\n\n\t\tg.board[row][col] = g.turnPlayer\n\t\twinner := checkForWinner(g)\n\t\tif winner != 0 {\n\t\t\tif winner != 3 {\n\t\t\t\tg.winner = winner\n\t\t\t}\n\t\t\tg.status = 1\n\t\t} else {\n\t\t\tif g.turnPlayer == 1 {\n\t\t\t\tg.turnPlayer = 2\n\t\t\t} else {\n\t\t\t\tg.turnPlayer = 1\n\t\t\t}\n\t\t}\n\t\tallGames.Set(g.ID, g)\n\t\treturn g.status\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc checkForWinner(g *gameState) int8 {\n\tcheckLine := func(startRow int, startColumn int, dr int, dc int) int8 {\n\t\tvar lastSquare int8 = g.board[startRow][startColumn]\n\t\trow, column := startRow+dr, startColumn+dc\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\t\t\tif g.board[row][column] == 0 {\n\t\t\t\t// Empty, can't win\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\t// different from last square in line, can't win\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+dr, column+dc\n\t\t}\n\t\t// if not returned, we have a winner\n\t\treturn lastSquare\n\t}\n\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(0, column, 1, 0); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// no empty square and no winner = draw\n\treturn 3\n}\n\nfunc GetGame(gameId string) string {\n\tgraw, ok := allGames.Get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\treturn marshalGameState(*g)\n\t} else {\n\t\tpanic(\"Game not found\")\n\t}\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn \"Welcome to tictactoe\"\n\t} else {\n\t\tgraw, ok := allGames.Get(path)\n\t\tif ok {\n\t\t\tg := graw.(*gameState)\n\t\t\tout := \"\\n\"\n\t\t\tfor i, row := range g.board {\n\t\t\t\tfor j, square := range row {\n\t\t\t\t\tout = out + \" \"\n\t\t\t\t\tswitch square {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tout = out + \" \"\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tout = out + \"X\"\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tout = out + \"O\"\n\t\t\t\t\t}\n\t\t\t\t\tif j != len(row)-1 {\n\t\t\t\t\t\tout = out + \" |\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif i != len(g.board)-1 {\n\t\t\t\t\tout = out + \"\\n------------\"\n\t\t\t\t}\n\t\t\t\tout = out + \"\\n\"\n\t\t\t}\n\t\t\treturn out\n\t\t} else {\n\t\t\treturn \"Game not found\"\n\t\t}\n\t}\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArAfE5HkNJtzlmkoKB6QYRfBiulNsrcx2K2TzJhmdzRp"},"signature":"Jkr8Lx1DU4sp7hPJuAurkUimoTsR32awgF+mtpwQ/bVHexD8X/vR1Mox6k5vvyuoVuMsuva4Mr7ZE9H3QA2Kaw=="}],"memo":""},"blockNum":"161507"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g18cwpdpsqd8mywj8skpsqsg9tn9hudkkpa6ycpe","package":{"Name":"a","Path":"gno.land/r/t/a","Files":[{"Name":"tictactoe.gno","Body":"package tictactoe\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n\tID         string\n\tboard      [3][3]int8\n\tturnPlayer int8\n\tplayer1    string\n\tplayer2    string\n\twinner     int8\n\tstatus     int8 // 0=open 1=closed\n}\n\nvar (\n\tallGames       avl.Tree\n\tnextGameId     int64\n\tavailableGames []string\n\tuserGames      avl.Tree\n)\n\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\n\nfunc StartGame(_ string) string {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn startGame(caller)\n}\n\nfunc startGame(player std.Address) string {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatInt(nextGameId, 10))\n\tg := \u0026gameState{\n\t\tID:         id,\n\t\tboard:      [3][3]int8{},\n\t\tturnPlayer: 1,\n\t\tplayer1:    string(player),\n\t\tplayer2:    \"\",\n\t\tstatus:     0,\n\t}\n\tallGames.Set(string(g.ID), g)\n\tavailableGames = append(availableGames, g.ID)\n\taddGameToUser(g.ID, player)\n\treturn g.ID\n}\n\nfunc marshalGameState(g gameState) string {\n\tout := \"{\"\n\tout = out + `\"ID\": \"` + g.ID + `\",`\n\tout = out + `\"turnPlayer\": ` + strconv.Itoa(int(g.turnPlayer)) + `,`\n\tout = out + `\"player1\": \"` + g.player1 + `\",`\n\tout = out + `\"player2\": \"` + g.player2 + `\",`\n\tout = out + `\"status\": ` + strconv.Itoa(int(g.status)) + `,`\n\tout = out + `\"winner\": ` + strconv.Itoa(int(g.winner)) + `,`\n\tout = out + `\"board\": [`\n\tfor i, v := range g.board {\n\t\tout = out + marshalIntSlice(v[:])\n\t\tif i != (len(v) - 1) {\n\t\t\tout = out + \",\"\n\t\t}\n\t}\n\tout = out + \"]}\"\n\treturn out\n}\n\nfunc marshalIntSlice(s []int8) string {\n\tout := \"[\"\n\tfor i, v := range s {\n\t\tout = out + strconv.Itoa(int(v))\n\t\tif i != (len(s) - 1) {\n\t\t\tout = out + \",\"\n\t\t}\n\t}\n\tout = out + \"]\"\n\treturn out\n}\n\nfunc addGameToUser(gameId string, player std.Address) {\n\tvar games []string\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]string)\n\t}\n\tgames = append([]string{gameId}, games...)\n\tuserGames.Set(string(player), games)\n}\n\nfunc GetGames(address string) string {\n\treturn marshalStringSlice(getGames(address))\n}\n\nfunc getGames(player string) []string {\n\tvar games []string\n\tv, ok := userGames.Get(player)\n\tif ok {\n\t\tgames = v.([]string)\n\t}\n\treturn games\n}\n\nfunc GetAvailableGames(_ string) string {\n\treturn marshalStringSlice(availableGames)\n}\n\nfunc marshalStringSlice(slice []string) string {\n\tout := \"[\"\n\tfor i, v := range slice {\n\t\tout = out + \"\\\"\" + v + \"\\\"\"\n\t\tif i != (len(slice) - 1) {\n\t\t\tout = out + \",\"\n\t\t}\n\t}\n\tout = out + \"]\"\n\treturn out\n}\n\nfunc JoinGame(gameId string) bool {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn joinGame(gameId, caller)\n}\n\nfunc joinGame(gameId string, player std.Address) bool {\n\tgraw, ok := allGames.Get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.player2 != \"\" {\n\t\t\tpanic(\"Game not available\")\n\t\t}\n\t\tg.player2 = string(player)\n\t\tallGames.Set(g.ID, g)\n\t\tremoveFromAvailableGames(g.ID)\n\t\treturn ok\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc indexOf(element string, data []string) int {\n\tfor k, v := range data {\n\t\tif element == v {\n\t\t\treturn k\n\t\t}\n\t}\n\treturn -1 // not found.\n}\n\nfunc removeFromAvailableGames(gameId string) {\n\tindex := indexOf(gameId, availableGames)\n\tif index == -1 {\n\t\tpanic(\"Game was not available\")\n\t}\n\tif index == 0 \u0026\u0026 len(availableGames) == 1 {\n\t\tavailableGames = []string{}\n\t} else {\n\t\tnewAvailableGames := availableGames[:len(availableGames)-1]\n\t\tnewAvailableGames[index] = availableGames[len(availableGames)-1]\n\t\tavailableGames = append([]string{}, newAvailableGames...)\n\t}\n}\n\nfunc MakeMove(gameId string, row, col int8) int8 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn makeMove(gameId, row, col, caller)\n}\n\nfunc makeMove(gameId string, row, col int8, player std.Address) int8 {\n\tgraw, ok := allGames.Get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.status == 1 {\n\t\t\tpanic(\"Game has ended\")\n\t\t}\n\t\tif g.player1 != string(player) \u0026\u0026 g.player2 != string(player) {\n\t\t\tpanic(\"You are not part of this game\")\n\t\t}\n\t\tif (g.turnPlayer == 1 \u0026\u0026 g.player1 != string(player)) || (g.turnPlayer == 2 \u0026\u0026 g.player2 != string(player)) {\n\t\t\tpanic(\"Not your turn\")\n\t\t}\n\t\tif row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n\t\t\tpanic(\"Move position out of bounds\")\n\t\t}\n\t\tif g.board[row][col] != 0 {\n\t\t\tpanic(\"Square not empty\")\n\t\t}\n\n\t\tg.board[row][col] = g.turnPlayer\n\t\twinner := checkForWinner(g)\n\t\tif winner != 0 {\n\t\t\tif winner != 3 {\n\t\t\t\tg.winner = winner\n\t\t\t}\n\t\t\tg.status = 1\n\t\t} else {\n\t\t\tif g.turnPlayer == 1 {\n\t\t\t\tg.turnPlayer = 2\n\t\t\t} else {\n\t\t\t\tg.turnPlayer = 1\n\t\t\t}\n\t\t}\n\t\tallGames.Set(g.ID, g)\n\t\treturn g.status\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc checkForWinner(g *gameState) int8 {\n\tcheckLine := func(startRow int, startColumn int, dr int, dc int) int8 {\n\t\tvar lastSquare int8 = g.board[startRow][startColumn]\n\t\trow, column := startRow+dr, startColumn+dc\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\t\t\tif g.board[row][column] == 0 {\n\t\t\t\t// Empty, can't win\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\t// different from last square in line, can't win\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+dr, column+dc\n\t\t}\n\t\t// if not returned, we have a winner\n\t\treturn lastSquare\n\t}\n\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(0, column, 1, 0); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// no empty square and no winner = draw\n\treturn 3\n}\n\nfunc GetGame(gameId string) string {\n\tgraw, ok := allGames.Get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\treturn marshalGameState(*g)\n\t} else {\n\t\tpanic(\"Game not found\")\n\t}\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn \"Welcome to tictactoe\"\n\t} else {\n\t\tgraw, ok := allGames.Get(path)\n\t\tif ok {\n\t\t\tg := graw.(*gameState)\n\t\t\tout := \"\\n\"\n\t\t\tfor i, row := range g.board {\n\t\t\t\tfor j, square := range row {\n\t\t\t\t\tout = out + \" \"\n\t\t\t\t\tswitch square {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tout = out + \" \"\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tout = out + \"X\"\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tout = out + \"O\"\n\t\t\t\t\t}\n\t\t\t\t\tif j != len(row)-1 {\n\t\t\t\t\t\tout = out + \" |\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif i != len(g.board)-1 {\n\t\t\t\t\tout = out + \"\\n------------\"\n\t\t\t\t}\n\t\t\t\tout = out + \"\\n\"\n\t\t\t}\n\t\t\treturn out\n\t\t} else {\n\t\t\treturn \"Game not found\"\n\t\t}\n\t}\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArAfE5HkNJtzlmkoKB6QYRfBiulNsrcx2K2TzJhmdzRp"},"signature":"aCWovITnvdJwX4pjitsBqJ/qnI8+Etc6qAd7ypBYMLEPzYz7nbx+tIdwO/qJoBjepaGGSyY+25ox6Ib7jpPMcw=="}],"memo":""},"blockNum":"161509"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g18cwpdpsqd8mywj8skpsqsg9tn9hudkkpa6ycpe","package":{"Name":"a","Path":"gno.land/p/tictactoe/a","Files":[{"Name":"tictactoe.gno","Body":"package tictactoe\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n\tID         string\n\tboard      [3][3]int8\n\tturnPlayer int8\n\tplayer1    string\n\tplayer2    string\n\twinner     int8\n\tstatus     int8 // 0=open 1=closed\n}\n\nvar (\n\tallGames       avl.Tree\n\tnextGameId     int64\n\tavailableGames []string\n\tuserGames      avl.Tree\n)\n\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\n\nfunc StartGame(_ string) string {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn startGame(caller)\n}\n\nfunc startGame(player std.Address) string {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatInt(nextGameId, 10))\n\tg := \u0026gameState{\n\t\tID:         id,\n\t\tboard:      [3][3]int8{},\n\t\tturnPlayer: 1,\n\t\tplayer1:    string(player),\n\t\tplayer2:    \"\",\n\t\tstatus:     0,\n\t}\n\tallGames.Set(string(g.ID), g)\n\tavailableGames = append(availableGames, g.ID)\n\taddGameToUser(g.ID, player)\n\treturn g.ID\n}\n\nfunc marshalGameState(g gameState) string {\n\tout := \"{\"\n\tout = out + `\"ID\": \"` + g.ID + `\",`\n\tout = out + `\"turnPlayer\": ` + strconv.Itoa(int(g.turnPlayer)) + `,`\n\tout = out + `\"player1\": \"` + g.player1 + `\",`\n\tout = out + `\"player2\": \"` + g.player2 + `\",`\n\tout = out + `\"status\": ` + strconv.Itoa(int(g.status)) + `,`\n\tout = out + `\"winner\": ` + strconv.Itoa(int(g.winner)) + `,`\n\tout = out + `\"board\": [`\n\tfor i, v := range g.board {\n\t\tout = out + marshalIntSlice(v[:])\n\t\tif i != (len(v) - 1) {\n\t\t\tout = out + \",\"\n\t\t}\n\t}\n\tout = out + \"]}\"\n\treturn out\n}\n\nfunc marshalIntSlice(s []int8) string {\n\tout := \"[\"\n\tfor i, v := range s {\n\t\tout = out + strconv.Itoa(int(v))\n\t\tif i != (len(s) - 1) {\n\t\t\tout = out + \",\"\n\t\t}\n\t}\n\tout = out + \"]\"\n\treturn out\n}\n\nfunc addGameToUser(gameId string, player std.Address) {\n\tvar games []string\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]string)\n\t}\n\tgames = append([]string{gameId}, games...)\n\tuserGames.Set(string(player), games)\n}\n\nfunc GetGames(address string) string {\n\treturn marshalStringSlice(getGames(address))\n}\n\nfunc getGames(player string) []string {\n\tvar games []string\n\tv, ok := userGames.Get(player)\n\tif ok {\n\t\tgames = v.([]string)\n\t}\n\treturn games\n}\n\nfunc GetAvailableGames(_ string) string {\n\treturn marshalStringSlice(availableGames)\n}\n\nfunc marshalStringSlice(slice []string) string {\n\tout := \"[\"\n\tfor i, v := range slice {\n\t\tout = out + \"\\\"\" + v + \"\\\"\"\n\t\tif i != (len(slice) - 1) {\n\t\t\tout = out + \",\"\n\t\t}\n\t}\n\tout = out + \"]\"\n\treturn out\n}\n\nfunc JoinGame(gameId string) bool {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn joinGame(gameId, caller)\n}\n\nfunc joinGame(gameId string, player std.Address) bool {\n\tgraw, ok := allGames.Get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.player2 != \"\" {\n\t\t\tpanic(\"Game not available\")\n\t\t}\n\t\tg.player2 = string(player)\n\t\tallGames.Set(g.ID, g)\n\t\tremoveFromAvailableGames(g.ID)\n\t\treturn ok\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc indexOf(element string, data []string) int {\n\tfor k, v := range data {\n\t\tif element == v {\n\t\t\treturn k\n\t\t}\n\t}\n\treturn -1 // not found.\n}\n\nfunc removeFromAvailableGames(gameId string) {\n\tindex := indexOf(gameId, availableGames)\n\tif index == -1 {\n\t\tpanic(\"Game was not available\")\n\t}\n\tif index == 0 \u0026\u0026 len(availableGames) == 1 {\n\t\tavailableGames = []string{}\n\t} else {\n\t\tnewAvailableGames := availableGames[:len(availableGames)-1]\n\t\tnewAvailableGames[index] = availableGames[len(availableGames)-1]\n\t\tavailableGames = append([]string{}, newAvailableGames...)\n\t}\n}\n\nfunc MakeMove(gameId string, row, col int8) int8 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn makeMove(gameId, row, col, caller)\n}\n\nfunc makeMove(gameId string, row, col int8, player std.Address) int8 {\n\tgraw, ok := allGames.Get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.status == 1 {\n\t\t\tpanic(\"Game has ended\")\n\t\t}\n\t\tif g.player1 != string(player) \u0026\u0026 g.player2 != string(player) {\n\t\t\tpanic(\"You are not part of this game\")\n\t\t}\n\t\tif (g.turnPlayer == 1 \u0026\u0026 g.player1 != string(player)) || (g.turnPlayer == 2 \u0026\u0026 g.player2 != string(player)) {\n\t\t\tpanic(\"Not your turn\")\n\t\t}\n\t\tif row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n\t\t\tpanic(\"Move position out of bounds\")\n\t\t}\n\t\tif g.board[row][col] != 0 {\n\t\t\tpanic(\"Square not empty\")\n\t\t}\n\n\t\tg.board[row][col] = g.turnPlayer\n\t\twinner := checkForWinner(g)\n\t\tif winner != 0 {\n\t\t\tif winner != 3 {\n\t\t\t\tg.winner = winner\n\t\t\t}\n\t\t\tg.status = 1\n\t\t} else {\n\t\t\tif g.turnPlayer == 1 {\n\t\t\t\tg.turnPlayer = 2\n\t\t\t} else {\n\t\t\t\tg.turnPlayer = 1\n\t\t\t}\n\t\t}\n\t\tallGames.Set(g.ID, g)\n\t\treturn g.status\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc checkForWinner(g *gameState) int8 {\n\tcheckLine := func(startRow int, startColumn int, dr int, dc int) int8 {\n\t\tvar lastSquare int8 = g.board[startRow][startColumn]\n\t\trow, column := startRow+dr, startColumn+dc\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\t\t\tif g.board[row][column] == 0 {\n\t\t\t\t// Empty, can't win\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\t// different from last square in line, can't win\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+dr, column+dc\n\t\t}\n\t\t// if not returned, we have a winner\n\t\treturn lastSquare\n\t}\n\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(0, column, 1, 0); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// no empty square and no winner = draw\n\treturn 3\n}\n\nfunc GetGame(gameId string) string {\n\tgraw, ok := allGames.Get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\treturn marshalGameState(*g)\n\t} else {\n\t\tpanic(\"Game not found\")\n\t}\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn \"Welcome to tictactoe\"\n\t} else {\n\t\tgraw, ok := allGames.Get(path)\n\t\tif ok {\n\t\t\tg := graw.(*gameState)\n\t\t\tout := \"\\n\"\n\t\t\tfor i, row := range g.board {\n\t\t\t\tfor j, square := range row {\n\t\t\t\t\tout = out + \" \"\n\t\t\t\t\tswitch square {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tout = out + \" \"\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tout = out + \"X\"\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tout = out + \"O\"\n\t\t\t\t\t}\n\t\t\t\t\tif j != len(row)-1 {\n\t\t\t\t\t\tout = out + \" |\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif i != len(g.board)-1 {\n\t\t\t\t\tout = out + \"\\n------------\"\n\t\t\t\t}\n\t\t\t\tout = out + \"\\n\"\n\t\t\t}\n\t\t\treturn out\n\t\t} else {\n\t\t\treturn \"Game not found\"\n\t\t}\n\t}\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArAfE5HkNJtzlmkoKB6QYRfBiulNsrcx2K2TzJhmdzRp"},"signature":"6s0nHlqMP3nDGgeN0HVieb3XgaCJOvmAMI3hi0uVqOgNkdo0EPSiIkOhh/X68zLpwo3dgori+9E3Xa4dUW2G3Q=="}],"memo":""},"blockNum":"161511"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g18cwpdpsqd8mywj8skpsqsg9tn9hudkkpa6ycpe","package":{"Name":"tictactoe","Path":"gno.land/p/tictactoe/tictactoe","Files":[{"Name":"tictactoe.gno","Body":"package tictactoe\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n\tID         string\n\tboard      [3][3]int8\n\tturnPlayer int8\n\tplayer1    string\n\tplayer2    string\n\twinner     int8\n\tstatus     int8 // 0=open 1=closed\n}\n\nvar (\n\tallGames       avl.Tree\n\tnextGameId     int64\n\tavailableGames []string\n\tuserGames      avl.Tree\n)\n\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\n\nfunc StartGame(_ string) string {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn startGame(caller)\n}\n\nfunc startGame(player std.Address) string {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatInt(nextGameId, 10))\n\tg := \u0026gameState{\n\t\tID:         id,\n\t\tboard:      [3][3]int8{},\n\t\tturnPlayer: 1,\n\t\tplayer1:    string(player),\n\t\tplayer2:    \"\",\n\t\tstatus:     0,\n\t}\n\tallGames.Set(string(g.ID), g)\n\tavailableGames = append(availableGames, g.ID)\n\taddGameToUser(g.ID, player)\n\treturn g.ID\n}\n\nfunc marshalGameState(g gameState) string {\n\tout := \"{\"\n\tout = out + `\"ID\": \"` + g.ID + `\",`\n\tout = out + `\"turnPlayer\": ` + strconv.Itoa(int(g.turnPlayer)) + `,`\n\tout = out + `\"player1\": \"` + g.player1 + `\",`\n\tout = out + `\"player2\": \"` + g.player2 + `\",`\n\tout = out + `\"status\": ` + strconv.Itoa(int(g.status)) + `,`\n\tout = out + `\"winner\": ` + strconv.Itoa(int(g.winner)) + `,`\n\tout = out + `\"board\": [`\n\tfor i, v := range g.board {\n\t\tout = out + marshalIntSlice(v[:])\n\t\tif i != (len(v) - 1) {\n\t\t\tout = out + \",\"\n\t\t}\n\t}\n\tout = out + \"]}\"\n\treturn out\n}\n\nfunc marshalIntSlice(s []int8) string {\n\tout := \"[\"\n\tfor i, v := range s {\n\t\tout = out + strconv.Itoa(int(v))\n\t\tif i != (len(s) - 1) {\n\t\t\tout = out + \",\"\n\t\t}\n\t}\n\tout = out + \"]\"\n\treturn out\n}\n\nfunc addGameToUser(gameId string, player std.Address) {\n\tvar games []string\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]string)\n\t}\n\tgames = append([]string{gameId}, games...)\n\tuserGames.Set(string(player), games)\n}\n\nfunc GetGames(address string) string {\n\treturn marshalStringSlice(getGames(address))\n}\n\nfunc getGames(player string) []string {\n\tvar games []string\n\tv, ok := userGames.Get(player)\n\tif ok {\n\t\tgames = v.([]string)\n\t}\n\treturn games\n}\n\nfunc GetAvailableGames(_ string) string {\n\treturn marshalStringSlice(availableGames)\n}\n\nfunc marshalStringSlice(slice []string) string {\n\tout := \"[\"\n\tfor i, v := range slice {\n\t\tout = out + \"\\\"\" + v + \"\\\"\"\n\t\tif i != (len(slice) - 1) {\n\t\t\tout = out + \",\"\n\t\t}\n\t}\n\tout = out + \"]\"\n\treturn out\n}\n\nfunc JoinGame(gameId string) bool {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn joinGame(gameId, caller)\n}\n\nfunc joinGame(gameId string, player std.Address) bool {\n\tgraw, ok := allGames.Get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.player2 != \"\" {\n\t\t\tpanic(\"Game not available\")\n\t\t}\n\t\tg.player2 = string(player)\n\t\tallGames.Set(g.ID, g)\n\t\tremoveFromAvailableGames(g.ID)\n\t\treturn ok\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc indexOf(element string, data []string) int {\n\tfor k, v := range data {\n\t\tif element == v {\n\t\t\treturn k\n\t\t}\n\t}\n\treturn -1 // not found.\n}\n\nfunc removeFromAvailableGames(gameId string) {\n\tindex := indexOf(gameId, availableGames)\n\tif index == -1 {\n\t\tpanic(\"Game was not available\")\n\t}\n\tif index == 0 \u0026\u0026 len(availableGames) == 1 {\n\t\tavailableGames = []string{}\n\t} else {\n\t\tnewAvailableGames := availableGames[:len(availableGames)-1]\n\t\tnewAvailableGames[index] = availableGames[len(availableGames)-1]\n\t\tavailableGames = append([]string{}, newAvailableGames...)\n\t}\n}\n\nfunc MakeMove(gameId string, row, col int8) int8 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn makeMove(gameId, row, col, caller)\n}\n\nfunc makeMove(gameId string, row, col int8, player std.Address) int8 {\n\tgraw, ok := allGames.Get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.status == 1 {\n\t\t\tpanic(\"Game has ended\")\n\t\t}\n\t\tif g.player1 != string(player) \u0026\u0026 g.player2 != string(player) {\n\t\t\tpanic(\"You are not part of this game\")\n\t\t}\n\t\tif (g.turnPlayer == 1 \u0026\u0026 g.player1 != string(player)) || (g.turnPlayer == 2 \u0026\u0026 g.player2 != string(player)) {\n\t\t\tpanic(\"Not your turn\")\n\t\t}\n\t\tif row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n\t\t\tpanic(\"Move position out of bounds\")\n\t\t}\n\t\tif g.board[row][col] != 0 {\n\t\t\tpanic(\"Square not empty\")\n\t\t}\n\n\t\tg.board[row][col] = g.turnPlayer\n\t\twinner := checkForWinner(g)\n\t\tif winner != 0 {\n\t\t\tif winner != 3 {\n\t\t\t\tg.winner = winner\n\t\t\t}\n\t\t\tg.status = 1\n\t\t} else {\n\t\t\tif g.turnPlayer == 1 {\n\t\t\t\tg.turnPlayer = 2\n\t\t\t} else {\n\t\t\t\tg.turnPlayer = 1\n\t\t\t}\n\t\t}\n\t\tallGames.Set(g.ID, g)\n\t\treturn g.status\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc checkForWinner(g *gameState) int8 {\n\tcheckLine := func(startRow int, startColumn int, dr int, dc int) int8 {\n\t\tvar lastSquare int8 = g.board[startRow][startColumn]\n\t\trow, column := startRow+dr, startColumn+dc\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\t\t\tif g.board[row][column] == 0 {\n\t\t\t\t// Empty, can't win\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\t// different from last square in line, can't win\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+dr, column+dc\n\t\t}\n\t\t// if not returned, we have a winner\n\t\treturn lastSquare\n\t}\n\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(0, column, 1, 0); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// no empty square and no winner = draw\n\treturn 3\n}\n\nfunc GetGame(gameId string) string {\n\tgraw, ok := allGames.Get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\treturn marshalGameState(*g)\n\t} else {\n\t\tpanic(\"Game not found\")\n\t}\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn \"Welcome to tictactoe\"\n\t} else {\n\t\tgraw, ok := allGames.Get(path)\n\t\tif ok {\n\t\t\tg := graw.(*gameState)\n\t\t\tout := \"\\n\"\n\t\t\tfor i, row := range g.board {\n\t\t\t\tfor j, square := range row {\n\t\t\t\t\tout = out + \" \"\n\t\t\t\t\tswitch square {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tout = out + \" \"\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tout = out + \"X\"\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tout = out + \"O\"\n\t\t\t\t\t}\n\t\t\t\t\tif j != len(row)-1 {\n\t\t\t\t\t\tout = out + \" |\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif i != len(g.board)-1 {\n\t\t\t\t\tout = out + \"\\n------------\"\n\t\t\t\t}\n\t\t\t\tout = out + \"\\n\"\n\t\t\t}\n\t\t\treturn out\n\t\t} else {\n\t\t\treturn \"Game not found\"\n\t\t}\n\t}\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArAfE5HkNJtzlmkoKB6QYRfBiulNsrcx2K2TzJhmdzRp"},"signature":"Z+2+Xmwk/+BcyMTyqHcU4LGNHUNkQp1Nm1df9+qtSTkPbP8A2GFnBIJ/yMoUaj8T03wRzEQCBaYduFo+1UA5/A=="}],"memo":""},"blockNum":"161513"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g18cwpdpsqd8mywj8skpsqsg9tn9hudkkpa6ycpe","package":{"Name":"1","Path":"gno.land/r/jhkjlhjkhlk/1","Files":[{"Name":"tictactoe.gno","Body":"package tictactoe\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n\tID         string\n\tboard      [3][3]int8\n\tturnPlayer int8\n\tplayer1    string\n\tplayer2    string\n\twinner     int8\n\tstatus     int8 // 0=open 1=closed\n}\n\nvar (\n\tallGames       avl.Tree\n\tnextGameId     int64\n\tavailableGames []string\n\tuserGames      avl.Tree\n)\n\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\n\nfunc StartGame(_ string) string {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn startGame(caller)\n}\n\nfunc startGame(player std.Address) string {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatInt(nextGameId, 10))\n\tg := \u0026gameState{\n\t\tID:         id,\n\t\tboard:      [3][3]int8{},\n\t\tturnPlayer: 1,\n\t\tplayer1:    string(player),\n\t\tplayer2:    \"\",\n\t\tstatus:     0,\n\t}\n\tallGames.Set(string(g.ID), g)\n\tavailableGames = append(availableGames, g.ID)\n\taddGameToUser(g.ID, player)\n\treturn g.ID\n}\n\nfunc marshalGameState(g gameState) string {\n\tout := \"{\"\n\tout = out + `\"ID\": \"` + g.ID + `\",`\n\tout = out + `\"turnPlayer\": ` + strconv.Itoa(int(g.turnPlayer)) + `,`\n\tout = out + `\"player1\": \"` + g.player1 + `\",`\n\tout = out + `\"player2\": \"` + g.player2 + `\",`\n\tout = out + `\"status\": ` + strconv.Itoa(int(g.status)) + `,`\n\tout = out + `\"winner\": ` + strconv.Itoa(int(g.winner)) + `,`\n\tout = out + `\"board\": [`\n\tfor i, v := range g.board {\n\t\tout = out + marshalIntSlice(v[:])\n\t\tif i != (len(v) - 1) {\n\t\t\tout = out + \",\"\n\t\t}\n\t}\n\tout = out + \"]}\"\n\treturn out\n}\n\nfunc marshalIntSlice(s []int8) string {\n\tout := \"[\"\n\tfor i, v := range s {\n\t\tout = out + strconv.Itoa(int(v))\n\t\tif i != (len(s) - 1) {\n\t\t\tout = out + \",\"\n\t\t}\n\t}\n\tout = out + \"]\"\n\treturn out\n}\n\nfunc addGameToUser(gameId string, player std.Address) {\n\tvar games []string\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]string)\n\t}\n\tgames = append([]string{gameId}, games...)\n\tuserGames.Set(string(player), games)\n}\n\nfunc GetGames(address string) string {\n\treturn marshalStringSlice(getGames(address))\n}\n\nfunc getGames(player string) []string {\n\tvar games []string\n\tv, ok := userGames.Get(player)\n\tif ok {\n\t\tgames = v.([]string)\n\t}\n\treturn games\n}\n\nfunc GetAvailableGames(_ string) string {\n\treturn marshalStringSlice(availableGames)\n}\n\nfunc marshalStringSlice(slice []string) string {\n\tout := \"[\"\n\tfor i, v := range slice {\n\t\tout = out + \"\\\"\" + v + \"\\\"\"\n\t\tif i != (len(slice) - 1) {\n\t\t\tout = out + \",\"\n\t\t}\n\t}\n\tout = out + \"]\"\n\treturn out\n}\n\nfunc JoinGame(gameId string) bool {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn joinGame(gameId, caller)\n}\n\nfunc joinGame(gameId string, player std.Address) bool {\n\tgraw, ok := allGames.Get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.player2 != \"\" {\n\t\t\tpanic(\"Game not available\")\n\t\t}\n\t\tg.player2 = string(player)\n\t\tallGames.Set(g.ID, g)\n\t\tremoveFromAvailableGames(g.ID)\n\t\treturn ok\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc indexOf(element string, data []string) int {\n\tfor k, v := range data {\n\t\tif element == v {\n\t\t\treturn k\n\t\t}\n\t}\n\treturn -1 // not found.\n}\n\nfunc removeFromAvailableGames(gameId string) {\n\tindex := indexOf(gameId, availableGames)\n\tif index == -1 {\n\t\tpanic(\"Game was not available\")\n\t}\n\tif index == 0 \u0026\u0026 len(availableGames) == 1 {\n\t\tavailableGames = []string{}\n\t} else {\n\t\tnewAvailableGames := availableGames[:len(availableGames)-1]\n\t\tnewAvailableGames[index] = availableGames[len(availableGames)-1]\n\t\tavailableGames = append([]string{}, newAvailableGames...)\n\t}\n}\n\nfunc MakeMove(gameId string, row, col int8) int8 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn makeMove(gameId, row, col, caller)\n}\n\nfunc makeMove(gameId string, row, col int8, player std.Address) int8 {\n\tgraw, ok := allGames.Get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.status == 1 {\n\t\t\tpanic(\"Game has ended\")\n\t\t}\n\t\tif g.player1 != string(player) \u0026\u0026 g.player2 != string(player) {\n\t\t\tpanic(\"You are not part of this game\")\n\t\t}\n\t\tif (g.turnPlayer == 1 \u0026\u0026 g.player1 != string(player)) || (g.turnPlayer == 2 \u0026\u0026 g.player2 != string(player)) {\n\t\t\tpanic(\"Not your turn\")\n\t\t}\n\t\tif row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n\t\t\tpanic(\"Move position out of bounds\")\n\t\t}\n\t\tif g.board[row][col] != 0 {\n\t\t\tpanic(\"Square not empty\")\n\t\t}\n\n\t\tg.board[row][col] = g.turnPlayer\n\t\twinner := checkForWinner(g)\n\t\tif winner != 0 {\n\t\t\tif winner != 3 {\n\t\t\t\tg.winner = winner\n\t\t\t}\n\t\t\tg.status = 1\n\t\t} else {\n\t\t\tif g.turnPlayer == 1 {\n\t\t\t\tg.turnPlayer = 2\n\t\t\t} else {\n\t\t\t\tg.turnPlayer = 1\n\t\t\t}\n\t\t}\n\t\tallGames.Set(g.ID, g)\n\t\treturn g.status\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc checkForWinner(g *gameState) int8 {\n\tcheckLine := func(startRow int, startColumn int, dr int, dc int) int8 {\n\t\tvar lastSquare int8 = g.board[startRow][startColumn]\n\t\trow, column := startRow+dr, startColumn+dc\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\t\t\tif g.board[row][column] == 0 {\n\t\t\t\t// Empty, can't win\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\t// different from last square in line, can't win\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+dr, column+dc\n\t\t}\n\t\t// if not returned, we have a winner\n\t\treturn lastSquare\n\t}\n\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(0, column, 1, 0); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// no empty square and no winner = draw\n\treturn 3\n}\n\nfunc GetGame(gameId string) string {\n\tgraw, ok := allGames.Get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\treturn marshalGameState(*g)\n\t} else {\n\t\tpanic(\"Game not found\")\n\t}\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn \"Welcome to tictactoe\"\n\t} else {\n\t\tgraw, ok := allGames.Get(path)\n\t\tif ok {\n\t\t\tg := graw.(*gameState)\n\t\t\tout := \"\\n\"\n\t\t\tfor i, row := range g.board {\n\t\t\t\tfor j, square := range row {\n\t\t\t\t\tout = out + \" \"\n\t\t\t\t\tswitch square {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tout = out + \" \"\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tout = out + \"X\"\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tout = out + \"O\"\n\t\t\t\t\t}\n\t\t\t\t\tif j != len(row)-1 {\n\t\t\t\t\t\tout = out + \" |\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif i != len(g.board)-1 {\n\t\t\t\t\tout = out + \"\\n------------\"\n\t\t\t\t}\n\t\t\t\tout = out + \"\\n\"\n\t\t\t}\n\t\t\treturn out\n\t\t} else {\n\t\t\treturn \"Game not found\"\n\t\t}\n\t}\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArAfE5HkNJtzlmkoKB6QYRfBiulNsrcx2K2TzJhmdzRp"},"signature":"8Qqgb+r/swWMK8A8IIkd4ge/3LvHOdrZL7isqsoMSIhJ/awdmzrATtqzYqLc0mCKOIlK0W85ip46FGq8bejUzA=="}],"memo":""},"blockNum":"161516"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g18cwpdpsqd8mywj8skpsqsg9tn9hudkkpa6ycpe","package":{"Name":"tictactoe","Path":"gno.land/p/jhkjlhjkhlk/tictactoe","Files":[{"Name":"tictactoe.gno","Body":"package tictactoe\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n\tID         string\n\tboard      [3][3]int8\n\tturnPlayer int8\n\tplayer1    string\n\tplayer2    string\n\twinner     int8\n\tstatus     int8 // 0=open 1=closed\n}\n\nvar (\n\tallGames       avl.Tree\n\tnextGameId     int64\n\tavailableGames []string\n\tuserGames      avl.Tree\n)\n\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\n\nfunc StartGame(_ string) string {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn startGame(caller)\n}\n\nfunc startGame(player std.Address) string {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatInt(nextGameId, 10))\n\tg := \u0026gameState{\n\t\tID:         id,\n\t\tboard:      [3][3]int8{},\n\t\tturnPlayer: 1,\n\t\tplayer1:    string(player),\n\t\tplayer2:    \"\",\n\t\tstatus:     0,\n\t}\n\tallGames.Set(string(g.ID), g)\n\tavailableGames = append(availableGames, g.ID)\n\taddGameToUser(g.ID, player)\n\treturn g.ID\n}\n\nfunc marshalGameState(g gameState) string {\n\tout := \"{\"\n\tout = out + `\"ID\": \"` + g.ID + `\",`\n\tout = out + `\"turnPlayer\": ` + strconv.Itoa(int(g.turnPlayer)) + `,`\n\tout = out + `\"player1\": \"` + g.player1 + `\",`\n\tout = out + `\"player2\": \"` + g.player2 + `\",`\n\tout = out + `\"status\": ` + strconv.Itoa(int(g.status)) + `,`\n\tout = out + `\"winner\": ` + strconv.Itoa(int(g.winner)) + `,`\n\tout = out + `\"board\": [`\n\tfor i, v := range g.board {\n\t\tout = out + marshalIntSlice(v[:])\n\t\tif i != (len(v) - 1) {\n\t\t\tout = out + \",\"\n\t\t}\n\t}\n\tout = out + \"]}\"\n\treturn out\n}\n\nfunc marshalIntSlice(s []int8) string {\n\tout := \"[\"\n\tfor i, v := range s {\n\t\tout = out + strconv.Itoa(int(v))\n\t\tif i != (len(s) - 1) {\n\t\t\tout = out + \",\"\n\t\t}\n\t}\n\tout = out + \"]\"\n\treturn out\n}\n\nfunc addGameToUser(gameId string, player std.Address) {\n\tvar games []string\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]string)\n\t}\n\tgames = append([]string{gameId}, games...)\n\tuserGames.Set(string(player), games)\n}\n\nfunc GetGames(address string) string {\n\treturn marshalStringSlice(getGames(address))\n}\n\nfunc getGames(player string) []string {\n\tvar games []string\n\tv, ok := userGames.Get(player)\n\tif ok {\n\t\tgames = v.([]string)\n\t}\n\treturn games\n}\n\nfunc GetAvailableGames(_ string) string {\n\treturn marshalStringSlice(availableGames)\n}\n\nfunc marshalStringSlice(slice []string) string {\n\tout := \"[\"\n\tfor i, v := range slice {\n\t\tout = out + \"\\\"\" + v + \"\\\"\"\n\t\tif i != (len(slice) - 1) {\n\t\t\tout = out + \",\"\n\t\t}\n\t}\n\tout = out + \"]\"\n\treturn out\n}\n\nfunc JoinGame(gameId string) bool {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn joinGame(gameId, caller)\n}\n\nfunc joinGame(gameId string, player std.Address) bool {\n\tgraw, ok := allGames.Get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.player2 != \"\" {\n\t\t\tpanic(\"Game not available\")\n\t\t}\n\t\tg.player2 = string(player)\n\t\tallGames.Set(g.ID, g)\n\t\tremoveFromAvailableGames(g.ID)\n\t\treturn ok\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc indexOf(element string, data []string) int {\n\tfor k, v := range data {\n\t\tif element == v {\n\t\t\treturn k\n\t\t}\n\t}\n\treturn -1 // not found.\n}\n\nfunc removeFromAvailableGames(gameId string) {\n\tindex := indexOf(gameId, availableGames)\n\tif index == -1 {\n\t\tpanic(\"Game was not available\")\n\t}\n\tif index == 0 \u0026\u0026 len(availableGames) == 1 {\n\t\tavailableGames = []string{}\n\t} else {\n\t\tnewAvailableGames := availableGames[:len(availableGames)-1]\n\t\tnewAvailableGames[index] = availableGames[len(availableGames)-1]\n\t\tavailableGames = append([]string{}, newAvailableGames...)\n\t}\n}\n\nfunc MakeMove(gameId string, row, col int8) int8 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn makeMove(gameId, row, col, caller)\n}\n\nfunc makeMove(gameId string, row, col int8, player std.Address) int8 {\n\tgraw, ok := allGames.Get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.status == 1 {\n\t\t\tpanic(\"Game has ended\")\n\t\t}\n\t\tif g.player1 != string(player) \u0026\u0026 g.player2 != string(player) {\n\t\t\tpanic(\"You are not part of this game\")\n\t\t}\n\t\tif (g.turnPlayer == 1 \u0026\u0026 g.player1 != string(player)) || (g.turnPlayer == 2 \u0026\u0026 g.player2 != string(player)) {\n\t\t\tpanic(\"Not your turn\")\n\t\t}\n\t\tif row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n\t\t\tpanic(\"Move position out of bounds\")\n\t\t}\n\t\tif g.board[row][col] != 0 {\n\t\t\tpanic(\"Square not empty\")\n\t\t}\n\n\t\tg.board[row][col] = g.turnPlayer\n\t\twinner := checkForWinner(g)\n\t\tif winner != 0 {\n\t\t\tif winner != 3 {\n\t\t\t\tg.winner = winner\n\t\t\t}\n\t\t\tg.status = 1\n\t\t} else {\n\t\t\tif g.turnPlayer == 1 {\n\t\t\t\tg.turnPlayer = 2\n\t\t\t} else {\n\t\t\t\tg.turnPlayer = 1\n\t\t\t}\n\t\t}\n\t\tallGames.Set(g.ID, g)\n\t\treturn g.status\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc checkForWinner(g *gameState) int8 {\n\tcheckLine := func(startRow int, startColumn int, dr int, dc int) int8 {\n\t\tvar lastSquare int8 = g.board[startRow][startColumn]\n\t\trow, column := startRow+dr, startColumn+dc\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\t\t\tif g.board[row][column] == 0 {\n\t\t\t\t// Empty, can't win\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\t// different from last square in line, can't win\n\t\t\t\treturn 0\n\t\t\t}\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+dr, column+dc\n\t\t}\n\t\t// if not returned, we have a winner\n\t\treturn lastSquare\n\t}\n\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(0, column, 1, 0); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// no empty square and no winner = draw\n\treturn 3\n}\n\nfunc GetGame(gameId string) string {\n\tgraw, ok := allGames.Get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\treturn marshalGameState(*g)\n\t} else {\n\t\tpanic(\"Game not found\")\n\t}\n}\n\nfunc Render(path string) string {\n\tif path == \"\" {\n\t\treturn \"Welcome to tictactoe\"\n\t} else {\n\t\tgraw, ok := allGames.Get(path)\n\t\tif ok {\n\t\t\tg := graw.(*gameState)\n\t\t\tout := \"\\n\"\n\t\t\tfor i, row := range g.board {\n\t\t\t\tfor j, square := range row {\n\t\t\t\t\tout = out + \" \"\n\t\t\t\t\tswitch square {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tout = out + \" \"\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tout = out + \"X\"\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tout = out + \"O\"\n\t\t\t\t\t}\n\t\t\t\t\tif j != len(row)-1 {\n\t\t\t\t\t\tout = out + \" |\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif i != len(g.board)-1 {\n\t\t\t\t\tout = out + \"\\n------------\"\n\t\t\t\t}\n\t\t\t\tout = out + \"\\n\"\n\t\t\t}\n\t\t\treturn out\n\t\t} else {\n\t\t\treturn \"Game not found\"\n\t\t}\n\t}\n}"}]},"deposit":""}],"fee":{"gas_wanted":"10000000","gas_fee":"50000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArAfE5HkNJtzlmkoKB6QYRfBiulNsrcx2K2TzJhmdzRp"},"signature":"3pLMAT0Uhqt0heHuxtAikS1wvUs0fO3yCVN4E6hgh6op/CWWs/hUh1cwtRdfktm9UxkEYT6w0x+xyx+KBXMa3g=="}],"memo":""},"blockNum":"161518"}
