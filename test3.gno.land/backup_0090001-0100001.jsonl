{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","package":{"Name":"hello","Path":"gno.land/r/test7/hello","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello Mars!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArpuZWPhPhGbXRDOr5vjwl7Ro++55QZaJ7/jUUbkpMHK"},"signature":"ajGGqkEU+0p2gMzgQkJ1L9uO9JCYSNzlG/9kLIXhvCcoXufHMzD+C0O9F6o6mwIguhC/5cG4Hm9uilsRednO9A=="}],"memo":""},"blockNum":"90264"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","to_address":"g1p6t66hp027gq6pt7x7vqz9aaqxpxat8y3aa9et","amount":"99000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArpuZWPhPhGbXRDOr5vjwl7Ro++55QZaJ7/jUUbkpMHK"},"signature":"tXrQU4Z7YP+vglhJoC0z3doRNHuftWIgAJwmGxDl88JZK5MHhvm+UuAHXLKBbiOi1vdAIZr0EXtY6Ph5QfAPbA=="}],"memo":""},"blockNum":"90449"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p6t66hp027gq6pt7x7vqz9aaqxpxat8y3aa9et","package":{"Name":"tictactoe","Path":"gno.land/r/tests/tictactoe","Files":[{"Name":"package.gno","Body":"package tictactoe\n\nimport (\n  std\n  \"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n  ID  int64\n\tboard      [3][3]int8\n\tturnPlayer int8\n  player0 string\n  player1 string\n  winner int8\n  status int8 // 0=open 1=closed\n}\n\nconst (\n\tnone   = iota\n\tcross  = iota\n\tcircle = iota\n)\n\nvar (\n\t// (not \"games\" because that's too useful a variable name)\n\tallGames     avl.Tree // string (game ID) -\u003e *Game\n\tnextGameId int64 = 0\n  availableGames []int64\n\t// Value must be sorted by game ID, descending\n\tuserGames avl.Tree // std.Address -\u003e []*Game\n)\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\nfunc StartGame() {\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return startGame(caller)\n}\nfunc startGame(player std.Address) int64 {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatUint(nextGameId, 10))\n\tg := \u0026gameState{\n    ID: nextGameId, \n  \tboard:     [3][3]int8{},\n  \tturnPlayer: 1,\n    player1: player,\n    player2: \"\",\n    status:0,\n  }\n\tallGames.Set(g.ID, g)\n  availableGames=append(availableGames, g.ID)\n  addGameToUser(g.ID, player)\n  return g.ID\n}\n\nfunc addGameToUser(gameId int64, player std.Address) {\n\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\t// game must be at top, because it is the latest ID\n\tgames = append([]int64{gameId}, games...)\n\tuserGames.Set(string(addr), games)\n}\nfunc GetGames() []int64{\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return getGames(caller)\n}\nfunc getGames(player std.Address) []int64{\n\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n  return games\n}\nfunc GetAvailableGames() {\n  return availableGames\n}\nfunc JoinGame(gameId int64) {\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return joinGame(gameId, caller)\n}\nfunc joinGame(gameId int64, player std.Address) bool {\n  graw, ok := allGames.get(gameId)\n  if (ok) {\n\t  g := graw.(*gameState)\n    if(g.player2!=\"\") {\n      panic(\"Game not available\")\n    }\n    g.player2 = string(player)\n    allGames.Set(g.ID, g)\n    removeFromAvailableGames(g.ID)\n    return ok\n  }\n  panic(\"Game not found\")\n}\nfunc indexOf(element int64, data []int64) (int) {\n   for k, v := range data {\n       if element == v {\n           return k\n       }\n   }\n   return -1    //not found.\n}\nfunc removeFromAvailableGames(gameId int64) {\n  index:=indexOf(gameId, availableGames)\n  if (index==-1) {\n    panic(\"Game was not available\")\n  }\n  if (index==0 \u0026\u0026 len(availableGames)==1) {\n    availableGames = []int64{}\n  }else{\n    newAvailableGames:=availableGames[:len(availableGames)-1]\n    newAvailableGames[index]=availableGames[len(availableGames)-1]\n    availableGames=append([]int64{},newAvailableGames...)\n  }\n}\nfunc MakeMove(gameId int64, row, col int8) int8{\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return makeMove(gameId, caller)\n}\nfunc makeMove(gameId int64, row, col int8, player std.Address) int8 {\n  graw, ok := allGames.get(gameId)\n  if (ok) {\n\t  g := graw.(*gameState)\n    if (g.status==1) {\n      panic(\"Game has ended\")\n    }\n    if(g.player1!=string(player) \u0026\u0026 g.player2!=string(player)) {\n      panic(\"You are not part of this game\")\n    }\n    if(g.turnPlayer==1 \u0026\u0026 g.player1!=string(player)) || (g.turnPlayer==2 \u0026\u0026 g.player2!=string(player)) {\n      panic(\"Not your turn\")\n    }\n    if row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n      panic(\"Move position out of bounds\")\n    }\n    if g.board[row][col] != 0 {\n      panic(\"Square not empty\")\n    }\n\n  \tg.board[row][col] = g.turnPlayer\n    winner:=checkForWinner(g)\n    if (winner!=0) {\n      if (winner!=3) {\n        g.winner = winner\n      }\n      g.status = 1\n    }else{\n      if g.turnPlayer==1 {\n        g.turnPlayer=2\n      }else{\n        g.turnPlayer=1\n      }\n    }\n    allGames.Set(g.ID, g)\n    return g.status\n  }\n  panic(\"Game not found\")\n}\n\nfunc checkForWinner(g gameState) int8 {\n\n\t// define a lambda function for checking one line\n\tcheckLine := func(startRow int, startColumn int, deltaRow int, deltaColumn int) gameResult {\n\t\tvar lastSquare squareState = g.board[startRow][startColumn]\n\t\trow, column := startRow+deltaRow, startColumn+deltaColumn\n\n\t\t// loop starts from the second square(startRow + deltaRow, startColumn + deltaColumn)\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\n\t\t\t// there can't be a winner if a empty square is present within the line\n\t\t\tif g.board[row][column] == none {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+deltaRow, column+deltaColumn\n\t\t}\n\n\t\t// someone has won the game\n\t\tif lastSquare == 1 {\n\t\t\treturn 1\n\t\t} else if lastSquare == 2 {\n\t\t\treturn 2\n\t\t}\n\n\t\treturn 0\n\t}\n\n\t// check horizontal rows\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check vertical columns\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(column, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check top-left to bottom-right diagonal\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\t// check top-right to bottom-left diagonal\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\t// check for draw\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == none {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// if no one wins yet, but none of the squares are empty\n\treturn 3\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3OCHplHTcHHgHBsvN0BB6tGZvEvEDGSj6W3RXNYgUFI"},"signature":"gP/he1m2c6nVjXED7xkpR2aDsdNyJ2iibv58Vx/qtR1SfHbq6MYkKzyovUqMABVOi9FWIrgsrW9gUm2h6UD2Dw=="}],"memo":""},"blockNum":"90452"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p6t66hp027gq6pt7x7vqz9aaqxpxat8y3aa9et","package":{"Name":"tictactoe1","Path":"gno.land/r/clockwork/tictactoe1","Files":[{"Name":"package.gno","Body":"package tictactoe\n\nimport (\n  std\n  \"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n  ID  int64\n\tboard      [3][3]int8\n\tturnPlayer int8\n  player0 string\n  player1 string\n  winner int8\n  status int8 // 0=open 1=closed\n}\n\nconst (\n\tnone   = iota\n\tcross  = iota\n\tcircle = iota\n)\n\nvar (\n\t// (not \"games\" because that's too useful a variable name)\n\tallGames     avl.Tree // string (game ID) -\u003e *Game\n\tnextGameId int64 = 0\n  availableGames []int64\n\t// Value must be sorted by game ID, descending\n\tuserGames avl.Tree // std.Address -\u003e []*Game\n)\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\nfunc StartGame() {\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return startGame(caller)\n}\nfunc startGame(player std.Address) int64 {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatUint(nextGameId, 10))\n\tg := \u0026gameState{\n    ID: nextGameId, \n  \tboard:     [3][3]int8{},\n  \tturnPlayer: 1,\n    player1: player,\n    player2: \"\",\n    status:0,\n  }\n\tallGames.Set(g.ID, g)\n  availableGames=append(availableGames, g.ID)\n  addGameToUser(g.ID, player)\n  return g.ID\n}\n\nfunc addGameToUser(gameId int64, player std.Address) {\n\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\t// game must be at top, because it is the latest ID\n\tgames = append([]int64{gameId}, games...)\n\tuserGames.Set(string(addr), games)\n}\nfunc GetGames() []int64{\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return getGames(caller)\n}\nfunc getGames(player std.Address) []int64{\n\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n  return games\n}\nfunc GetAvailableGames() {\n  return availableGames\n}\nfunc JoinGame(gameId int64) {\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return joinGame(gameId, caller)\n}\nfunc joinGame(gameId int64, player std.Address) bool {\n  graw, ok := allGames.get(gameId)\n  if (ok) {\n\t  g := graw.(*gameState)\n    if(g.player2!=\"\") {\n      panic(\"Game not available\")\n    }\n    g.player2 = string(player)\n    allGames.Set(g.ID, g)\n    removeFromAvailableGames(g.ID)\n    return ok\n  }\n  panic(\"Game not found\")\n}\nfunc indexOf(element int64, data []int64) (int) {\n   for k, v := range data {\n       if element == v {\n           return k\n       }\n   }\n   return -1    //not found.\n}\nfunc removeFromAvailableGames(gameId int64) {\n  index:=indexOf(gameId, availableGames)\n  if (index==-1) {\n    panic(\"Game was not available\")\n  }\n  if (index==0 \u0026\u0026 len(availableGames)==1) {\n    availableGames = []int64{}\n  }else{\n    newAvailableGames:=availableGames[:len(availableGames)-1]\n    newAvailableGames[index]=availableGames[len(availableGames)-1]\n    availableGames=append([]int64{},newAvailableGames...)\n  }\n}\nfunc MakeMove(gameId int64, row, col int8) int8{\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return makeMove(gameId, caller)\n}\nfunc makeMove(gameId int64, row, col int8, player std.Address) int8 {\n  graw, ok := allGames.get(gameId)\n  if (ok) {\n\t  g := graw.(*gameState)\n    if (g.status==1) {\n      panic(\"Game has ended\")\n    }\n    if(g.player1!=string(player) \u0026\u0026 g.player2!=string(player)) {\n      panic(\"You are not part of this game\")\n    }\n    if(g.turnPlayer==1 \u0026\u0026 g.player1!=string(player)) || (g.turnPlayer==2 \u0026\u0026 g.player2!=string(player)) {\n      panic(\"Not your turn\")\n    }\n    if row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n      panic(\"Move position out of bounds\")\n    }\n    if g.board[row][col] != 0 {\n      panic(\"Square not empty\")\n    }\n\n  \tg.board[row][col] = g.turnPlayer\n    winner:=checkForWinner(g)\n    if (winner!=0) {\n      if (winner!=3) {\n        g.winner = winner\n      }\n      g.status = 1\n    }else{\n      if g.turnPlayer==1 {\n        g.turnPlayer=2\n      }else{\n        g.turnPlayer=1\n      }\n    }\n    allGames.Set(g.ID, g)\n    return g.status\n  }\n  panic(\"Game not found\")\n}\n\nfunc checkForWinner(g gameState) int8 {\n\n\t// define a lambda function for checking one line\n\tcheckLine := func(startRow int, startColumn int, deltaRow int, deltaColumn int) gameResult {\n\t\tvar lastSquare squareState = g.board[startRow][startColumn]\n\t\trow, column := startRow+deltaRow, startColumn+deltaColumn\n\n\t\t// loop starts from the second square(startRow + deltaRow, startColumn + deltaColumn)\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\n\t\t\t// there can't be a winner if a empty square is present within the line\n\t\t\tif g.board[row][column] == none {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+deltaRow, column+deltaColumn\n\t\t}\n\n\t\t// someone has won the game\n\t\tif lastSquare == 1 {\n\t\t\treturn 1\n\t\t} else if lastSquare == 2 {\n\t\t\treturn 2\n\t\t}\n\n\t\treturn 0\n\t}\n\n\t// check horizontal rows\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check vertical columns\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(column, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check top-left to bottom-right diagonal\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\t// check top-right to bottom-left diagonal\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\t// check for draw\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == none {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// if no one wins yet, but none of the squares are empty\n\treturn 3\n}\nfunc Render(path string) string {\n  return \"Welcome to tictactoe\"\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3OCHplHTcHHgHBsvN0BB6tGZvEvEDGSj6W3RXNYgUFI"},"signature":"J8WyKJhi8GV4enfu/JCew8FDv9YfPxMwXUiu/Eq7Ys1QUppv/PdvY+fwei9ucR2X7UVwsoUY/HBnZ/Nrjfn/Fw=="}],"memo":""},"blockNum":"90456"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p6t66hp027gq6pt7x7vqz9aaqxpxat8y3aa9et","package":{"Name":"tictactoe","Path":"gno.land/r/clockwork/tictactoe","Files":[{"Name":"tictactoe.gno","Body":"package tictactoe\n\nimport (\n  std\n  \"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n  ID  int64\n\tboard      [3][3]int8\n\tturnPlayer int8\n  player0 string\n  player1 string\n  winner int8\n  status int8 // 0=open 1=closed\n}\n\nvar (\n\t// (not \"games\" because that's too useful a variable name)\n\tallGames     avl.Tree // string (game ID) -\u003e *Game\n\tnextGameId int64 = 0\n  availableGames []int64\n\t// Value must be sorted by game ID, descending\n\tuserGames avl.Tree // std.Address -\u003e []*Game\n)\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\nfunc StartGame() {\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return startGame(caller)\n}\nfunc startGame(player std.Address) int64 {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatUint(nextGameId, 10))\n\tg := \u0026gameState{\n    ID: nextGameId, \n  \tboard:     [3][3]int8{},\n  \tturnPlayer: 1,\n    player1: player,\n    player2: \"\",\n    status:0,\n  }\n\tallGames.Set(g.ID, g)\n  availableGames=append(availableGames, g.ID)\n  addGameToUser(g.ID, player)\n  return g.ID\n}\n\nfunc addGameToUser(gameId int64, player std.Address) {\n\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\t// game must be at top, because it is the latest ID\n\tgames = append([]int64{gameId}, games...)\n\tuserGames.Set(string(addr), games)\n}\nfunc GetGames() []int64{\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return getGames(caller)\n}\nfunc getGames(player std.Address) []int64{\n\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n  return games\n}\nfunc GetAvailableGames() {\n  return availableGames\n}\nfunc JoinGame(gameId int64) {\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return joinGame(gameId, caller)\n}\nfunc joinGame(gameId int64, player std.Address) bool {\n  graw, ok := allGames.get(gameId)\n  if (ok) {\n\t  g := graw.(*gameState)\n    if(g.player2!=\"\") {\n      panic(\"Game not available\")\n    }\n    g.player2 = string(player)\n    allGames.Set(g.ID, g)\n    removeFromAvailableGames(g.ID)\n    return ok\n  }\n  panic(\"Game not found\")\n}\nfunc indexOf(element int64, data []int64) (int) {\n   for k, v := range data {\n       if element == v {\n           return k\n       }\n   }\n   return -1    //not found.\n}\nfunc removeFromAvailableGames(gameId int64) {\n  index:=indexOf(gameId, availableGames)\n  if (index==-1) {\n    panic(\"Game was not available\")\n  }\n  if (index==0 \u0026\u0026 len(availableGames)==1) {\n    availableGames = []int64{}\n  }else{\n    newAvailableGames:=availableGames[:len(availableGames)-1]\n    newAvailableGames[index]=availableGames[len(availableGames)-1]\n    availableGames=append([]int64{},newAvailableGames...)\n  }\n}\nfunc MakeMove(gameId int64, row, col int8) int8{\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return makeMove(gameId, caller)\n}\nfunc makeMove(gameId int64, row, col int8, player std.Address) int8 {\n  graw, ok := allGames.get(gameId)\n  if (ok) {\n\t  g := graw.(*gameState)\n    if (g.status==1) {\n      panic(\"Game has ended\")\n    }\n    if(g.player1!=string(player) \u0026\u0026 g.player2!=string(player)) {\n      panic(\"You are not part of this game\")\n    }\n    if(g.turnPlayer==1 \u0026\u0026 g.player1!=string(player)) || (g.turnPlayer==2 \u0026\u0026 g.player2!=string(player)) {\n      panic(\"Not your turn\")\n    }\n    if row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n      panic(\"Move position out of bounds\")\n    }\n    if g.board[row][col] != 0 {\n      panic(\"Square not empty\")\n    }\n\n  \tg.board[row][col] = g.turnPlayer\n    winner:=checkForWinner(g)\n    if (winner!=0) {\n      if (winner!=3) {\n        g.winner = winner\n      }\n      g.status = 1\n    }else{\n      if g.turnPlayer==1 {\n        g.turnPlayer=2\n      }else{\n        g.turnPlayer=1\n      }\n    }\n    allGames.Set(g.ID, g)\n    return g.status\n  }\n  panic(\"Game not found\")\n}\n\nfunc checkForWinner(g gameState) int8 {\n\n\t// define a lambda function for checking one line\n\tcheckLine := func(startRow int, startColumn int, deltaRow int, deltaColumn int) gameResult {\n\t\tvar lastSquare squareState = g.board[startRow][startColumn]\n\t\trow, column := startRow+deltaRow, startColumn+deltaColumn\n\n\t\t// loop starts from the second square(startRow + deltaRow, startColumn + deltaColumn)\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\n\t\t\t// there can't be a winner if a empty square is present within the line\n\t\t\tif g.board[row][column] == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+deltaRow, column+deltaColumn\n\t\t}\n\n\t\t// someone has won the game\n\t\tif lastSquare == 1 {\n\t\t\treturn 1\n\t\t} else if lastSquare == 2 {\n\t\t\treturn 2\n\t\t}\n\n\t\treturn 0\n\t}\n\n\t// check horizontal rows\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check vertical columns\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(column, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check top-left to bottom-right diagonal\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\t// check top-right to bottom-left diagonal\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\t// check for draw\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// if no one wins yet, but none of the squares are empty\n\treturn 3\n}\nfunc Render(path string) string {\n  return \"Welcome to tictactoe\"\n}"},{"Name":"gno.mod","Body":"module gno.land/r/clockwork/tictactoe\n\nrequire (\n\t\"gno.land/p/demo/avl\" v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3OCHplHTcHHgHBsvN0BB6tGZvEvEDGSj6W3RXNYgUFI"},"signature":"cmIYM0z3eoE4VDSROnRyRkPVM3oVefbtpxctsM1eaG9rjZSGX09MA/cq+vF6jNXxqwFuCxEzHvY9NJzgSJwh2Q=="}],"memo":""},"blockNum":"90467"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1p6t66hp027gq6pt7x7vqz9aaqxpxat8y3aa9et","to_address":"g1zgggsu07z6mq277mnt6hlrnc0yhc7404t3ww0f","amount":"50000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3OCHplHTcHHgHBsvN0BB6tGZvEvEDGSj6W3RXNYgUFI"},"signature":"IMikqPtTnUuqVTf6PobMprUT6AF+pHiLTo6+3Os+JHUvWkk8egfmWk+i9NZWwJJwbKx+xBnUJNiBGzXdaF+OGQ=="}],"memo":""},"blockNum":"90473"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p6t66hp027gq6pt7x7vqz9aaqxpxat8y3aa9et","package":{"Name":"tictactoe","Path":"gno.land/r/clockwork/tictactoe","Files":[{"Name":"tictactoe.gno","Body":"package tictactoe\n\nimport (\n  \"std\"\n  \"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n  ID  int64\n\tboard      [3][3]int8\n\tturnPlayer int8\n  player0 string\n  player1 string\n  winner int8\n  status int8 // 0=open 1=closed\n}\n\nvar (\n\t// (not \"games\" because that's too useful a variable name)\n\tallGames     avl.Tree // string (game ID) -\u003e *Game\n\tnextGameId int64 = 0\n  availableGames []int64\n\t// Value must be sorted by game ID, descending\n\tuserGames avl.Tree // std.Address -\u003e []*Game\n)\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\nfunc StartGame() {\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return startGame(caller)\n}\nfunc startGame(player std.Address) int64 {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatUint(nextGameId, 10))\n\tg := \u0026gameState{\n    ID: nextGameId, \n  \tboard:     [3][3]int8{},\n  \tturnPlayer: 1,\n    player1: player,\n    player2: \"\",\n    status:0,\n  }\n\tallGames.Set(g.ID, g)\n  availableGames=append(availableGames, g.ID)\n  addGameToUser(g.ID, player)\n  return g.ID\n}\n\nfunc addGameToUser(gameId int64, player std.Address) {\n\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\t// game must be at top, because it is the latest ID\n\tgames = append([]int64{gameId}, games...)\n\tuserGames.Set(string(addr), games)\n}\nfunc GetGames() []int64{\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return getGames(caller)\n}\nfunc getGames(player std.Address) []int64{\n\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n  return games\n}\nfunc GetAvailableGames() {\n  return availableGames\n}\nfunc JoinGame(gameId int64) {\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return joinGame(gameId, caller)\n}\nfunc joinGame(gameId int64, player std.Address) bool {\n  graw, ok := allGames.get(gameId)\n  if (ok) {\n\t  g := graw.(*gameState)\n    if(g.player2!=\"\") {\n      panic(\"Game not available\")\n    }\n    g.player2 = string(player)\n    allGames.Set(g.ID, g)\n    removeFromAvailableGames(g.ID)\n    return ok\n  }\n  panic(\"Game not found\")\n}\nfunc indexOf(element int64, data []int64) (int) {\n   for k, v := range data {\n       if element == v {\n           return k\n       }\n   }\n   return -1    //not found.\n}\nfunc removeFromAvailableGames(gameId int64) {\n  index:=indexOf(gameId, availableGames)\n  if (index==-1) {\n    panic(\"Game was not available\")\n  }\n  if (index==0 \u0026\u0026 len(availableGames)==1) {\n    availableGames = []int64{}\n  }else{\n    newAvailableGames:=availableGames[:len(availableGames)-1]\n    newAvailableGames[index]=availableGames[len(availableGames)-1]\n    availableGames=append([]int64{},newAvailableGames...)\n  }\n}\nfunc MakeMove(gameId int64, row, col int8) int8{\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return makeMove(gameId, caller)\n}\nfunc makeMove(gameId int64, row, col int8, player std.Address) int8 {\n  graw, ok := allGames.get(gameId)\n  if (ok) {\n\t  g := graw.(*gameState)\n    if (g.status==1) {\n      panic(\"Game has ended\")\n    }\n    if(g.player1!=string(player) \u0026\u0026 g.player2!=string(player)) {\n      panic(\"You are not part of this game\")\n    }\n    if(g.turnPlayer==1 \u0026\u0026 g.player1!=string(player)) || (g.turnPlayer==2 \u0026\u0026 g.player2!=string(player)) {\n      panic(\"Not your turn\")\n    }\n    if row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n      panic(\"Move position out of bounds\")\n    }\n    if g.board[row][col] != 0 {\n      panic(\"Square not empty\")\n    }\n\n  \tg.board[row][col] = g.turnPlayer\n    winner:=checkForWinner(g)\n    if (winner!=0) {\n      if (winner!=3) {\n        g.winner = winner\n      }\n      g.status = 1\n    }else{\n      if g.turnPlayer==1 {\n        g.turnPlayer=2\n      }else{\n        g.turnPlayer=1\n      }\n    }\n    allGames.Set(g.ID, g)\n    return g.status\n  }\n  panic(\"Game not found\")\n}\n\nfunc checkForWinner(g gameState) int8 {\n\n\t// define a lambda function for checking one line\n\tcheckLine := func(startRow int, startColumn int, deltaRow int, deltaColumn int) gameResult {\n\t\tvar lastSquare squareState = g.board[startRow][startColumn]\n\t\trow, column := startRow+deltaRow, startColumn+deltaColumn\n\n\t\t// loop starts from the second square(startRow + deltaRow, startColumn + deltaColumn)\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\n\t\t\t// there can't be a winner if a empty square is present within the line\n\t\t\tif g.board[row][column] == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+deltaRow, column+deltaColumn\n\t\t}\n\n\t\t// someone has won the game\n\t\tif lastSquare == 1 {\n\t\t\treturn 1\n\t\t} else if lastSquare == 2 {\n\t\t\treturn 2\n\t\t}\n\n\t\treturn 0\n\t}\n\n\t// check horizontal rows\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check vertical columns\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(column, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check top-left to bottom-right diagonal\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\t// check top-right to bottom-left diagonal\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\t// check for draw\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// if no one wins yet, but none of the squares are empty\n\treturn 3\n}\nfunc Render(path string) string {\n  return \"Welcome to tictactoe\"\n}"},{"Name":"gno.mod","Body":"module gno.land/r/clockwork/tictactoe\n\nrequire (\n\t\"gno.land/p/demo/avl\" v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3OCHplHTcHHgHBsvN0BB6tGZvEvEDGSj6W3RXNYgUFI"},"signature":"VsvqX/OfEvDIqi6ACnHF7k+XFSpqhcZFJHD2dr/pxJtbowH0QE8XrWMcfQoGRXLXMxIGrL9f8lHyumUQGoZ3Sg=="}],"memo":""},"blockNum":"90478"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1zgggsu07z6mq277mnt6hlrnc0yhc7404t3ww0f","package":{"Name":"tictactoe","Path":"gno.land/r/clockwork/tictactoe","Files":[{"Name":"gno.mod","Body":"module gno.land/r/clockwork/tictactoe\n\nrequire (\n\t\"gno.land/p/demo/avl\" v0.0.0-latest\n)\n"},{"Name":"tictactoe.gno","Body":"package tictactoe\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n\tID         int64\n\tboard      [3][3]int8\n\tturnPlayer int8\n\tplayer0    string\n\tplayer1    string\n\twinner     int8\n\tstatus     int8 // 0=open 1=closed\n}\n\nvar (\n\t// (not \"games\" because that's too useful a variable name)\n\tallGames       avl.Tree // string (game ID) -\u003e *Game\n\tnextGameId     int64    = 0\n\tavailableGames []int64\n\t// Value must be sorted by game ID, descending\n\tuserGames avl.Tree // std.Address -\u003e []*Game\n)\n\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\n\nfunc StartGame() {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn startGame(caller)\n}\n\nfunc startGame(player std.Address) int64 {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatUint(nextGameId, 10))\n\tg := \u0026gameState{\n\t\tID:         nextGameId,\n\t\tboard:      [3][3]int8{},\n\t\tturnPlayer: 1,\n\t\tplayer1:    player,\n\t\tplayer2:    \"\",\n\t\tstatus:     0,\n\t}\n\tallGames.Set(g.ID, g)\n\tavailableGames = append(availableGames, g.ID)\n\taddGameToUser(g.ID, player)\n\treturn g.ID\n}\n\nfunc addGameToUser(gameId int64, player std.Address) {\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\t// game must be at top, because it is the latest ID\n\tgames = append([]int64{gameId}, games...)\n\tuserGames.Set(string(addr), games)\n}\n\nfunc GetGames() []int64 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn getGames(caller)\n}\n\nfunc getGames(player std.Address) []int64 {\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\treturn games\n}\n\nfunc GetAvailableGames() {\n\treturn availableGames\n}\n\nfunc JoinGame(gameId int64) {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn joinGame(gameId, caller)\n}\n\nfunc joinGame(gameId int64, player std.Address) bool {\n\tgraw, ok := allGames.get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.player2 != \"\" {\n\t\t\tpanic(\"Game not available\")\n\t\t}\n\t\tg.player2 = string(player)\n\t\tallGames.Set(g.ID, g)\n\t\tremoveFromAvailableGames(g.ID)\n\t\treturn ok\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc indexOf(element int64, data []int64) int {\n\tfor k, v := range data {\n\t\tif element == v {\n\t\t\treturn k\n\t\t}\n\t}\n\treturn -1 // not found.\n}\n\nfunc removeFromAvailableGames(gameId int64) {\n\tindex := indexOf(gameId, availableGames)\n\tif index == -1 {\n\t\tpanic(\"Game was not available\")\n\t}\n\tif index == 0 \u0026\u0026 len(availableGames) == 1 {\n\t\tavailableGames = []int64{}\n\t} else {\n\t\tnewAvailableGames := availableGames[:len(availableGames)-1]\n\t\tnewAvailableGames[index] = availableGames[len(availableGames)-1]\n\t\tavailableGames = append([]int64{}, newAvailableGames...)\n\t}\n}\n\nfunc MakeMove(gameId int64, row, col int8) int8 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn makeMove(gameId, caller)\n}\n\nfunc makeMove(gameId int64, row, col int8, player std.Address) int8 {\n\tgraw, ok := allGames.get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.status == 1 {\n\t\t\tpanic(\"Game has ended\")\n\t\t}\n\t\tif g.player1 != string(player) \u0026\u0026 g.player2 != string(player) {\n\t\t\tpanic(\"You are not part of this game\")\n\t\t}\n\t\tif (g.turnPlayer == 1 \u0026\u0026 g.player1 != string(player)) || (g.turnPlayer == 2 \u0026\u0026 g.player2 != string(player)) {\n\t\t\tpanic(\"Not your turn\")\n\t\t}\n\t\tif row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n\t\t\tpanic(\"Move position out of bounds\")\n\t\t}\n\t\tif g.board[row][col] != 0 {\n\t\t\tpanic(\"Square not empty\")\n\t\t}\n\n\t\tg.board[row][col] = g.turnPlayer\n\t\twinner := checkForWinner(g)\n\t\tif winner != 0 {\n\t\t\tif winner != 3 {\n\t\t\t\tg.winner = winner\n\t\t\t}\n\t\t\tg.status = 1\n\t\t} else {\n\t\t\tif g.turnPlayer == 1 {\n\t\t\t\tg.turnPlayer = 2\n\t\t\t} else {\n\t\t\t\tg.turnPlayer = 1\n\t\t\t}\n\t\t}\n\t\tallGames.Set(g.ID, g)\n\t\treturn g.status\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc checkForWinner(g gameState) int8 {\n\t// define a lambda function for checking one line\n\tcheckLine := func(startRow int, startColumn int, deltaRow int, deltaColumn int) gameResult {\n\t\tvar lastSquare squareState = g.board[startRow][startColumn]\n\t\trow, column := startRow+deltaRow, startColumn+deltaColumn\n\n\t\t// loop starts from the second square(startRow + deltaRow, startColumn + deltaColumn)\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\n\t\t\t// there can't be a winner if a empty square is present within the line\n\t\t\tif g.board[row][column] == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+deltaRow, column+deltaColumn\n\t\t}\n\n\t\t// someone has won the game\n\t\tif lastSquare == 1 {\n\t\t\treturn 1\n\t\t} else if lastSquare == 2 {\n\t\t\treturn 2\n\t\t}\n\n\t\treturn 0\n\t}\n\n\t// check horizontal rows\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check vertical columns\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(column, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check top-left to bottom-right diagonal\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\t// check top-right to bottom-left diagonal\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\t// check for draw\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// if no one wins yet, but none of the squares are empty\n\treturn 3\n}\n\nfunc Render(path string) string {\n\treturn \"Welcome to tictactoe\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"500000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AtbNEYgmLPZsATNRANRI0dXaZ/8LMp2Pl80pikkXnG2K"},"signature":"civc+hZNViiLwNjQS9y7Z15CE9rukc1WQwaZNJjGmakuj0MHR3DPB2uh6wzMP6yOVm2iqzy2+wDjI7UngnGc0w=="}],"memo":""},"blockNum":"90483"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1p6t66hp027gq6pt7x7vqz9aaqxpxat8y3aa9et","package":{"Name":"tictactoe","Path":"gno.land/p/clockwork/tictactoe","Files":[{"Name":"tictactoe.gno","Body":"package tictactoe\n\nimport (\n  \"std\"\n  \"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n  ID  int64\n\tboard      [3][3]int8\n\tturnPlayer int8\n  player0 string\n  player1 string\n  winner int8\n  status int8 // 0=open 1=closed\n}\n\nvar (\n\t// (not \"games\" because that's too useful a variable name)\n\tallGames     avl.Tree // string (game ID) -\u003e *Game\n\tnextGameId int64 = 0\n  availableGames []int64\n\t// Value must be sorted by game ID, descending\n\tuserGames avl.Tree // std.Address -\u003e []*Game\n)\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\nfunc StartGame() int64 {\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return startGame(caller)\n}\nfunc startGame(player std.Address) int64 {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatUint(nextGameId, 10))\n\tg := \u0026gameState{\n    ID: nextGameId, \n  \tboard:     [3][3]int8{},\n  \tturnPlayer: 1,\n    player1: player,\n    player2: \"\",\n    status:0,\n  }\n\tallGames.Set(g.ID, g)\n  availableGames=append(availableGames, g.ID)\n  addGameToUser(g.ID, player)\n  return g.ID\n}\n\nfunc addGameToUser(gameId int64, player std.Address) {\n\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\t// game must be at top, because it is the latest ID\n\tgames = append([]int64{gameId}, games...)\n\tuserGames.Set(string(addr), games)\n}\nfunc GetGames() []int64{\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return getGames(caller)\n}\nfunc getGames(player std.Address) []int64{\n\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n  return games\n}\nfunc GetAvailableGames() {\n  return availableGames\n}\nfunc JoinGame(gameId int64) {\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return joinGame(gameId, caller)\n}\nfunc joinGame(gameId int64, player std.Address) bool {\n  graw, ok := allGames.get(gameId)\n  if (ok) {\n\t  g := graw.(*gameState)\n    if(g.player2!=\"\") {\n      panic(\"Game not available\")\n    }\n    g.player2 = string(player)\n    allGames.Set(g.ID, g)\n    removeFromAvailableGames(g.ID)\n    return ok\n  }\n  panic(\"Game not found\")\n}\nfunc indexOf(element int64, data []int64) (int) {\n   for k, v := range data {\n       if element == v {\n           return k\n       }\n   }\n   return -1    //not found.\n}\nfunc removeFromAvailableGames(gameId int64) {\n  index:=indexOf(gameId, availableGames)\n  if (index==-1) {\n    panic(\"Game was not available\")\n  }\n  if (index==0 \u0026\u0026 len(availableGames)==1) {\n    availableGames = []int64{}\n  }else{\n    newAvailableGames:=availableGames[:len(availableGames)-1]\n    newAvailableGames[index]=availableGames[len(availableGames)-1]\n    availableGames=append([]int64{},newAvailableGames...)\n  }\n}\nfunc MakeMove(gameId int64, row, col int8) int8{\n\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n  return makeMove(gameId, caller)\n}\nfunc makeMove(gameId int64, row, col int8, player std.Address) int8 {\n  graw, ok := allGames.get(gameId)\n  if (ok) {\n\t  g := graw.(*gameState)\n    if (g.status==1) {\n      panic(\"Game has ended\")\n    }\n    if(g.player1!=string(player) \u0026\u0026 g.player2!=string(player)) {\n      panic(\"You are not part of this game\")\n    }\n    if(g.turnPlayer==1 \u0026\u0026 g.player1!=string(player)) || (g.turnPlayer==2 \u0026\u0026 g.player2!=string(player)) {\n      panic(\"Not your turn\")\n    }\n    if row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n      panic(\"Move position out of bounds\")\n    }\n    if g.board[row][col] != 0 {\n      panic(\"Square not empty\")\n    }\n\n  \tg.board[row][col] = g.turnPlayer\n    winner:=checkForWinner(g)\n    if (winner!=0) {\n      if (winner!=3) {\n        g.winner = winner\n      }\n      g.status = 1\n    }else{\n      if g.turnPlayer==1 {\n        g.turnPlayer=2\n      }else{\n        g.turnPlayer=1\n      }\n    }\n    allGames.Set(g.ID, g)\n    return g.status\n  }\n  panic(\"Game not found\")\n}\n\nfunc checkForWinner(g gameState) int8 {\n\n\t// define a lambda function for checking one line\n\tcheckLine := func(startRow int, startColumn int, deltaRow int, deltaColumn int) gameResult {\n\t\tvar lastSquare squareState = g.board[startRow][startColumn]\n\t\trow, column := startRow+deltaRow, startColumn+deltaColumn\n\n\t\t// loop starts from the second square(startRow + deltaRow, startColumn + deltaColumn)\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\n\t\t\t// there can't be a winner if a empty square is present within the line\n\t\t\tif g.board[row][column] == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+deltaRow, column+deltaColumn\n\t\t}\n\n\t\t// someone has won the game\n\t\tif lastSquare == 1 {\n\t\t\treturn 1\n\t\t} else if lastSquare == 2 {\n\t\t\treturn 2\n\t\t}\n\n\t\treturn 0\n\t}\n\n\t// check horizontal rows\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check vertical columns\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(column, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check top-left to bottom-right diagonal\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\t// check top-right to bottom-left diagonal\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\t// check for draw\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// if no one wins yet, but none of the squares are empty\n\treturn 3\n}\nfunc Render(path string) string {\n  return \"Welcome to tictactoe\"\n}"},{"Name":"gno.mod","Body":"module gno.land/r/clockwork/tictactoe\n\nrequire (\n\t\"gno.land/p/demo/avl\" v0.0.0-latest\n)\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3OCHplHTcHHgHBsvN0BB6tGZvEvEDGSj6W3RXNYgUFI"},"signature":"bxyKgWFODk+aXM7pTrjPx32dkedHA5gYJivZoJYgBOs4KMg3HRTw+D7RFSrOhNoS76bEvJtN6ZFv1Folcs4Cfg=="}],"memo":""},"blockNum":"90490"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1zgggsu07z6mq277mnt6hlrnc0yhc7404t3ww0f","package":{"Name":"tictactoe","Path":"gno.land/r/clockwork/tictactoe","Files":[{"Name":"gno.mod","Body":"module gno.land/r/clockwork/tictactoe\n\nrequire (\n\t\"gno.land/p/demo/avl\" v0.0.0-latest\n)\n"},{"Name":"tictactoe.gno","Body":"package tictactoe\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n\tID         int64\n\tboard      [3][3]int8\n\tturnPlayer int8\n\tplayer0    string\n\tplayer1    string\n\twinner     int8\n\tstatus     int8 // 0=open 1=closed\n}\n\nvar (\n\t// (not \"games\" because that's too useful a variable name)\n\tallGames       avl.Tree // string (game ID) -\u003e *Game\n\tnextGameId     int64    = 0\n\tavailableGames []int64\n\t// Value must be sorted by game ID, descending\n\tuserGames avl.Tree // std.Address -\u003e []*Game\n)\n\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\n\nfunc StartGame() {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn startGame(caller)\n}\n\nfunc startGame(player std.Address) int64 {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatUint(nextGameId, 10))\n\tg := \u0026gameState{\n\t\tID:         nextGameId,\n\t\tboard:      [3][3]int8{},\n\t\tturnPlayer: 1,\n\t\tplayer1:    player,\n\t\tplayer2:    \"\",\n\t\tstatus:     0,\n\t}\n\tallGames.Set(g.ID, g)\n\tavailableGames = append(availableGames, g.ID)\n\taddGameToUser(g.ID, player)\n\treturn g.ID\n}\n\nfunc addGameToUser(gameId int64, player std.Address) {\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\t// game must be at top, because it is the latest ID\n\tgames = append([]int64{gameId}, games...)\n\tuserGames.Set(string(addr), games)\n}\n\nfunc GetGames() []int64 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn getGames(caller)\n}\n\nfunc getGames(player std.Address) []int64 {\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\treturn games\n}\n\nfunc GetAvailableGames() {\n\treturn availableGames\n}\n\nfunc JoinGame(gameId int64) {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn joinGame(gameId, caller)\n}\n\nfunc joinGame(gameId int64, player std.Address) bool {\n\tgraw, ok := allGames.get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.player2 != \"\" {\n\t\t\tpanic(\"Game not available\")\n\t\t}\n\t\tg.player2 = string(player)\n\t\tallGames.Set(g.ID, g)\n\t\tremoveFromAvailableGames(g.ID)\n\t\treturn ok\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc indexOf(element int64, data []int64) int {\n\tfor k, v := range data {\n\t\tif element == v {\n\t\t\treturn k\n\t\t}\n\t}\n\treturn -1 // not found.\n}\n\nfunc removeFromAvailableGames(gameId int64) {\n\tindex := indexOf(gameId, availableGames)\n\tif index == -1 {\n\t\tpanic(\"Game was not available\")\n\t}\n\tif index == 0 \u0026\u0026 len(availableGames) == 1 {\n\t\tavailableGames = []int64{}\n\t} else {\n\t\tnewAvailableGames := availableGames[:len(availableGames)-1]\n\t\tnewAvailableGames[index] = availableGames[len(availableGames)-1]\n\t\tavailableGames = append([]int64{}, newAvailableGames...)\n\t}\n}\n\nfunc MakeMove(gameId int64, row, col int8) int8 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn makeMove(gameId, caller)\n}\n\nfunc makeMove(gameId int64, row, col int8, player std.Address) int8 {\n\tgraw, ok := allGames.get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.status == 1 {\n\t\t\tpanic(\"Game has ended\")\n\t\t}\n\t\tif g.player1 != string(player) \u0026\u0026 g.player2 != string(player) {\n\t\t\tpanic(\"You are not part of this game\")\n\t\t}\n\t\tif (g.turnPlayer == 1 \u0026\u0026 g.player1 != string(player)) || (g.turnPlayer == 2 \u0026\u0026 g.player2 != string(player)) {\n\t\t\tpanic(\"Not your turn\")\n\t\t}\n\t\tif row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n\t\t\tpanic(\"Move position out of bounds\")\n\t\t}\n\t\tif g.board[row][col] != 0 {\n\t\t\tpanic(\"Square not empty\")\n\t\t}\n\n\t\tg.board[row][col] = g.turnPlayer\n\t\twinner := checkForWinner(g)\n\t\tif winner != 0 {\n\t\t\tif winner != 3 {\n\t\t\t\tg.winner = winner\n\t\t\t}\n\t\t\tg.status = 1\n\t\t} else {\n\t\t\tif g.turnPlayer == 1 {\n\t\t\t\tg.turnPlayer = 2\n\t\t\t} else {\n\t\t\t\tg.turnPlayer = 1\n\t\t\t}\n\t\t}\n\t\tallGames.Set(g.ID, g)\n\t\treturn g.status\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc checkForWinner(g gameState) int8 {\n\t// define a lambda function for checking one line\n\tcheckLine := func(startRow int, startColumn int, deltaRow int, deltaColumn int) gameResult {\n\t\tvar lastSquare squareState = g.board[startRow][startColumn]\n\t\trow, column := startRow+deltaRow, startColumn+deltaColumn\n\n\t\t// loop starts from the second square(startRow + deltaRow, startColumn + deltaColumn)\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\n\t\t\t// there can't be a winner if a empty square is present within the line\n\t\t\tif g.board[row][column] == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+deltaRow, column+deltaColumn\n\t\t}\n\n\t\t// someone has won the game\n\t\tif lastSquare == 1 {\n\t\t\treturn 1\n\t\t} else if lastSquare == 2 {\n\t\t\treturn 2\n\t\t}\n\n\t\treturn 0\n\t}\n\n\t// check horizontal rows\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check vertical columns\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(column, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check top-left to bottom-right diagonal\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\t// check top-right to bottom-left diagonal\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\t// check for draw\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// if no one wins yet, but none of the squares are empty\n\treturn 3\n}\n\nfunc Render(path string) string {\n\treturn \"Welcome to tictactoe\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"500000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AtbNEYgmLPZsATNRANRI0dXaZ/8LMp2Pl80pikkXnG2K"},"signature":"b+tLw/j+ZHaGj7mgtB/iKlT2Q+Joz6oNhWrf6RpGuJMKaiY95Sjv2FVeEvAktTk49VKH81zh2onwIvcCLD6hPQ=="}],"memo":""},"blockNum":"90493"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1zgggsu07z6mq277mnt6hlrnc0yhc7404t3ww0f","package":{"Name":"tictactoe","Path":"gno.land/r/clockwork/tictactoe","Files":[{"Name":"gno.mod","Body":"module gno.land/r/clockwork/tictactoe\n\nrequire (\n\t\"gno.land/p/demo/avl\" v0.0.0-latest\n)\n"},{"Name":"tictactoe.gno","Body":"package tictactoe\n\nimport (\n\t\"std\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n\tID         int64\n\tboard      [3][3]int8\n\tturnPlayer int8\n\tplayer0    string\n\tplayer1    string\n\twinner     int8\n\tstatus     int8 // 0=open 1=closed\n}\n\nvar (\n\t// (not \"games\" because that's too useful a variable name)\n\tallGames       avl.Tree // string (game ID) -\u003e *Game\n\tnextGameId     int64    = 0\n\tavailableGames []int64\n\t// Value must be sorted by game ID, descending\n\tuserGames avl.Tree // std.Address -\u003e []*Game\n)\n\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\n\nfunc StartGame() int64 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn startGame(caller)\n}\n\nfunc startGame(player std.Address) int64 {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatUint(nextGameId, 10))\n\tg := \u0026gameState{\n\t\tID:         nextGameId,\n\t\tboard:      [3][3]int8{},\n\t\tturnPlayer: 1,\n\t\tplayer1:    player,\n\t\tplayer2:    \"\",\n\t\tstatus:     0,\n\t}\n\tallGames.Set(g.ID, g)\n\tavailableGames = append(availableGames, g.ID)\n\taddGameToUser(g.ID, player)\n\treturn g.ID\n}\n\nfunc addGameToUser(gameId int64, player std.Address) {\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\t// game must be at top, because it is the latest ID\n\tgames = append([]int64{gameId}, games...)\n\tuserGames.Set(string(addr), games)\n}\n\nfunc GetGames() []int64 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn getGames(caller)\n}\n\nfunc getGames(player std.Address) []int64 {\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\treturn games\n}\n\nfunc GetAvailableGames() {\n\treturn availableGames\n}\n\nfunc JoinGame(gameId int64) {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn joinGame(gameId, caller)\n}\n\nfunc joinGame(gameId int64, player std.Address) bool {\n\tgraw, ok := allGames.get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.player2 != \"\" {\n\t\t\tpanic(\"Game not available\")\n\t\t}\n\t\tg.player2 = string(player)\n\t\tallGames.Set(g.ID, g)\n\t\tremoveFromAvailableGames(g.ID)\n\t\treturn ok\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc indexOf(element int64, data []int64) int {\n\tfor k, v := range data {\n\t\tif element == v {\n\t\t\treturn k\n\t\t}\n\t}\n\treturn -1 // not found.\n}\n\nfunc removeFromAvailableGames(gameId int64) {\n\tindex := indexOf(gameId, availableGames)\n\tif index == -1 {\n\t\tpanic(\"Game was not available\")\n\t}\n\tif index == 0 \u0026\u0026 len(availableGames) == 1 {\n\t\tavailableGames = []int64{}\n\t} else {\n\t\tnewAvailableGames := availableGames[:len(availableGames)-1]\n\t\tnewAvailableGames[index] = availableGames[len(availableGames)-1]\n\t\tavailableGames = append([]int64{}, newAvailableGames...)\n\t}\n}\n\nfunc MakeMove(gameId int64, row, col int8) int8 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn makeMove(gameId, caller)\n}\n\nfunc makeMove(gameId int64, row, col int8, player std.Address) int8 {\n\tgraw, ok := allGames.get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.status == 1 {\n\t\t\tpanic(\"Game has ended\")\n\t\t}\n\t\tif g.player1 != string(player) \u0026\u0026 g.player2 != string(player) {\n\t\t\tpanic(\"You are not part of this game\")\n\t\t}\n\t\tif (g.turnPlayer == 1 \u0026\u0026 g.player1 != string(player)) || (g.turnPlayer == 2 \u0026\u0026 g.player2 != string(player)) {\n\t\t\tpanic(\"Not your turn\")\n\t\t}\n\t\tif row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n\t\t\tpanic(\"Move position out of bounds\")\n\t\t}\n\t\tif g.board[row][col] != 0 {\n\t\t\tpanic(\"Square not empty\")\n\t\t}\n\n\t\tg.board[row][col] = g.turnPlayer\n\t\twinner := checkForWinner(g)\n\t\tif winner != 0 {\n\t\t\tif winner != 3 {\n\t\t\t\tg.winner = winner\n\t\t\t}\n\t\t\tg.status = 1\n\t\t} else {\n\t\t\tif g.turnPlayer == 1 {\n\t\t\t\tg.turnPlayer = 2\n\t\t\t} else {\n\t\t\t\tg.turnPlayer = 1\n\t\t\t}\n\t\t}\n\t\tallGames.Set(g.ID, g)\n\t\treturn g.status\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc checkForWinner(g gameState) int8 {\n\t// define a lambda function for checking one line\n\tcheckLine := func(startRow int, startColumn int, deltaRow int, deltaColumn int) gameResult {\n\t\tvar lastSquare squareState = g.board[startRow][startColumn]\n\t\trow, column := startRow+deltaRow, startColumn+deltaColumn\n\n\t\t// loop starts from the second square(startRow + deltaRow, startColumn + deltaColumn)\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\n\t\t\t// there can't be a winner if a empty square is present within the line\n\t\t\tif g.board[row][column] == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+deltaRow, column+deltaColumn\n\t\t}\n\n\t\t// someone has won the game\n\t\tif lastSquare == 1 {\n\t\t\treturn 1\n\t\t} else if lastSquare == 2 {\n\t\t\treturn 2\n\t\t}\n\n\t\treturn 0\n\t}\n\n\t// check horizontal rows\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check vertical columns\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(column, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check top-left to bottom-right diagonal\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\t// check top-right to bottom-left diagonal\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\t// check for draw\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// if no one wins yet, but none of the squares are empty\n\treturn 3\n}\n\nfunc Render(path string) string {\n\treturn \"Welcome to tictactoe\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"500000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AtbNEYgmLPZsATNRANRI0dXaZ/8LMp2Pl80pikkXnG2K"},"signature":"8U5csl/E3ZbUWIw2cOHxq03x8evQK99TVRNHoCFGJr1PWCZa/pIj0AemMqzBKQlP585BSeCV3hmA/+KJbw5GEA=="}],"memo":""},"blockNum":"90495"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1zgggsu07z6mq277mnt6hlrnc0yhc7404t3ww0f","package":{"Name":"tictactoe","Path":"gno.land/r/clockwork/tictactoe","Files":[{"Name":"gno.mod","Body":"module gno.land/r/clockwork/tictactoe\n\nrequire (\n\t\"gno.land/p/demo/avl\" v0.0.0-latest\n)\n"},{"Name":"tictactoe.gno","Body":"package tictactoe\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n\tID         int64\n\tboard      [3][3]int8\n\tturnPlayer int8\n\tplayer0    string\n\tplayer1    string\n\twinner     int8\n\tstatus     int8 // 0=open 1=closed\n}\n\nvar (\n\t// (not \"games\" because that's too useful a variable name)\n\tallGames       avl.Tree // string (game ID) -\u003e *Game\n\tnextGameId     int64    = 0\n\tavailableGames []int64\n\t// Value must be sorted by game ID, descending\n\tuserGames avl.Tree // std.Address -\u003e []*Game\n)\n\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\n\nfunc StartGame() int64 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn startGame(caller)\n}\n\nfunc startGame(player std.Address) int64 {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatUint(nextGameId, 10))\n\tg := \u0026gameState{\n\t\tID:         nextGameId,\n\t\tboard:      [3][3]int8{},\n\t\tturnPlayer: 1,\n\t\tplayer1:    player,\n\t\tplayer2:    \"\",\n\t\tstatus:     0,\n\t}\n\tallGames.Set(g.ID, g)\n\tavailableGames = append(availableGames, g.ID)\n\taddGameToUser(g.ID, player)\n\treturn g.ID\n}\n\nfunc addGameToUser(gameId int64, player std.Address) {\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\t// game must be at top, because it is the latest ID\n\tgames = append([]int64{gameId}, games...)\n\tuserGames.Set(string(addr), games)\n}\n\nfunc GetGames() []int64 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn getGames(caller)\n}\n\nfunc getGames(player std.Address) []int64 {\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\treturn games\n}\n\nfunc GetAvailableGames() {\n\treturn availableGames\n}\n\nfunc JoinGame(gameId int64) {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn joinGame(gameId, caller)\n}\n\nfunc joinGame(gameId int64, player std.Address) bool {\n\tgraw, ok := allGames.get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.player2 != \"\" {\n\t\t\tpanic(\"Game not available\")\n\t\t}\n\t\tg.player2 = string(player)\n\t\tallGames.Set(g.ID, g)\n\t\tremoveFromAvailableGames(g.ID)\n\t\treturn ok\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc indexOf(element int64, data []int64) int {\n\tfor k, v := range data {\n\t\tif element == v {\n\t\t\treturn k\n\t\t}\n\t}\n\treturn -1 // not found.\n}\n\nfunc removeFromAvailableGames(gameId int64) {\n\tindex := indexOf(gameId, availableGames)\n\tif index == -1 {\n\t\tpanic(\"Game was not available\")\n\t}\n\tif index == 0 \u0026\u0026 len(availableGames) == 1 {\n\t\tavailableGames = []int64{}\n\t} else {\n\t\tnewAvailableGames := availableGames[:len(availableGames)-1]\n\t\tnewAvailableGames[index] = availableGames[len(availableGames)-1]\n\t\tavailableGames = append([]int64{}, newAvailableGames...)\n\t}\n}\n\nfunc MakeMove(gameId int64, row, col int8) int8 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn makeMove(gameId, caller)\n}\n\nfunc makeMove(gameId int64, row, col int8, player std.Address) int8 {\n\tgraw, ok := allGames.get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.status == 1 {\n\t\t\tpanic(\"Game has ended\")\n\t\t}\n\t\tif g.player1 != string(player) \u0026\u0026 g.player2 != string(player) {\n\t\t\tpanic(\"You are not part of this game\")\n\t\t}\n\t\tif (g.turnPlayer == 1 \u0026\u0026 g.player1 != string(player)) || (g.turnPlayer == 2 \u0026\u0026 g.player2 != string(player)) {\n\t\t\tpanic(\"Not your turn\")\n\t\t}\n\t\tif row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n\t\t\tpanic(\"Move position out of bounds\")\n\t\t}\n\t\tif g.board[row][col] != 0 {\n\t\t\tpanic(\"Square not empty\")\n\t\t}\n\n\t\tg.board[row][col] = g.turnPlayer\n\t\twinner := checkForWinner(g)\n\t\tif winner != 0 {\n\t\t\tif winner != 3 {\n\t\t\t\tg.winner = winner\n\t\t\t}\n\t\t\tg.status = 1\n\t\t} else {\n\t\t\tif g.turnPlayer == 1 {\n\t\t\t\tg.turnPlayer = 2\n\t\t\t} else {\n\t\t\t\tg.turnPlayer = 1\n\t\t\t}\n\t\t}\n\t\tallGames.Set(g.ID, g)\n\t\treturn g.status\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc checkForWinner(g gameState) int8 {\n\t// define a lambda function for checking one line\n\tcheckLine := func(startRow int, startColumn int, deltaRow int, deltaColumn int) gameResult {\n\t\tvar lastSquare squareState = g.board[startRow][startColumn]\n\t\trow, column := startRow+deltaRow, startColumn+deltaColumn\n\n\t\t// loop starts from the second square(startRow + deltaRow, startColumn + deltaColumn)\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\n\t\t\t// there can't be a winner if a empty square is present within the line\n\t\t\tif g.board[row][column] == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+deltaRow, column+deltaColumn\n\t\t}\n\n\t\t// someone has won the game\n\t\tif lastSquare == 1 {\n\t\t\treturn 1\n\t\t} else if lastSquare == 2 {\n\t\t\treturn 2\n\t\t}\n\n\t\treturn 0\n\t}\n\n\t// check horizontal rows\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check vertical columns\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(column, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check top-left to bottom-right diagonal\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\t// check top-right to bottom-left diagonal\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\t// check for draw\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// if no one wins yet, but none of the squares are empty\n\treturn 3\n}\n\nfunc Render(path string) string {\n\treturn \"Welcome to tictactoe\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"500000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AtbNEYgmLPZsATNRANRI0dXaZ/8LMp2Pl80pikkXnG2K"},"signature":"rGbTYqXW5T5wlqC/qawsEpK+nOBl0dvcYIKqPEzzD3hpJSYzpoPd2A9carwuHh6LJT5VNwuomgGarNarvB+lVg=="}],"memo":""},"blockNum":"90497"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1zgggsu07z6mq277mnt6hlrnc0yhc7404t3ww0f","package":{"Name":"tictactoe","Path":"gno.land/r/clockwork/tictactoe","Files":[{"Name":"gno.mod","Body":"module gno.land/r/clockwork/tictactoe\n\nrequire (\n\t\"gno.land/p/demo/avl\" v0.0.0-latest\n)\n"},{"Name":"tictactoe.gno","Body":"package tictactoe\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n\tID         int64\n\tboard      [3][3]int8\n\tturnPlayer int8\n\tplayer0    string\n\tplayer1    string\n\twinner     int8\n\tstatus     int8 // 0=open 1=closed\n}\n\nvar (\n\t// (not \"games\" because that's too useful a variable name)\n\tallGames       avl.Tree // string (game ID) -\u003e *Game\n\tnextGameId     int64    = 0\n\tavailableGames []int64\n\t// Value must be sorted by game ID, descending\n\tuserGames avl.Tree // std.Address -\u003e []*Game\n)\n\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\n\nfunc StartGame() int64 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn startGame(caller)\n}\n\nfunc startGame(player std.Address) int64 {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatInt(nextGameId, 10))\n\tg := \u0026gameState{\n\t\tID:         nextGameId,\n\t\tboard:      [3][3]int8{},\n\t\tturnPlayer: 1,\n\t\tplayer1:    player,\n\t\tplayer2:    \"\",\n\t\tstatus:     0,\n\t}\n\tallGames.Set(g.ID, g)\n\tavailableGames = append(availableGames, g.ID)\n\taddGameToUser(g.ID, player)\n\treturn g.ID\n}\n\nfunc addGameToUser(gameId int64, player std.Address) {\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\t// game must be at top, because it is the latest ID\n\tgames = append([]int64{gameId}, games...)\n\tuserGames.Set(string(addr), games)\n}\n\nfunc GetGames() []int64 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn getGames(caller)\n}\n\nfunc getGames(player std.Address) []int64 {\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\treturn games\n}\n\nfunc GetAvailableGames() {\n\treturn availableGames\n}\n\nfunc JoinGame(gameId int64) {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn joinGame(gameId, caller)\n}\n\nfunc joinGame(gameId int64, player std.Address) bool {\n\tgraw, ok := allGames.get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.player2 != \"\" {\n\t\t\tpanic(\"Game not available\")\n\t\t}\n\t\tg.player2 = string(player)\n\t\tallGames.Set(g.ID, g)\n\t\tremoveFromAvailableGames(g.ID)\n\t\treturn ok\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc indexOf(element int64, data []int64) int {\n\tfor k, v := range data {\n\t\tif element == v {\n\t\t\treturn k\n\t\t}\n\t}\n\treturn -1 // not found.\n}\n\nfunc removeFromAvailableGames(gameId int64) {\n\tindex := indexOf(gameId, availableGames)\n\tif index == -1 {\n\t\tpanic(\"Game was not available\")\n\t}\n\tif index == 0 \u0026\u0026 len(availableGames) == 1 {\n\t\tavailableGames = []int64{}\n\t} else {\n\t\tnewAvailableGames := availableGames[:len(availableGames)-1]\n\t\tnewAvailableGames[index] = availableGames[len(availableGames)-1]\n\t\tavailableGames = append([]int64{}, newAvailableGames...)\n\t}\n}\n\nfunc MakeMove(gameId int64, row, col int8) int8 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn makeMove(gameId, caller)\n}\n\nfunc makeMove(gameId int64, row, col int8, player std.Address) int8 {\n\tgraw, ok := allGames.get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.status == 1 {\n\t\t\tpanic(\"Game has ended\")\n\t\t}\n\t\tif g.player1 != string(player) \u0026\u0026 g.player2 != string(player) {\n\t\t\tpanic(\"You are not part of this game\")\n\t\t}\n\t\tif (g.turnPlayer == 1 \u0026\u0026 g.player1 != string(player)) || (g.turnPlayer == 2 \u0026\u0026 g.player2 != string(player)) {\n\t\t\tpanic(\"Not your turn\")\n\t\t}\n\t\tif row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n\t\t\tpanic(\"Move position out of bounds\")\n\t\t}\n\t\tif g.board[row][col] != 0 {\n\t\t\tpanic(\"Square not empty\")\n\t\t}\n\n\t\tg.board[row][col] = g.turnPlayer\n\t\twinner := checkForWinner(g)\n\t\tif winner != 0 {\n\t\t\tif winner != 3 {\n\t\t\t\tg.winner = winner\n\t\t\t}\n\t\t\tg.status = 1\n\t\t} else {\n\t\t\tif g.turnPlayer == 1 {\n\t\t\t\tg.turnPlayer = 2\n\t\t\t} else {\n\t\t\t\tg.turnPlayer = 1\n\t\t\t}\n\t\t}\n\t\tallGames.Set(g.ID, g)\n\t\treturn g.status\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc checkForWinner(g gameState) int8 {\n\t// define a lambda function for checking one line\n\tcheckLine := func(startRow int, startColumn int, deltaRow int, deltaColumn int) gameResult {\n\t\tvar lastSquare squareState = g.board[startRow][startColumn]\n\t\trow, column := startRow+deltaRow, startColumn+deltaColumn\n\n\t\t// loop starts from the second square(startRow + deltaRow, startColumn + deltaColumn)\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\n\t\t\t// there can't be a winner if a empty square is present within the line\n\t\t\tif g.board[row][column] == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+deltaRow, column+deltaColumn\n\t\t}\n\n\t\t// someone has won the game\n\t\tif lastSquare == 1 {\n\t\t\treturn 1\n\t\t} else if lastSquare == 2 {\n\t\t\treturn 2\n\t\t}\n\n\t\treturn 0\n\t}\n\n\t// check horizontal rows\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check vertical columns\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(column, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check top-left to bottom-right diagonal\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\t// check top-right to bottom-left diagonal\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\t// check for draw\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// if no one wins yet, but none of the squares are empty\n\treturn 3\n}\n\nfunc Render(path string) string {\n\treturn \"Welcome to tictactoe\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"500000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AtbNEYgmLPZsATNRANRI0dXaZ/8LMp2Pl80pikkXnG2K"},"signature":"piXtSudBNGibA+zEJOESpiTLzFNs1tKjsDUpkM3UQjIJZaHuazrObRxTUj7L3DuldKBdiG2gQU5HVg3Z+IpBNw=="}],"memo":""},"blockNum":"90499"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1zgggsu07z6mq277mnt6hlrnc0yhc7404t3ww0f","package":{"Name":"tictactoe","Path":"gno.land/r/clockwork/tictactoe","Files":[{"Name":"gno.mod","Body":"module gno.land/r/clockwork/tictactoe\n\nrequire (\n\t\"gno.land/p/demo/avl\" v0.0.0-latest\n)\n"},{"Name":"tictactoe.gno","Body":"package tictactoe\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n\tID         int64\n\tboard      [3][3]int8\n\tturnPlayer int8\n\tplayer1    string\n\tplayer2    string\n\twinner     int8\n\tstatus     int8 // 0=open 1=closed\n}\n\nvar (\n\t// (not \"games\" because that's too useful a variable name)\n\tallGames       avl.Tree // string (game ID) -\u003e *Game\n\tnextGameId     int64    = 0\n\tavailableGames []int64\n\t// Value must be sorted by game ID, descending\n\tuserGames avl.Tree // std.Address -\u003e []*Game\n)\n\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\n\nfunc StartGame() int64 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn startGame(caller)\n}\n\nfunc startGame(player std.Address) int64 {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatInt(nextGameId, 10))\n\tg := \u0026gameState{\n\t\tID:         nextGameId,\n\t\tboard:      [3][3]int8{},\n\t\tturnPlayer: 1,\n\t\tplayer1:    player,\n\t\tplayer2:    \"\",\n\t\tstatus:     0,\n\t}\n\tallGames.Set(g.ID, g)\n\tavailableGames = append(availableGames, g.ID)\n\taddGameToUser(g.ID, player)\n\treturn g.ID\n}\n\nfunc addGameToUser(gameId int64, player std.Address) {\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\t// game must be at top, because it is the latest ID\n\tgames = append([]int64{gameId}, games...)\n\tuserGames.Set(string(addr), games)\n}\n\nfunc GetGames() []int64 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn getGames(caller)\n}\n\nfunc getGames(player std.Address) []int64 {\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\treturn games\n}\n\nfunc GetAvailableGames() {\n\treturn availableGames\n}\n\nfunc JoinGame(gameId int64) {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn joinGame(gameId, caller)\n}\n\nfunc joinGame(gameId int64, player std.Address) bool {\n\tgraw, ok := allGames.get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.player2 != \"\" {\n\t\t\tpanic(\"Game not available\")\n\t\t}\n\t\tg.player2 = string(player)\n\t\tallGames.Set(g.ID, g)\n\t\tremoveFromAvailableGames(g.ID)\n\t\treturn ok\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc indexOf(element int64, data []int64) int {\n\tfor k, v := range data {\n\t\tif element == v {\n\t\t\treturn k\n\t\t}\n\t}\n\treturn -1 // not found.\n}\n\nfunc removeFromAvailableGames(gameId int64) {\n\tindex := indexOf(gameId, availableGames)\n\tif index == -1 {\n\t\tpanic(\"Game was not available\")\n\t}\n\tif index == 0 \u0026\u0026 len(availableGames) == 1 {\n\t\tavailableGames = []int64{}\n\t} else {\n\t\tnewAvailableGames := availableGames[:len(availableGames)-1]\n\t\tnewAvailableGames[index] = availableGames[len(availableGames)-1]\n\t\tavailableGames = append([]int64{}, newAvailableGames...)\n\t}\n}\n\nfunc MakeMove(gameId int64, row, col int8) int8 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn makeMove(gameId, caller)\n}\n\nfunc makeMove(gameId int64, row, col int8, player std.Address) int8 {\n\tgraw, ok := allGames.get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.status == 1 {\n\t\t\tpanic(\"Game has ended\")\n\t\t}\n\t\tif g.player1 != string(player) \u0026\u0026 g.player2 != string(player) {\n\t\t\tpanic(\"You are not part of this game\")\n\t\t}\n\t\tif (g.turnPlayer == 1 \u0026\u0026 g.player1 != string(player)) || (g.turnPlayer == 2 \u0026\u0026 g.player2 != string(player)) {\n\t\t\tpanic(\"Not your turn\")\n\t\t}\n\t\tif row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n\t\t\tpanic(\"Move position out of bounds\")\n\t\t}\n\t\tif g.board[row][col] != 0 {\n\t\t\tpanic(\"Square not empty\")\n\t\t}\n\n\t\tg.board[row][col] = g.turnPlayer\n\t\twinner := checkForWinner(g)\n\t\tif winner != 0 {\n\t\t\tif winner != 3 {\n\t\t\t\tg.winner = winner\n\t\t\t}\n\t\t\tg.status = 1\n\t\t} else {\n\t\t\tif g.turnPlayer == 1 {\n\t\t\t\tg.turnPlayer = 2\n\t\t\t} else {\n\t\t\t\tg.turnPlayer = 1\n\t\t\t}\n\t\t}\n\t\tallGames.Set(g.ID, g)\n\t\treturn g.status\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc checkForWinner(g gameState) int8 {\n\t// define a lambda function for checking one line\n\tcheckLine := func(startRow int, startColumn int, deltaRow int, deltaColumn int) gameResult {\n\t\tvar lastSquare squareState = g.board[startRow][startColumn]\n\t\trow, column := startRow+deltaRow, startColumn+deltaColumn\n\n\t\t// loop starts from the second square(startRow + deltaRow, startColumn + deltaColumn)\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\n\t\t\t// there can't be a winner if a empty square is present within the line\n\t\t\tif g.board[row][column] == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+deltaRow, column+deltaColumn\n\t\t}\n\n\t\t// someone has won the game\n\t\tif lastSquare == 1 {\n\t\t\treturn 1\n\t\t} else if lastSquare == 2 {\n\t\t\treturn 2\n\t\t}\n\n\t\treturn 0\n\t}\n\n\t// check horizontal rows\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check vertical columns\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(column, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check top-left to bottom-right diagonal\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\t// check top-right to bottom-left diagonal\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\t// check for draw\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// if no one wins yet, but none of the squares are empty\n\treturn 3\n}\n\nfunc Render(path string) string {\n\treturn \"Welcome to tictactoe\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"500000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AtbNEYgmLPZsATNRANRI0dXaZ/8LMp2Pl80pikkXnG2K"},"signature":"IyNuQ3BXDI8yoKF/tbOEHzk/4E0zDEZSqlKgBgJFmQ0EWpcDeGs0oJr+/57+Zys3/1dzU5fuQznwb5t348cIFg=="}],"memo":""},"blockNum":"90501"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1zgggsu07z6mq277mnt6hlrnc0yhc7404t3ww0f","package":{"Name":"tictactoe","Path":"gno.land/r/clockwork/tictactoe","Files":[{"Name":"gno.mod","Body":"module gno.land/r/clockwork/tictactoe\n\nrequire (\n\t\"gno.land/p/demo/avl\" v0.0.0-latest\n)\n"},{"Name":"tictactoe.gno","Body":"package tictactoe\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n\tID         int64\n\tboard      [3][3]int8\n\tturnPlayer int8\n\tplayer1    string\n\tplayer2    string\n\twinner     int8\n\tstatus     int8 // 0=open 1=closed\n}\n\nvar (\n\t// (not \"games\" because that's too useful a variable name)\n\tallGames       avl.Tree // string (game ID) -\u003e *Game\n\tnextGameId     int64    = 0\n\tavailableGames []int64\n\t// Value must be sorted by game ID, descending\n\tuserGames avl.Tree // std.Address -\u003e []*Game\n)\n\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\n\nfunc StartGame() int64 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn startGame(caller)\n}\n\nfunc startGame(player std.Address) int64 {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatInt(nextGameId, 10))\n\tg := \u0026gameState{\n\t\tID:         nextGameId,\n\t\tboard:      [3][3]int8{},\n\t\tturnPlayer: 1,\n\t\tplayer1:    string(player),\n\t\tplayer2:    \"\",\n\t\tstatus:     0,\n\t}\n\tallGames.Set(g.ID, g)\n\tavailableGames = append(availableGames, g.ID)\n\taddGameToUser(g.ID, player)\n\treturn g.ID\n}\n\nfunc addGameToUser(gameId int64, player std.Address) {\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\t// game must be at top, because it is the latest ID\n\tgames = append([]int64{gameId}, games...)\n\tuserGames.Set(string(addr), games)\n}\n\nfunc GetGames() []int64 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn getGames(caller)\n}\n\nfunc getGames(player std.Address) []int64 {\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\treturn games\n}\n\nfunc GetAvailableGames() {\n\treturn availableGames\n}\n\nfunc JoinGame(gameId int64) {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn joinGame(gameId, caller)\n}\n\nfunc joinGame(gameId int64, player std.Address) bool {\n\tgraw, ok := allGames.get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.player2 != \"\" {\n\t\t\tpanic(\"Game not available\")\n\t\t}\n\t\tg.player2 = string(player)\n\t\tallGames.Set(g.ID, g)\n\t\tremoveFromAvailableGames(g.ID)\n\t\treturn ok\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc indexOf(element int64, data []int64) int {\n\tfor k, v := range data {\n\t\tif element == v {\n\t\t\treturn k\n\t\t}\n\t}\n\treturn -1 // not found.\n}\n\nfunc removeFromAvailableGames(gameId int64) {\n\tindex := indexOf(gameId, availableGames)\n\tif index == -1 {\n\t\tpanic(\"Game was not available\")\n\t}\n\tif index == 0 \u0026\u0026 len(availableGames) == 1 {\n\t\tavailableGames = []int64{}\n\t} else {\n\t\tnewAvailableGames := availableGames[:len(availableGames)-1]\n\t\tnewAvailableGames[index] = availableGames[len(availableGames)-1]\n\t\tavailableGames = append([]int64{}, newAvailableGames...)\n\t}\n}\n\nfunc MakeMove(gameId int64, row, col int8) int8 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn makeMove(gameId, caller)\n}\n\nfunc makeMove(gameId int64, row, col int8, player std.Address) int8 {\n\tgraw, ok := allGames.get(gameId)\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.status == 1 {\n\t\t\tpanic(\"Game has ended\")\n\t\t}\n\t\tif g.player1 != string(player) \u0026\u0026 g.player2 != string(player) {\n\t\t\tpanic(\"You are not part of this game\")\n\t\t}\n\t\tif (g.turnPlayer == 1 \u0026\u0026 g.player1 != string(player)) || (g.turnPlayer == 2 \u0026\u0026 g.player2 != string(player)) {\n\t\t\tpanic(\"Not your turn\")\n\t\t}\n\t\tif row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n\t\t\tpanic(\"Move position out of bounds\")\n\t\t}\n\t\tif g.board[row][col] != 0 {\n\t\t\tpanic(\"Square not empty\")\n\t\t}\n\n\t\tg.board[row][col] = g.turnPlayer\n\t\twinner := checkForWinner(g)\n\t\tif winner != 0 {\n\t\t\tif winner != 3 {\n\t\t\t\tg.winner = winner\n\t\t\t}\n\t\t\tg.status = 1\n\t\t} else {\n\t\t\tif g.turnPlayer == 1 {\n\t\t\t\tg.turnPlayer = 2\n\t\t\t} else {\n\t\t\t\tg.turnPlayer = 1\n\t\t\t}\n\t\t}\n\t\tallGames.Set(g.ID, g)\n\t\treturn g.status\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc checkForWinner(g gameState) int8 {\n\t// define a lambda function for checking one line\n\tcheckLine := func(startRow int, startColumn int, deltaRow int, deltaColumn int) gameResult {\n\t\tvar lastSquare squareState = g.board[startRow][startColumn]\n\t\trow, column := startRow+deltaRow, startColumn+deltaColumn\n\n\t\t// loop starts from the second square(startRow + deltaRow, startColumn + deltaColumn)\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\n\t\t\t// there can't be a winner if a empty square is present within the line\n\t\t\tif g.board[row][column] == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+deltaRow, column+deltaColumn\n\t\t}\n\n\t\t// someone has won the game\n\t\tif lastSquare == 1 {\n\t\t\treturn 1\n\t\t} else if lastSquare == 2 {\n\t\t\treturn 2\n\t\t}\n\n\t\treturn 0\n\t}\n\n\t// check horizontal rows\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check vertical columns\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(column, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check top-left to bottom-right diagonal\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\t// check top-right to bottom-left diagonal\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\t// check for draw\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// if no one wins yet, but none of the squares are empty\n\treturn 3\n}\n\nfunc Render(path string) string {\n\treturn \"Welcome to tictactoe\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"500000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AtbNEYgmLPZsATNRANRI0dXaZ/8LMp2Pl80pikkXnG2K"},"signature":"nXQS7lfHbB10gcLeirzGZrncH7b1fQwLbczvvewPSC1IMDHHlM7ymeN/ZW7szYKhhNe8J3c1ZBdCb2ExdOza7Q=="}],"memo":""},"blockNum":"90503"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1zgggsu07z6mq277mnt6hlrnc0yhc7404t3ww0f","package":{"Name":"tictactoe","Path":"gno.land/r/clockwork/tictactoe","Files":[{"Name":"gno.mod","Body":"module gno.land/r/clockwork/tictactoe\n\nrequire (\n\t\"gno.land/p/demo/avl\" v0.0.0-latest\n)\n"},{"Name":"tictactoe.gno","Body":"package tictactoe\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n\tID         int64\n\tboard      [3][3]int8\n\tturnPlayer int8\n\tplayer1    string\n\tplayer2    string\n\twinner     int8\n\tstatus     int8 // 0=open 1=closed\n}\n\nvar (\n\t// (not \"games\" because that's too useful a variable name)\n\tallGames       avl.Tree // string (game ID) -\u003e *Game\n\tnextGameId     int64    = 0\n\tavailableGames []int64\n\t// Value must be sorted by game ID, descending\n\tuserGames avl.Tree // std.Address -\u003e []*Game\n)\n\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\n\nfunc StartGame() int64 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn startGame(caller)\n}\n\nfunc startGame(player std.Address) int64 {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatInt(nextGameId, 10))\n\tg := \u0026gameState{\n\t\tID:         nextGameId,\n\t\tboard:      [3][3]int8{},\n\t\tturnPlayer: 1,\n\t\tplayer1:    string(player),\n\t\tplayer2:    \"\",\n\t\tstatus:     0,\n\t}\n\tallGames.Set(string(g.ID), g)\n\tavailableGames = append(availableGames, g.ID)\n\taddGameToUser(g.ID, player)\n\treturn g.ID\n}\n\nfunc addGameToUser(gameId int64, player std.Address) {\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\t// game must be at top, because it is the latest ID\n\tgames = append([]int64{gameId}, games...)\n\tuserGames.Set(string(addr), games)\n}\n\nfunc GetGames() []int64 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn getGames(caller)\n}\n\nfunc getGames(player std.Address) []int64 {\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\treturn games\n}\n\nfunc GetAvailableGames() {\n\treturn availableGames\n}\n\nfunc JoinGame(gameId int64) {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn joinGame(gameId, caller)\n}\n\nfunc joinGame(gameId int64, player std.Address) bool {\n\tgraw, ok := allGames.get(string(gameId))\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.player2 != \"\" {\n\t\t\tpanic(\"Game not available\")\n\t\t}\n\t\tg.player2 = string(player)\n\t\tallGames.Set(string(g.ID), g)\n\t\tremoveFromAvailableGames(g.ID)\n\t\treturn ok\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc indexOf(element int64, data []int64) int {\n\tfor k, v := range data {\n\t\tif element == v {\n\t\t\treturn k\n\t\t}\n\t}\n\treturn -1 // not found.\n}\n\nfunc removeFromAvailableGames(gameId int64) {\n\tindex := indexOf(gameId, availableGames)\n\tif index == -1 {\n\t\tpanic(\"Game was not available\")\n\t}\n\tif index == 0 \u0026\u0026 len(availableGames) == 1 {\n\t\tavailableGames = []int64{}\n\t} else {\n\t\tnewAvailableGames := availableGames[:len(availableGames)-1]\n\t\tnewAvailableGames[index] = availableGames[len(availableGames)-1]\n\t\tavailableGames = append([]int64{}, newAvailableGames...)\n\t}\n}\n\nfunc MakeMove(gameId int64, row, col int8) int8 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn makeMove(gameId, caller)\n}\n\nfunc makeMove(gameId int64, row, col int8, player std.Address) int8 {\n\tgraw, ok := allGames.Get(string(gameId))\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.status == 1 {\n\t\t\tpanic(\"Game has ended\")\n\t\t}\n\t\tif g.player1 != string(player) \u0026\u0026 g.player2 != string(player) {\n\t\t\tpanic(\"You are not part of this game\")\n\t\t}\n\t\tif (g.turnPlayer == 1 \u0026\u0026 g.player1 != string(player)) || (g.turnPlayer == 2 \u0026\u0026 g.player2 != string(player)) {\n\t\t\tpanic(\"Not your turn\")\n\t\t}\n\t\tif row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n\t\t\tpanic(\"Move position out of bounds\")\n\t\t}\n\t\tif g.board[row][col] != 0 {\n\t\t\tpanic(\"Square not empty\")\n\t\t}\n\n\t\tg.board[row][col] = g.turnPlayer\n\t\twinner := checkForWinner(g)\n\t\tif winner != 0 {\n\t\t\tif winner != 3 {\n\t\t\t\tg.winner = winner\n\t\t\t}\n\t\t\tg.status = 1\n\t\t} else {\n\t\t\tif g.turnPlayer == 1 {\n\t\t\t\tg.turnPlayer = 2\n\t\t\t} else {\n\t\t\t\tg.turnPlayer = 1\n\t\t\t}\n\t\t}\n\t\tallGames.Set(g.ID, g)\n\t\treturn g.status\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc checkForWinner(g gameState) int8 {\n\t// define a lambda function for checking one line\n\tcheckLine := func(startRow int, startColumn int, deltaRow int, deltaColumn int) gameResult {\n\t\tvar lastSquare squareState = g.board[startRow][startColumn]\n\t\trow, column := startRow+deltaRow, startColumn+deltaColumn\n\n\t\t// loop starts from the second square(startRow + deltaRow, startColumn + deltaColumn)\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\n\t\t\t// there can't be a winner if a empty square is present within the line\n\t\t\tif g.board[row][column] == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+deltaRow, column+deltaColumn\n\t\t}\n\n\t\t// someone has won the game\n\t\tif lastSquare == 1 {\n\t\t\treturn 1\n\t\t} else if lastSquare == 2 {\n\t\t\treturn 2\n\t\t}\n\n\t\treturn 0\n\t}\n\n\t// check horizontal rows\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check vertical columns\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(column, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check top-left to bottom-right diagonal\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\t// check top-right to bottom-left diagonal\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\t// check for draw\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// if no one wins yet, but none of the squares are empty\n\treturn 3\n}\n\nfunc Render(path string) string {\n\treturn \"Welcome to tictactoe\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"500000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AtbNEYgmLPZsATNRANRI0dXaZ/8LMp2Pl80pikkXnG2K"},"signature":"0aBVsUFvjvmLPemChRly1yKPgFn8knhWm1kWrujwVfcMYEJTXny0cZxxprXJQIhc7Ry7ky+0ffmG/C8zKAPzKQ=="}],"memo":""},"blockNum":"90506"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq","to_address":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","amount":"1ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AnK+a6mcFDjY6b/v6p7r8QFW1M1PgIoQxBgrwOoyY7v3"},"signature":"x/Im/jP6tJZ8AqEcc/XejAstA6uNrZ8oy2tIEE0qh/tWLt6WJ0iNZonpO2pxAQPE23YB7DdJYcOf2irOuKJeZw=="}],"memo":""},"blockNum":"90837"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq","to_address":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","amount":"1ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AnK+a6mcFDjY6b/v6p7r8QFW1M1PgIoQxBgrwOoyY7v3"},"signature":"plGtR7BkTnm5kyLFDuqwtPbGakSSLvL89FmHmE8bw0BHuojhEwLyR7NwabkxY6KCk5r9GFonYjhkGfGnFmW2ug=="}],"memo":""},"blockNum":"90842"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1u7y667z64x2h7vc6fmpcprgey4ck233jaww9zq","to_address":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","amount":"1ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AnK+a6mcFDjY6b/v6p7r8QFW1M1PgIoQxBgrwOoyY7v3"},"signature":"JLBz318P8vg5OylGJku/uCgzxfZIqrdRsAXN41bN9hAuK2oT6TRPBSHkutDsg+xgfPTiUihfI+C/xnaYE8Twjw=="}],"memo":""},"blockNum":"91191"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","package":{"Name":"me22","Path":"gno.land/r/test99/me22","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArpuZWPhPhGbXRDOr5vjwl7Ro++55QZaJ7/jUUbkpMHK"},"signature":"MriwBbv8qM4ZiaheNE6/7KvN8/JTxo9U/hQjm2MOQk5iQAZXHlvCsOCZxzGmwCOTiu3/2kHnYYAAa1UUn3pkKw=="}],"memo":""},"blockNum":"91697"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1zgggsu07z6mq277mnt6hlrnc0yhc7404t3ww0f","package":{"Name":"tictactoe","Path":"gno.land/r/clockwork/tictactoe","Files":[{"Name":"gno.mod","Body":"module gno.land/r/clockwork/tictactoe\n\nrequire (\n\t\"gno.land/p/demo/avl\" v0.0.0-latest\n)\n"},{"Name":"tictactoe.gno","Body":"package tictactoe\n\nimport (\n\t\"std\"\n\t\"strconv\"\n\n\t\"gno.land/p/demo/avl\"\n)\n\ntype gameState struct {\n\tID         int64\n\tboard      [3][3]int8\n\tturnPlayer int8\n\tplayer1    string\n\tplayer2    string\n\twinner     int8\n\tstatus     int8 // 0=open 1=closed\n}\n\nvar (\n\t// (not \"games\" because that's too useful a variable name)\n\tallGames       avl.Tree\n\tnextGameId     int64\n\tavailableGames []int64\n\tuserGames      avl.Tree\n)\n\nconst zeroes = \"000000000\"\n\n// zeroPad9 pads s to the left with zeroes until it's at least 9 bytes long.\nfunc zeroPad9(s string) string {\n\tn := 9 - len(s)\n\tif n \u003c 0 {\n\t\treturn s\n\t}\n\treturn zeroes[:n] + s\n}\n\nfunc StartGame() int64 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn startGame(caller)\n}\n\nfunc startGame(player std.Address) int64 {\n\tnextGameId++\n\t// id is zero-padded to work well with avl's alphabetic order.\n\tid := zeroPad9(strconv.FormatInt(nextGameId, 10))\n\tg := \u0026gameState{\n\t\tID:         nextGameId,\n\t\tboard:      [3][3]int8{},\n\t\tturnPlayer: 1,\n\t\tplayer1:    string(player),\n\t\tplayer2:    \"\",\n\t\tstatus:     0,\n\t}\n\tallGames.Set(string(g.ID), g)\n\tavailableGames = append(availableGames, g.ID)\n\taddGameToUser(g.ID, player)\n\treturn g.ID\n}\n\nfunc addGameToUser(gameId int64, player std.Address) {\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\t// game must be at top, because it is the latest ID\n\tgames = append([]int64{gameId}, games...)\n\tuserGames.Set(string(addr), games)\n}\n\nfunc GetGames() []int64 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn getGames(caller)\n}\n\nfunc getGames(player std.Address) []int64 {\n\tvar games []int64\n\tv, ok := userGames.Get(string(player))\n\tif ok {\n\t\tgames = v.([]int64)\n\t}\n\treturn games\n}\n\nfunc GetAvailableGames() {\n\treturn availableGames\n}\n\nfunc JoinGame(gameId int64) {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn joinGame(gameId, caller)\n}\n\nfunc joinGame(gameId int64, player std.Address) bool {\n\tgraw, ok := allGames.get(string(gameId))\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.player2 != \"\" {\n\t\t\tpanic(\"Game not available\")\n\t\t}\n\t\tg.player2 = string(player)\n\t\tallGames.Set(string(g.ID), g)\n\t\tremoveFromAvailableGames(g.ID)\n\t\treturn ok\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc indexOf(element int64, data []int64) int {\n\tfor k, v := range data {\n\t\tif element == v {\n\t\t\treturn k\n\t\t}\n\t}\n\treturn -1 // not found.\n}\n\nfunc removeFromAvailableGames(gameId int64) {\n\tindex := indexOf(gameId, availableGames)\n\tif index == -1 {\n\t\tpanic(\"Game was not available\")\n\t}\n\tif index == 0 \u0026\u0026 len(availableGames) == 1 {\n\t\tavailableGames = []int64{}\n\t} else {\n\t\tnewAvailableGames := availableGames[:len(availableGames)-1]\n\t\tnewAvailableGames[index] = availableGames[len(availableGames)-1]\n\t\tavailableGames = append([]int64{}, newAvailableGames...)\n\t}\n}\n\nfunc MakeMove(gameId int64, row, col int8) int8 {\n\tstd.AssertOriginCall()\n\tcaller := std.GetOrigCaller()\n\treturn makeMove(gameId, caller)\n}\n\nfunc makeMove(gameId int64, row, col int8, player std.Address) int8 {\n\tgraw, ok := allGames.Get(string(gameId))\n\tif ok {\n\t\tg := graw.(*gameState)\n\t\tif g.status == 1 {\n\t\t\tpanic(\"Game has ended\")\n\t\t}\n\t\tif g.player1 != string(player) \u0026\u0026 g.player2 != string(player) {\n\t\t\tpanic(\"You are not part of this game\")\n\t\t}\n\t\tif (g.turnPlayer == 1 \u0026\u0026 g.player1 != string(player)) || (g.turnPlayer == 2 \u0026\u0026 g.player2 != string(player)) {\n\t\t\tpanic(\"Not your turn\")\n\t\t}\n\t\tif row \u003c 0 || col \u003c 0 || row \u003e= 3 || col \u003e= 3 {\n\t\t\tpanic(\"Move position out of bounds\")\n\t\t}\n\t\tif g.board[row][col] != 0 {\n\t\t\tpanic(\"Square not empty\")\n\t\t}\n\n\t\tg.board[row][col] = g.turnPlayer\n\t\twinner := checkForWinner(g)\n\t\tif winner != 0 {\n\t\t\tif winner != 3 {\n\t\t\t\tg.winner = winner\n\t\t\t}\n\t\t\tg.status = 1\n\t\t} else {\n\t\t\tif g.turnPlayer == 1 {\n\t\t\t\tg.turnPlayer = 2\n\t\t\t} else {\n\t\t\t\tg.turnPlayer = 1\n\t\t\t}\n\t\t}\n\t\tallGames.Set(g.ID, g)\n\t\treturn g.status\n\t}\n\tpanic(\"Game not found\")\n}\n\nfunc checkForWinner(g gameState) int8 {\n\t// define a lambda function for checking one line\n\tcheckLine := func(startRow int, startColumn int, deltaRow int, deltaColumn int) gameResult {\n\t\tvar lastSquare squareState = g.board[startRow][startColumn]\n\t\trow, column := startRow+deltaRow, startColumn+deltaColumn\n\n\t\t// loop starts from the second square(startRow + deltaRow, startColumn + deltaColumn)\n\t\tfor row \u003e= 0 \u0026\u0026 column \u003e= 0 \u0026\u0026 row \u003c 3 \u0026\u0026 column \u003c 3 {\n\n\t\t\t// there can't be a winner if a empty square is present within the line\n\t\t\tif g.board[row][column] == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tif lastSquare != g.board[row][column] {\n\t\t\t\treturn 0\n\t\t\t}\n\n\t\t\tlastSquare = g.board[row][column]\n\t\t\trow, column = row+deltaRow, column+deltaColumn\n\t\t}\n\n\t\t// someone has won the game\n\t\tif lastSquare == 1 {\n\t\t\treturn 1\n\t\t} else if lastSquare == 2 {\n\t\t\treturn 2\n\t\t}\n\n\t\treturn 0\n\t}\n\n\t// check horizontal rows\n\tfor row := 0; row \u003c 3; row++ {\n\t\tif result := checkLine(row, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check vertical columns\n\tfor column := 0; column \u003c 3; column++ {\n\t\tif result := checkLine(column, 0, 0, 1); result != 0 {\n\t\t\treturn result\n\t\t}\n\t}\n\t// check top-left to bottom-right diagonal\n\tif result := checkLine(0, 0, 1, 1); result != 0 {\n\t\treturn result\n\t}\n\t// check top-right to bottom-left diagonal\n\tif result := checkLine(0, 2, 1, -1); result != 0 {\n\t\treturn result\n\t}\n\t// check for draw\n\tfor _, row := range g.board {\n\t\tfor _, square := range row {\n\t\t\tif square == 0 {\n\t\t\t\treturn 0\n\t\t\t}\n\t\t}\n\t}\n\t// if no one wins yet, but none of the squares are empty\n\treturn 3\n}\n\nfunc Render(path string) string {\n\treturn \"Welcome to tictactoe\"\n}\n"}]},"deposit":""}],"fee":{"gas_wanted":"500000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AtbNEYgmLPZsATNRANRI0dXaZ/8LMp2Pl80pikkXnG2K"},"signature":"KEuXtt2jWku2HPv5wPei/5pucN1V/owtvqf4oqxTLj4o/f5ds0w5KsT7xa8q0yded5/34ji3ONJG+y5Zithrcg=="}],"memo":""},"blockNum":"91711"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","package":{"Name":"asdads","Path":"gno.land/r/asdasd/asdads","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArpuZWPhPhGbXRDOr5vjwl7Ro++55QZaJ7/jUUbkpMHK"},"signature":"oqnbYPm5U1v5rfkZNMDOA6GIfxc43DeIkgl0xHGoLkk50UTFaEW9QYOGnWZaXk79JjTyNOjKhyEpJFh3KIHcWw=="}],"memo":""},"blockNum":"93248"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14vhcdsyf83ngsrrqc92kmw8q9xakqjm0v8448t","send":"","pkg_path":"gno.land/r/demo/minter","func":"Mint","args":["g139lgdt3puegy4rxhe4hfq9tg2yj6a0qfzs8jgc","ugnot","310000000"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgiTyNXOXskkkxKv2DXaDxFtabuTPHlltbYwCOBpHL3w"},"signature":"vOG3gvU7gcfXeIJINYZcTv+TREj12CcnWiPXZoFWdfQJzfYrUln+/yEekpvcODiARB1rXXb6YJVhiv6J8PKxbQ=="}],"memo":""},"blockNum":"93443"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g14qvahvnnllzwl9ehn3mkph248uapsehwgfe4pt","to_address":"g15aqqnlhfupy6m3yma99c067jvnsgtltsh2gl4c","amount":"1000004ugnot"}],"fee":{"gas_wanted":"3000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5URci9hJassjEJK8dwEUhep/AJr+eQRSE0spEpAwLr9"},"signature":"7lmUnUi1vADFkIGciQG90r92wSSVBLluJk6xlP1yXGdXOwYkWtefAeEiMOZ30xNTRfMZR79X4rCuJvKDafWzpw=="}],"memo":""},"blockNum":"93895"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g14qvahvnnllzwl9ehn3mkph248uapsehwgfe4pt","to_address":"g15aqqnlhfupy6m3yma99c067jvnsgtltsh2gl4c","amount":"1000005ugnot"}],"fee":{"gas_wanted":"3000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5URci9hJassjEJK8dwEUhep/AJr+eQRSE0spEpAwLr9"},"signature":"hq/XDxSJzILGJ0lPLhaSmxk4s+Vum3rLPQboZkZnIzca4U2UWuijypUrI9UiZxGTxAdqj2R5MH/slT4nqSnMzA=="}],"memo":""},"blockNum":"93897"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14qvahvnnllzwl9ehn3mkph248uapsehwgfe4pt","send":"","pkg_path":"gno.land/p/demo/hiba","func":"abcde","args":["hiba"]}],"fee":{"gas_wanted":"3000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5URci9hJassjEJK8dwEUhep/AJr+eQRSE0spEpAwLr9"},"signature":"i9k5BlOsRsx37H0UQyREyk1EFLNbTRRfHMIYUM00NaIq6p3HqCq2uFDqWOYOBqaNKB7PLZZo1QRxtbPtDV4rIg=="}],"memo":""},"blockNum":"93899"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g14qvahvnnllzwl9ehn3mkph248uapsehwgfe4pt","to_address":"g1ffzxha57dh0qgv9ma5v393ur0zexfvp6lsjpae","amount":"10000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5URci9hJassjEJK8dwEUhep/AJr+eQRSE0spEpAwLr9"},"signature":"HbXCeYrP0K7HH78wlqXVzV1DdMaJVz2fqbrh7TCbraxzN7jwGHorfEJiLzj5nJb3J9zlM23ODJgG8PPmoFgK3A=="}],"memo":"hi jinoooooooos"},"blockNum":"93907"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g14qvahvnnllzwl9ehn3mkph248uapsehwgfe4pt","package":{"Name":"gg12gg","Path":"gno.land/r/demo/gg12gg","Files":[{"Name":"gg12gg.gno","Body":"package hello\n\nfunc Hello() string {\n\treturn \"Hello() called\"\n}\n\nfunc Render() string {\n\treturn \"Render() called\"\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5URci9hJassjEJK8dwEUhep/AJr+eQRSE0spEpAwLr9"},"signature":"Fak/qfvXGWT1iXS7bfV3dnVFCw/JnmWwPtaiGFdH1dB6hFT4yGlVAFS/QK9H3DKgFeYF0cUSkOcKk5Pn6+JpsQ=="}],"memo":""},"blockNum":"93916"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g14qvahvnnllzwl9ehn3mkph248uapsehwgfe4pt","package":{"Name":"gg12344gg","Path":"gno.land/r/demo/gg12344gg","Files":[{"Name":"gg12344gg.gno","Body":"package hello\n\nfunc Hello() string {\n\treturn \"Hello() called\"\n}\n\nfunc Render() string {\n\treturn \"Render() called\"\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5URci9hJassjEJK8dwEUhep/AJr+eQRSE0spEpAwLr9"},"signature":"FR7RHnCJB3MGiH/U1QLSfgsJxkzxaFjrNOvJXzwmx45paw1OrXDe+VF5KV0jcFDFd25DjUZbb7ByTMK6SKUaow=="}],"memo":""},"blockNum":"93918"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g14qvahvnnllzwl9ehn3mkph248uapsehwgfe4pt","package":{"Name":"gggg","Path":"gno.land/r/demo/gggg","Files":[{"Name":"hello.gno","Body":"package hello\n\nfunc Hello() string {\n\treturn \"Hello() called\"\n}\n\nfunc Render() string {\n\treturn \"Render() called\"\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5URci9hJassjEJK8dwEUhep/AJr+eQRSE0spEpAwLr9"},"signature":"pT8NevkzpEPvPyFRJrSydxlvSqkxH723sbsrRIsZVGJlOYuSHZlhKQufM1uW5/rwjq4i3gvWstwmJwf9JtbdQA=="}],"memo":""},"blockNum":"93920"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14qvahvnnllzwl9ehn3mkph248uapsehwgfe4pt","send":"","pkg_path":"gno.land/r/demo/tong","func":"Transfer","args":["g15aqqnlhfupy6m3yma99c067jvnsgtltsh2gl4c","1500"]}],"fee":{"gas_wanted":"9000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5URci9hJassjEJK8dwEUhep/AJr+eQRSE0spEpAwLr9"},"signature":"gadYBtPx5r6AT//fgwi92QHuTojfJFqzxk/h2a9b+t98At6qniZt/r1aRjeJWHVXUF4/U0x5KzuRDKvYHePN4A=="}],"memo":""},"blockNum":"93923"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14qvahvnnllzwl9ehn3mkph248uapsehwgfe4pt","send":"","pkg_path":"gno.land/r/demo/tong","func":"Transfer","args":["g15aqqnlhfupy6m3yma99c067jvnsgtltsh2gl4c","150000"]}],"fee":{"gas_wanted":"9000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5URci9hJassjEJK8dwEUhep/AJr+eQRSE0spEpAwLr9"},"signature":"CsLydhCrnJZ375CdsfCZcHnvs+K+tvXYSviO2af4+nBVr3vpP5MnSG4pdQX2d6HuMOWeDG7fFXKhGxFCLNrmtg=="}],"memo":""},"blockNum":"93925"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14qvahvnnllzwl9ehn3mkph248uapsehwgfe4pt","send":"","pkg_path":"gno.land/r/demo/tong","func":"Transfer","args":["g15aqqnlhfupy6m3yma99c067jvnsgtltsh2gl4c","3500"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5URci9hJassjEJK8dwEUhep/AJr+eQRSE0spEpAwLr9"},"signature":"Qca8FHL4VsLva4BT5Loj2HhRRoJcNOZxVGwQeaSPDC81T60GSmy7jZT9q4MAOhPf43Tep6rFcx1wi/CBiLEj/A=="}],"memo":""},"blockNum":"93927"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14qvahvnnllzwl9ehn3mkph248uapsehwgfe4pt","send":"","pkg_path":"gno.land/r/demo/tong","func":"Transfer","args":["g15aqqnlhfupy6m3yma99c067jvnsgtltsh2gl4c","100000"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5URci9hJassjEJK8dwEUhep/AJr+eQRSE0spEpAwLr9"},"signature":"wDwyjdasLE+tZkehbXTuGaj5HzIiVIParyf334P0XelEFoS76uQrpJQ3Vog5s9YjgdbTA3YL3/jv83ypmp6XCQ=="}],"memo":""},"blockNum":"93930"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1fnakf9vrd6uqn8qdmp88yam4p0ngy572answ9f","package":{"Name":"testingse","Path":"gno.land/r/demo/testingse","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n\treturn \"Hello World!\"\n}\n"},{"Name":"asdf.gno","Body":""}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3cWVULHSHC1mwK8o1vfJHKfNMvLEvKU/sHPQoFWRoey"},"signature":"alOJP/JcEdrzvsl8JZASu40WaRsHfV9RFNGWMCCXlqRe0gg8GBMo2y9YvOCdrgaBrncLtn454SxAbqzypv5DNQ=="}],"memo":""},"blockNum":"94325"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1fnakf9vrd6uqn8qdmp88yam4p0ngy572answ9f","package":{"Name":"nope","Path":"gno.land/r/demo/nope","Files":[{"Name":"package.gno","Body":"package nope\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"},{"Name":"asdf.gno","Body":"package nope\r\n\r\nfunc Render(path string) string {\r\n  return \"Hello World!\"\r\n}\r\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3cWVULHSHC1mwK8o1vfJHKfNMvLEvKU/sHPQoFWRoey"},"signature":"3TGanbtm0Y3nBWqkn2w48eCHdMXbaN//Idtp4deJuldbjrDoHGt/jfQ3AIQnsFquCD1lyZ8vu64CwoDVbxXJdw=="}],"memo":""},"blockNum":"94329"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1fnakf9vrd6uqn8qdmp88yam4p0ngy572answ9f","to_address":"g1fnakf9vrd6uqn8qdmp88yam4p0ngy572answ9f","amount":"1000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3cWVULHSHC1mwK8o1vfJHKfNMvLEvKU/sHPQoFWRoey"},"signature":"xVLrQQY2RF0u9fd66oUgO52I536LBw7AFLBhYLtDJLNBgvIHO/aLMudqOA4Go4B0HdPiUtwtgSbzYsVyWfTuvQ=="}],"memo":""},"blockNum":"94331"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1fnakf9vrd6uqn8qdmp88yam4p0ngy572answ9f","send":"","pkg_path":"gno.land/r/demo/gnoph","func":"Transfer","args":["g1h7sxqvet2psvsnnqdj2e8ldwj037s8uwhs7pew","12"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3cWVULHSHC1mwK8o1vfJHKfNMvLEvKU/sHPQoFWRoey"},"signature":"vxtJrltb+OL1cIO3G02peBg3RFRTEAvKuunHyLBPyzJsMcETtePqMLY6l/TABTRi0S6202MhqNnhMrMJ+vqNcg=="}],"memo":""},"blockNum":"94334"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1fnakf9vrd6uqn8qdmp88yam4p0ngy572answ9f","to_address":"g1fnakf9vrd6uqn8qdmp88yam4p0ngy572answ9f","amount":"1000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3cWVULHSHC1mwK8o1vfJHKfNMvLEvKU/sHPQoFWRoey"},"signature":"nPPUs1nWFY2+/ztpPpHquR/+DnwVYCv1TYo+XF1vYyUbknkxbi5XTtdlB/ZJZJdXknSkP/6WtzmK+3MANsOLeQ=="}],"memo":""},"blockNum":"94345"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1fnakf9vrd6uqn8qdmp88yam4p0ngy572answ9f","to_address":"g1h7sxqvet2psvsnnqdj2e8ldwj037s8uwhs7pew","amount":"1000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3cWVULHSHC1mwK8o1vfJHKfNMvLEvKU/sHPQoFWRoey"},"signature":"Gtc2sZEXpuKQTlrkd24NZLHbKbaCp3OI+8PKm2CcWKIBC8nEsfjbAiFYIkY5t4aeag4bEuLPO0BO1H6NTqndCw=="}],"memo":""},"blockNum":"94348"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13enw4ph4jwh2mqv07pxcsesyam5605cydps77n","to_address":"g1qv3dqyw46fut94z9t90jka58saw2e7l99nzqtr","amount":"602000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3JoC0+RVv9CQsgf4X359CS2cPelnoPDiVtGW/ppfqfN"},"signature":"MVChApGOTODgx3/IePMlNrQRfpphztuvppS5cXjoG6BiDtBJDYJsmLH1Vlrn9szmnTChMngGawy7EbqqMouToA=="}],"memo":""},"blockNum":"94411"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g15aqqnlhfupy6m3yma99c067jvnsgtltsh2gl4c","to_address":"g14qvahvnnllzwl9ehn3mkph248uapsehwgfe4pt","amount":"12000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A27+HjKCKEmzyBEVKKRYN/8ItA49KusmYvj05+rlSD0p"},"signature":"nLWIachRpSlFcxbFH2n4Es6Eag5MsoP3yzvPKE7hyC0y7BhKEGsf+2zEEFi+Q5S9tniV0VNVsW//B05FXUZngA=="}],"memo":""},"blockNum":"94560"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14qvahvnnllzwl9ehn3mkph248uapsehwgfe4pt","send":"","pkg_path":"gno.land/r/demo/tong","func":"Transfer","args":["g15aqqnlhfupy6m3yma99c067jvnsgtltsh2gl4c","40000"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5URci9hJassjEJK8dwEUhep/AJr+eQRSE0spEpAwLr9"},"signature":"uOtsNXzUYudZ5P+PIQft4pwQQyn+RhEVghoD6RMkMHxmU//uGcZrXSYWnlsJ6eHgY1Dk7Qi9huqGnLWvCVZZdw=="}],"memo":""},"blockNum":"94569"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","package":{"Name":"hello2","Path":"gno.land/p/test919/hello2","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArpuZWPhPhGbXRDOr5vjwl7Ro++55QZaJ7/jUUbkpMHK"},"signature":"KTfPD3IbyKTxbpIHKB+dD8yXy9mC463tgGBv+5G8iG5lFqi8diTKin0Rc9xaM4yXC6bWyITB899yC02cQwbRqA=="}],"memo":""},"blockNum":"94586"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","to_address":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","amount":"40000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArpuZWPhPhGbXRDOr5vjwl7Ro++55QZaJ7/jUUbkpMHK"},"signature":"R6qOLY+ouKRSOoSRClitO5Y8/AxphSxxu1sQwlnOL3RqkR6BsQ3WI6O5MnpkCT2SfeHu7BwO3JCNNfgyrlqR+w=="}],"memo":""},"blockNum":"94694"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","package":{"Name":"echo","Path":"gno.land/p/broken/echo","Files":[{"Name":"hello.gno","Body":"package broken\n\nfunc Echo(text string) string {\n    return text kaputt!\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"SGsNGY1Fp4E0jBX2jlYowqSqpRGQfwb/vHZplcA9bY4dz8pn7KYjx1dSQ5sa7mt1Ni6m+Sj5/02txAVvpZrgOw=="}],"memo":""},"blockNum":"94722"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","package":{"Name":"hueco","Path":"gno.land/p/marbella/hueco","Files":[{"Name":"hello.gno","Body":"package hueco\n\nfunc Echo(text string) string {\n    return text\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"11Q++h2hvUyrY8lX1UzMB23IrXxW/AJHx3WUwUzDQctDg1GQzPZFDwKqsKd4jlG//1GZalkTpmGyWDCrbFqUsA=="}],"memo":""},"blockNum":"94735"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","package":{"Name":"hueco","Path":"gno.land/p/marbella/hueco/v2","Files":[{"Name":"hueco.gno","Body":"package hueco\n\nfunc Echo(v string) string {\n\treturn v\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"1Lse53bF0XF46HSqSzieYMecfR5Hyr7t8yiAY3r8Q78ppm6ldKmqUaZ71R32Q25F1cNyES3+Wgr3BmHvNbr8nw=="}],"memo":""},"blockNum":"94745"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","pkg_path":"gno.land/p/marbella/hueco/v2","func":"Echo","args":["Hey"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"MLgPUL18T/a2aBz48xpSxoAzNq/fr2nqNPIr9BEzJAwxLWjHTZ/WtfzoI4MlRqlPQwGNnMscrxx/rRl2NgrUtQ=="}],"memo":""},"blockNum":"94752"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","package":{"Name":"huecoco","Path":"gno.land/r/marbella/huecoco","Files":[{"Name":"hello.gno","Body":"package huecoco\n\nimport (\n    \"gno.land/p/demo/ufmt\"\n    hueco \"gno.land/p/marbella/hueco/v2\"\n)\n\nfunc Echo(v string) string {\n    return ufmt.Sprintf(\"echo: %s\", hueco.Echo(v))\n}"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"0Dell+ZzOILAgVVqKKfxoC7g9kWY6UpmjSyh2wWb3bJqRt4pGnlC+XsD3WyxtEy4YFfu+yvOVQPzXFs0+lCcuw=="}],"memo":""},"blockNum":"94783"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","pkg_path":"gno.land/e/marbella/huecoco","func":"Echo","args":["Hey"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"90x1snd80MUoUGgvbr+mJOxtKfGs4P4xe6xlKy7Mr3UpC1LjBfv4B1VXlRBjOWjTb6WzKcYx5dyYkd5O09qlfA=="}],"memo":""},"blockNum":"94787"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","send":"","pkg_path":"gno.land/r/marbella/huecoco","func":"Echo","args":["Hey"]}],"fee":{"gas_wanted":"5000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"sBulqgnUbvTwMyF14LeWj9OI7qRAq2bq9FxivzIQo2ApGCbRFCFiG3aV7PuTmfaOkecPOIIYVpaFtyXwdzrKjg=="}],"memo":""},"blockNum":"94789"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"Name":"hello","Path":"gno.land/p/test10/hello","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"XSbHGqJIHkXVNvdo6Yyr/WRCA95M0nsiKn8OrsXUO/p+FFyJ066Obc79oVdRv7u0Ur5W8hrxf15xTk5cENyC0A=="}],"memo":""},"blockNum":"94875"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"Name":"hello","Path":"gno.land/p/test10/hello","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"hislX8uKeB0b7ZIo5iHNsIBBT7nhNic8w8hkzo4WpgF+Vsck3oORqohyy/8AcxETdyqmw7TmynYviOLSa+XEQQ=="}],"memo":""},"blockNum":"94878"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"Name":"hello","Path":"gno.land/p/test10/hello","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"MAmRdceeBTu/fMOnh3ywMywbjWVv+f9pKoPJatcdXWZBNu4djQDCJJitXJ/6Viq1EI/dlaQESFxOz943fugkUA=="}],"memo":""},"blockNum":"94881"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"Name":"hello","Path":"gno.land/p/test10/hello","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"2hSZ6q2jBhePL+bvlNtDC37Mkmkkztqnpdl9TjYV1GAvTDIaDJnUyncBBU1Fd3XHEVqEA2Y2naTn8vtxb4E19A=="}],"memo":""},"blockNum":"94883"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","package":{"Name":"hello","Path":"gno.land/p/test10/hello","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"mIrReSZDBuKbHz6cWIaW/9bldsuRqngf/Vj19ziSAPRys7Fm4ZzSH2FGlgEBW72/s8HgevxEBc1hiyh54zAMaQ=="}],"memo":""},"blockNum":"94885"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g14qvahvnnllzwl9ehn3mkph248uapsehwgfe4pt","to_address":"g15aqqnlhfupy6m3yma99c067jvnsgtltsh2gl4c","amount":"111234ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5URci9hJassjEJK8dwEUhep/AJr+eQRSE0spEpAwLr9"},"signature":"3mGZKQDpezDEhPi9oxEI4pNG3ZYevGAz7GoO93JVd9pN3fr6VrzCqCDLhoBlNQPRm4YOtDnRk1/e6O+grfL3EQ=="}],"memo":""},"blockNum":"95554"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g14qvahvnnllzwl9ehn3mkph248uapsehwgfe4pt","to_address":"g1l47x640c4petu4chfjge3qg2uplakx78hkxqxd","amount":"123456ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A5URci9hJassjEJK8dwEUhep/AJr+eQRSE0spEpAwLr9"},"signature":"QekVMXwdA+y4w/7ssbcc6BcLqFAAWWDhAIIvF15IcvBdqlqy8jPRCr/7/OxWI4gDio7b2I8nQiSpIPFIS6wrhw=="}],"memo":""},"blockNum":"95556"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1hy6zry03hg5d8le9s2w4fxme6236hkgd928dun","package":{"Name":"barv1","Path":"gno.land/p/foo/barv1","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AvC68IPWD/o8iYM+et/K6YpBp4+m0hF3mLXIdFZnWH1Y"},"signature":"XvpZ48ujMh+CFKiwfzCniqF4f39BgWaMPrqvqcdRumQ2JYA40IdEDV3sIF5m25Zcohzf5o3TMxnDDWih85Vl2g=="}],"memo":""},"blockNum":"95655"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","package":{"Name":"dasfasf","Path":"gno.land/p/aadsasd/dasfasf","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArpuZWPhPhGbXRDOr5vjwl7Ro++55QZaJ7/jUUbkpMHK"},"signature":"D6Dcc+CU8J2UC8UF0W3fchJ/rITp+EyIKKUmcqjZwmQ5IUW/QT/f6AmNEfOOgTXaH3ZaBpZeC+wfXLa69icyyQ=="}],"memo":""},"blockNum":"95910"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","package":{"Name":"555","Path":"gno.land/p/gfhfh/555","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) st[tring {\n\treturn \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArpuZWPhPhGbXRDOr5vjwl7Ro++55QZaJ7/jUUbkpMHK"},"signature":"sRFd79vQGzqQLXPhAUEtkqAuHmClOBtEGR5yuV0AqJ428UbqO992uMO1v1wGRGMDHDnIINUuAFlPhNIEEMKN8w=="}],"memo":""},"blockNum":"96296"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13enw4ph4jwh2mqv07pxcsesyam5605cydps77n","to_address":"g1qv3dqyw46fut94z9t90jka58saw2e7l99nzqtr","amount":"1000081704ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3JoC0+RVv9CQsgf4X359CS2cPelnoPDiVtGW/ppfqfN"},"signature":"Na0tWMIvrjVqWtcwlm+XTVO5rPuRW/R44F3yiqFW/+MW4DpcKddp6ZF3AS9jBAL0HHVLEIUJu8CMb8/hZ7MxgA=="}],"memo":""},"blockNum":"97124"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","to_address":"g1kcdd3n0d472g2p5l8svyg9t0wq6h5857nq992f","amount":"13000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"Qxm9ApEtVAkr/bz5wjHva64KQgjRea6ykZYHWFHJMQQObu6TuGJ7yNeqVz/I2IKAL820wjqWLihnR0igU2StQQ=="}],"memo":""},"blockNum":"97348"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/position","func":"Mint","args":["bar","foo","10000","5000","15000","5000000","5000000","1","1","9999999999"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"KzAGCdniXes/M92nLgnQKlq1vd5jiGYR5NmEuNTex/g9g7cvsESZA4yqYqbeHlvTgG6H0/AaW9EBoVcgDsPH0w=="}],"memo":""},"blockNum":"97350"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/position","func":"Mint","args":["bar","foo","10000","5000","15000","5000000","5000000","1","1","9999999999"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"FoxjeIiTRGnODPQ61dhDppTgn3VYuHhf6ZNRU0H91yMC55wQTI9NNd5iNAl8jQNqtD4UH649KMmzlaJSqD47ZQ=="}],"memo":""},"blockNum":"97354"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/position","func":"Mint","args":["bar","foo","10000","5000","15000","5000000","5000000","1","1","9999999999"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"TUbh0XcBl6wyeHNB2/R7IEiT0JR3DBd3G4iMUMr74HENUcKQF3DNWSJ+bhamTPtgnSzmRkNWATz6meeXScuRsQ=="}],"memo":""},"blockNum":"97356"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/position","func":"Mint","args":["bar","foo","10000","5000","15000","5000000","5000000","1","1","9999999999"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"wL7sj04hcG4vVGJ5WmF96+G85RT1pOvP16vYXm4pKIp6mURVSt1sEKxwfAUlora8+XUrjwLNKz5Qw6WGQVMSDA=="}],"memo":""},"blockNum":"97359"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/position","func":"Mint","args":["bar","foo","10000","5000","15000","5000000","5000000","1","1","9999999999"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"7LTKv+UWpUZ973DqBSFWkxtZePmxhWvCSsrArYZGq112XXVx0VUsY7qfQWe9Ge11BZ1COjXaqayFPdcs0P1rnQ=="}],"memo":""},"blockNum":"97369"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/position","func":"Mint","args":["bar","foo","10000","5000","15000","5000000","5000000","1","1","9999999999"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"b5C0VjUDUf5sunxuCqAjHc7yELRBKlMd88SQ2ojBIgperSsNphd9Vou5XSEqS3whIPdDoFJhXWjWqpHYIqsxJQ=="}],"memo":""},"blockNum":"97371"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/position","func":"Mint","args":["bar","foo","10000","5000","15000","5000000","5000000","1","1","9999999999"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"cxkc63PUEfELcBqNbGb4hZxOFtAJ7bhkDdKKjsIl6xEbCBGGYZYwv59SUrktj8s09gbsB/kwbvIPkw8/c5dUkw=="}],"memo":""},"blockNum":"97373"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/position","func":"Mint","args":["bar","foo","10000","5000","15000","5000000","5000000","1","1","9999999999"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"i6H3+OnsFAHUOpNDsz4cJjXUBnKvDWdK50nvXwsSMaMqeVryhg1/rN4GyQK/TxoMz66JrMl2C6JXSCAFI5KPwQ=="}],"memo":""},"blockNum":"97375"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/position","func":"Mint","args":["bar","foo","10000","5000","15000","5000000","5000000","1","1","9999999999"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"6IYaSskN1pRiLvYqAcSbnhLnH9tW33LIvGOg+BnydSFvhR95aO+xB45YEXzI2ZJJrHnA1mAguZZ9oNuAPSAeiA=="}],"memo":""},"blockNum":"97377"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/position","func":"Mint","args":["bar","foo","10000","5000","15000","5000000","5000000","1","1","9999999999"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"bmLo1k0wKE3SWT0FNw1GmfXAH/me0w+Y/S1r2qCAK0QZOI/5+X/2IlkbDo3PXaVol8FFby5WEHA0rkyhL8S5EA=="}],"memo":""},"blockNum":"97379"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1jg8mtutu9khhfwc4nxmuhcpftf0pajdhfvsqf5","send":"","pkg_path":"gno.land/r/position","func":"Mint","args":["bar","foo","10000","5000","15000","5000000","5000000","1","1","9999999999"]}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+FhNtsXHjLfSJk1lB8FbiL4mGPjc50Kt81J7EKDnJ2y"},"signature":"vAD6lPkOqHxwnYxziwy2Pgs7gB1BMfLyBY/7goPo8U5U/+c31z05tHb42D/7U+DH41AwBEkXexQo7AEnuQlnuA=="}],"memo":""},"blockNum":"97382"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g14vhcdsyf83ngsrrqc92kmw8q9xakqjm0v8448t","send":"","pkg_path":"gno.land/r/demo/minter","func":"Mint","args":["g1v0w4l3uwgwfrgav38ja53g6fkxetxnczyy8574","ugnot","310000000"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AgiTyNXOXskkkxKv2DXaDxFtabuTPHlltbYwCOBpHL3w"},"signature":"BZP0qZZYLc/Gbkm99sx8cn0DMoolPNNBsdvNBM4EbcpFVnBcWoz8ltkWbRYhDLLgwXytFfnjVhoOmMXpjv46Zg=="}],"memo":""},"blockNum":"97804"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1v0w4l3uwgwfrgav38ja53g6fkxetxnczyy8574","to_address":"g1v0w4l3uwgwfrgav38ja53g6fkxetxnczyy8574","amount":"300000000ugnot"}],"fee":{"gas_wanted":"2000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AsQyjO3EPkLQQVgfjkiB6k6BzJmxNhlRpnjwoWmQrhDh"},"signature":"El0j/2VmU5WaADoq09vDTEHoj5hbYyuZjfjfhxaI+8x1uT6QufwRhxyK6YoMYlR9cCUwmomziiYQm4sQN6PS+g=="}],"memo":""},"blockNum":"97811"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1c4f5pn9zatmyxrndncv3zsq8qmk33vf4g9gm7h","send":"","pkg_path":"gno.land/r/demo/tong","func":"Transfer","args":["g1flk9z2qmkgqeyrl654r3639rzgz7xczdfwwqw7","55"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AshocLMsZgjD1Q08bZUfI1akIdxlp2BcUNjdkX3ChTWW"},"signature":"EZA3y+lCNxhItcsbVes0RtpPwtRg1qa3gvFWJfSnqmNALu6T7+YT9rsyUbPu3qEiwc9IIQ3PMjCx7PCXAtjNXA=="}],"memo":""},"blockNum":"98740"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1c4f5pn9zatmyxrndncv3zsq8qmk33vf4g9gm7h","send":"","pkg_path":"gno.land/r/demo/tong","func":"Transfer","args":["g1flk9z2qmkgqeyrl654r3639rzgz7xczdfwwqw7","55"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AshocLMsZgjD1Q08bZUfI1akIdxlp2BcUNjdkX3ChTWW"},"signature":"xmhu/YP3Xaxg3yFKXPJUdkcwfrZWlBvc3FBDAvJ4vrAuDB8B4FHNvZ+dvW1k44WtvLQAKJF/GzGNB5Jo/J6nGg=="}],"memo":""},"blockNum":"98801"}
{"tx":{"msg":[{"@type":"/vm.m_call","caller":"g1c4f5pn9zatmyxrndncv3zsq8qmk33vf4g9gm7h","send":"","pkg_path":"gno.land/r/demo/tong","func":"Transfer","args":["g1flk9z2qmkgqeyrl654r3639rzgz7xczdfwwqw7","123"]}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"AshocLMsZgjD1Q08bZUfI1akIdxlp2BcUNjdkX3ChTWW"},"signature":"KBDA8V43aWO31ycpoookQJL1zc7ge0Wrm7epiISsZwMoIxwSsqp3tFf9A/udKXcixWKIoOG8Z21kqkAj1pRw7Q=="}],"memo":""},"blockNum":"98803"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","to_address":"g1c74t34ukg2lq39nxx5cddlkvjtfrm3zchnzvk6","amount":"20000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArpuZWPhPhGbXRDOr5vjwl7Ro++55QZaJ7/jUUbkpMHK"},"signature":"7dpEeE2JfZZ/zD5KQXCIYro4HKKtDGFo6g7VgQJwEXA7jm7TuQiIRyes73TuMc2EhfAYy+VZrfqnln5nij2pkw=="}],"memo":""},"blockNum":"98988"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g1fsu3z335h5qngf7t3lmakvpmpwg9ae76tqwh7c","to_address":"g1jxv2klra2cr6c06lcqqspqre3yyamrhfmucqld","amount":"10000000ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"ArpuZWPhPhGbXRDOr5vjwl7Ro++55QZaJ7/jUUbkpMHK"},"signature":"vVFkv5qD0dqF7elXAa2cPkP8vRDTNqCG1uXic01DD4hVnU+rQXIPaXRfgDkb20dIey2D59AdaUWIMu6RSHDHGQ=="}],"memo":""},"blockNum":"99006"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jxv2klra2cr6c06lcqqspqre3yyamrhfmucqld","package":{"Name":"hello","Path":"gno.land/p/adriana/hello","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\n"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+tN+YLGZqLVvFrpH+WvbjggXIzUENAiXqtMyvmLSO5Z"},"signature":"WC20sV2p+LIwYANPbkZzT6SZAYhkXnC54aD11vU3T6g2et2tyUQfrtSIwGdh2cgiOS2fcAR/G99K51HRZV9NXw=="}],"memo":""},"blockNum":"99012"}
{"tx":{"msg":[{"@type":"/vm.m_addpkg","creator":"g1jxv2klra2cr6c06lcqqspqre3yyamrhfmucqld","package":{"Name":"AiB","Path":"gno.land/p/Laura/AiB","Files":[{"Name":"package.gno","Body":"package hello\n\nfunc Render(path string) string {\n  return \"Hello World!\"\n}\nThis is my first Gno deployment!"}]},"deposit":"1ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1000000ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A+tN+YLGZqLVvFrpH+WvbjggXIzUENAiXqtMyvmLSO5Z"},"signature":"bND44Jy8lPFp5jxLtcsDUOUIIylE3V+/KLcq6nByaJo/T+e2XTsn8pqRyEAf9/NRDt4hO+mkUhQUDARakCe8jQ=="}],"memo":""},"blockNum":"99021"}
{"tx":{"msg":[{"@type":"/bank.MsgSend","from_address":"g13enw4ph4jwh2mqv07pxcsesyam5605cydps77n","to_address":"g1tplzvne9mspy9dh5ueyrp7mxtp0l63k2l0xn9x","amount":"1425810ugnot"}],"fee":{"gas_wanted":"1000000","gas_fee":"1ugnot"},"signatures":[{"pub_key":{"@type":"/tm.PubKeySecp256k1","value":"A3JoC0+RVv9CQsgf4X359CS2cPelnoPDiVtGW/ppfqfN"},"signature":"fSsewx+1HUpPyxBKsAUiw2koDDfvXORp4Lj+9j0vpRN1lk/N5Lbq+fy38RkCYJ+FvAvJhonZxRbCAckw6dOcFw=="}],"memo":""},"blockNum":"99850"}
